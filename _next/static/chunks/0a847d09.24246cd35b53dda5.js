(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[343],{2687:function(module,__unused_webpack_exports,__webpack_require__){var process=__webpack_require__(2040);/*!
* ONNX Runtime Web v1.15.0
* Copyright (c) Microsoft Corporation. All rights reserved.
* Licensed under the MIT License.
*/!function(er,en){module.exports=en()}(self,()=>(()=>{var __webpack_modules__={8453:(er,en,ei)=>{"use strict";ei.r(en),ei.d(en,{InferenceSession:()=>eg,Tensor:()=>ef,env:()=>eu,registerBackend:()=>es});let eo={},ea=[],es=(er,en,ei)=>{if(!en||"function"!=typeof en.init||"function"!=typeof en.createSessionHandler)throw TypeError("not a valid backend");{let es=eo[er];if(void 0===es)eo[er]={backend:en,priority:ei};else{if(es.priority>ei)return;if(es.priority===ei&&es.backend!==en)throw Error(`cannot register backend "${er}" using priority ${ei}`)}if(ei>=0){let en=ea.indexOf(er);-1!==en&&ea.splice(en,1);for(let en=0;en<ea.length;en++)if(eo[ea[en]].priority<=ei)return void ea.splice(en,0,er);ea.push(er)}}},eu=new class{constructor(){this.wasm={},this.webgl={},this.webgpu={},this.logLevelInternal="warning"}set logLevel(er){if(void 0!==er){if("string"!=typeof er||-1===["verbose","info","warning","error","fatal"].indexOf(er))throw Error(`Unsupported logging level: ${er}`);this.logLevelInternal=er}}get logLevel(){return this.logLevelInternal}},el=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array]]),ec=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),ep=!1;class ed{constructor(er,en,ei){let eo,ea,es;if((()=>{if(!ep){ep=!0;let er="undefined"!=typeof BigInt64Array&&"function"==typeof BigInt64Array.from,en="undefined"!=typeof BigUint64Array&&"function"==typeof BigUint64Array.from;er&&(el.set("int64",BigInt64Array),ec.set(BigInt64Array,"int64")),en&&(el.set("uint64",BigUint64Array),ec.set(BigUint64Array,"uint64"))}})(),"string"==typeof er){if(eo=er,es=ei,"string"===er){if(!Array.isArray(en))throw TypeError("A string tensor's data must be a string array.");ea=en}else{let ei=el.get(er);if(void 0===ei)throw TypeError(`Unsupported tensor type: ${er}.`);if(Array.isArray(en))ea=ei.from(en);else{if(!(en instanceof ei))throw TypeError(`A ${eo} tensor's data must be type of ${ei}`);ea=en}}}else if(es=en,Array.isArray(er)){if(0===er.length)throw TypeError("Tensor type cannot be inferred from an empty array.");let en=typeof er[0];if("string"===en)eo="string",ea=er;else{if("boolean"!==en)throw TypeError(`Invalid element type of data array: ${en}.`);eo="bool",ea=Uint8Array.from(er)}}else{let en=ec.get(er.constructor);if(void 0===en)throw TypeError(`Unsupported type for tensor data: ${er.constructor}.`);eo=en,ea=er}if(void 0===es)es=[ea.length];else if(!Array.isArray(es))throw TypeError("A tensor's dims must be a number array");let eu=(er=>{let en=1;for(let ei=0;ei<er.length;ei++){let eo=er[ei];if("number"!=typeof eo||!Number.isSafeInteger(eo))throw TypeError(`dims[${ei}] must be an integer, got: ${eo}`);if(eo<0)throw RangeError(`dims[${ei}] must be a non-negative integer, got: ${eo}`);en*=eo}return en})(es);if(eu!==ea.length)throw Error(`Tensor's size(${eu}) does not match data length(${ea.length}).`);this.dims=es,this.type=eo,this.data=ea,this.size=eu}static bufferToTensor(er,en){let ei,eo;if(void 0===er)throw Error("Image buffer must be defined");if(void 0===en.height||void 0===en.width)throw Error("Image height and width must be defined");if("NHWC"===en.tensorLayout)throw Error("NHWC Tensor layout is not supported yet");let{height:ea,width:es}=en,eu=en.norm??{mean:255,bias:0};ei="number"==typeof eu.mean?[eu.mean,eu.mean,eu.mean,eu.mean]:[eu.mean[0],eu.mean[1],eu.mean[2],eu.mean[3]??255],eo="number"==typeof eu.bias?[eu.bias,eu.bias,eu.bias,eu.bias]:[eu.bias[0],eu.bias[1],eu.bias[2],eu.bias[3]??0];let el=void 0!==en.bitmapFormat?en.bitmapFormat:"RGBA",ec=void 0!==en.tensorFormat&&void 0!==en.tensorFormat?en.tensorFormat:"RGB",ep=ea*es,ef=new Float32Array("RGBA"===ec?4*ep:3*ep),eh=4,eg=0,em=1,eb=2,ey=3,ev=0,e_=ep,ex=2*ep,ew=-1;"RGB"===el&&(eh=3,eg=0,em=1,eb=2,ey=-1),"RGBA"===ec?ew=3*ep:"RBG"===ec?(ev=0,ex=ep,e_=2*ep):"BGR"===ec&&(ex=0,e_=ep,ev=2*ep);for(let en=0;en<ep;en++,eg+=eh,eb+=eh,em+=eh,ey+=eh)ef[ev++]=(er[eg]+eo[0])/ei[0],ef[e_++]=(er[em]+eo[1])/ei[1],ef[ex++]=(er[eb]+eo[2])/ei[2],-1!==ew&&-1!==ey&&(ef[ew++]=(er[ey]+eo[3])/ei[3]);return new ed("float32",ef,"RGBA"===ec?[1,4,ea,es]:[1,3,ea,es])}static async fromImage(er,en){let ei="undefined"!=typeof HTMLImageElement&&er instanceof HTMLImageElement,eo="undefined"!=typeof ImageData&&er instanceof ImageData,ea="undefined"!=typeof ImageBitmap&&er instanceof ImageBitmap,es="string"==typeof er,eu,el=en??{};if(ei){let ei=document.createElement("canvas");ei.width=er.width,ei.height=er.height;let eo=ei.getContext("2d");if(null==eo)throw Error("Can not access image data");{let ei=er.height,ea=er.width;if(void 0!==en&&void 0!==en.resizedHeight&&void 0!==en.resizedWidth&&(ei=en.resizedHeight,ea=en.resizedWidth),void 0!==en){if(el=en,void 0!==en.tensorFormat)throw Error("Image input config format must be RGBA for HTMLImageElement");if(el.tensorFormat="RGBA",void 0!==en.height&&en.height!==ei)throw Error("Image input config height doesn't match HTMLImageElement height");if(el.height=ei,void 0!==en.width&&en.width!==ea)throw Error("Image input config width doesn't match HTMLImageElement width");el.width=ea}else el.tensorFormat="RGBA",el.height=ei,el.width=ea;eo.drawImage(er,0,0),eu=eo.getImageData(0,0,ea,ei).data}}else{if(!eo){if(ea){if(void 0===en)throw Error("Please provide image config with format for Imagebitmap");if(void 0!==en.bitmapFormat)throw Error("Image input config format must be defined for ImageBitmap");let ei=document.createElement("canvas").getContext("2d");if(null!=ei){let eo=er.height,ea=er.width;if(ei.drawImage(er,0,0,ea,eo),eu=ei.getImageData(0,0,ea,eo).data,void 0!==en){if(void 0!==en.height&&en.height!==eo)throw Error("Image input config height doesn't match ImageBitmap height");if(el.height=eo,void 0!==en.width&&en.width!==ea)throw Error("Image input config width doesn't match ImageBitmap width");el.width=ea}else el.height=eo,el.width=ea;return ed.bufferToTensor(eu,el)}throw Error("Can not access image data")}if(es)return new Promise((ei,eo)=>{let ea=document.createElement("canvas"),es=ea.getContext("2d");if(!er||!es)return eo();let eu=new Image;eu.crossOrigin="Anonymous",eu.src=er,eu.onload=()=>{ea.width=eu.width,ea.height=eu.height,es.drawImage(eu,0,0,ea.width,ea.height);let er=es.getImageData(0,0,ea.width,ea.height);if(void 0!==en){if(void 0!==en.height&&en.height!==ea.height)throw Error("Image input config height doesn't match height");if(el.height=ea.height,void 0!==en.width&&en.width!==ea.width)throw Error("Image input config width doesn't match width");el.width=ea.width}else el.height=ea.height,el.width=ea.width;ei(ed.bufferToTensor(er.data,el))}});throw Error("Input data provided is not supported - aborted tensor creation")}{let ei,eo;let ea="RGBA";if(void 0!==en&&void 0!==en.resizedWidth&&void 0!==en.resizedHeight?(ei=en.resizedHeight,eo=en.resizedWidth):(ei=er.height,eo=er.width),void 0!==en){if(el=en,void 0!==en.bitmapFormat&&en.bitmapFormat!==ea)throw Error("Image input config format must be RGBA for ImageData");el.bitmapFormat="RGBA"}else el.bitmapFormat="RGBA";if(el.height=ei,el.width=eo,void 0!==en){let en=document.createElement("canvas");en.width=eo,en.height=ei;let ea=en.getContext("2d");if(null==ea)throw Error("Can not access image data");ea.putImageData(er,0,0),eu=ea.getImageData(0,0,eo,ei).data}else eu=er.data}}if(void 0!==eu)return ed.bufferToTensor(eu,el);throw Error("Input data provided is not supported - aborted tensor creation")}toDataURL(er){let en=document.createElement("canvas");en.width=this.dims[3],en.height=this.dims[2];let ei=en.getContext("2d");if(null!=ei){let eo,ea,es,eu;void 0!==er?.tensorLayout&&"NHWC"===er.tensorLayout?(eo=this.dims[2],ea=this.dims[3]):(eo=this.dims[3],ea=this.dims[2]);let el=void 0!==er?.format?er.format:"RGB",ec=er?.norm;void 0===ec||void 0===ec.mean?es=[255,255,255,255]:"number"==typeof ec.mean?es=[ec.mean,ec.mean,ec.mean,ec.mean]:(es=[ec.mean[0],ec.mean[1],ec.mean[2],0],void 0!==ec.mean[3]&&(es[3]=ec.mean[3])),void 0===ec||void 0===ec.bias?eu=[0,0,0,0]:"number"==typeof ec.bias?eu=[ec.bias,ec.bias,ec.bias,ec.bias]:(eu=[ec.bias[0],ec.bias[1],ec.bias[2],0],void 0!==ec.bias[3]&&(eu[3]=ec.bias[3]));let ep=ea*eo,ed=0,ef=ep,eh=2*ep,eg=-1;"RGBA"===el?(ed=0,ef=ep,eh=2*ep,eg=3*ep):"RGB"===el?(ed=0,ef=ep,eh=2*ep):"RBG"===el&&(ed=0,eh=ep,ef=2*ep);for(let er=0;er<ea;er++)for(let en=0;en<eo;en++){let eo=(this.data[ed++]-eu[0])*es[0],ea=(this.data[ef++]-eu[1])*es[1],el=(this.data[eh++]-eu[2])*es[2],ec=-1===eg?255:(this.data[eg++]-eu[3])*es[3];ei.fillStyle="rgba("+eo+","+ea+","+el+","+ec+")",ei.fillRect(en,er,1,1)}return en.toDataURL()}throw Error("Can not access image data")}toImageData(er){let en;let ei=document.createElement("canvas").getContext("2d");if(null==ei)throw Error("Can not access image data");{let eo,ea,es,eu,el;void 0!==er?.tensorLayout&&"NHWC"===er.tensorLayout?(eo=this.dims[2],ea=this.dims[1],es=this.dims[3]):(eo=this.dims[3],ea=this.dims[2],es=this.dims[1]);let ec=void 0!==er&&void 0!==er.format?er.format:"RGB",ep=er?.norm;void 0===ep||void 0===ep.mean?eu=[255,255,255,255]:"number"==typeof ep.mean?eu=[ep.mean,ep.mean,ep.mean,ep.mean]:(eu=[ep.mean[0],ep.mean[1],ep.mean[2],255],void 0!==ep.mean[3]&&(eu[3]=ep.mean[3])),void 0===ep||void 0===ep.bias?el=[0,0,0,0]:"number"==typeof ep.bias?el=[ep.bias,ep.bias,ep.bias,ep.bias]:(el=[ep.bias[0],ep.bias[1],ep.bias[2],0],void 0!==ep.bias[3]&&(el[3]=ep.bias[3]));let ed=ea*eo;if(void 0!==er){if(void 0!==er.height&&er.height!==ea)throw Error("Image output config height doesn't match tensor height");if(void 0!==er.width&&er.width!==eo)throw Error("Image output config width doesn't match tensor width");if(void 0!==er.format&&4===es&&"RGBA"!==er.format||3===es&&"RGB"!==er.format&&"BGR"!==er.format)throw Error("Tensor format doesn't match input tensor dims")}let ef=4,eh=0,eg=1,em=2,eb=3,ey=0,ev=ed,e_=2*ed,ex=-1;"RGBA"===ec?(ey=0,ev=ed,e_=2*ed,ex=3*ed):"RGB"===ec?(ey=0,ev=ed,e_=2*ed):"RBG"===ec&&(ey=0,e_=ed,ev=2*ed),en=ei.createImageData(eo,ea);for(let er=0;er<ea*eo;eh+=ef,eg+=ef,em+=ef,eb+=ef,er++)en.data[eh]=(this.data[ey++]-el[0])*eu[0],en.data[eg]=(this.data[ev++]-el[1])*eu[1],en.data[em]=(this.data[e_++]-el[2])*eu[2],en.data[eb]=-1===ex?255:(this.data[ex++]-el[3])*eu[3]}return en}reshape(er){return new ed(this.type,this.data,er)}}let ef=ed;class eh{constructor(er){this.handler=er}async run(er,en,ei){let eo={},ea={};if("object"!=typeof er||null===er||er instanceof ef||Array.isArray(er))throw TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let es=!0;if("object"==typeof en){if(null===en)throw TypeError("Unexpected argument[1]: cannot be null.");if(en instanceof ef)throw TypeError("'fetches' cannot be a Tensor");if(Array.isArray(en)){if(0===en.length)throw TypeError("'fetches' cannot be an empty array.");for(let er of(es=!1,en)){if("string"!=typeof er)throw TypeError("'fetches' must be a string array or an object.");if(-1===this.outputNames.indexOf(er))throw RangeError(`'fetches' contains invalid output name: ${er}.`);eo[er]=null}if("object"==typeof ei&&null!==ei)ea=ei;else if(void 0!==ei)throw TypeError("'options' must be an object.")}else{let er=!1,eu=Object.getOwnPropertyNames(en);for(let ei of this.outputNames)if(-1!==eu.indexOf(ei)){let ea=en[ei];(null===ea||ea instanceof ef)&&(er=!0,es=!1,eo[ei]=ea)}if(er){if("object"==typeof ei&&null!==ei)ea=ei;else if(void 0!==ei)throw TypeError("'options' must be an object.")}else ea=en}}else if(void 0!==en)throw TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let en of this.inputNames)if(void 0===er[en])throw Error(`input '${en}' is missing in 'feeds'.`);if(es)for(let er of this.outputNames)eo[er]=null;let eu=await this.handler.run(er,eo,ea),el={};for(let er in eu)Object.hasOwnProperty.call(eu,er)&&(el[er]=new ef(eu[er].type,eu[er].data,eu[er].dims));return el}static async create(er,en,ei,es){let eu,el={};if("string"==typeof er){if(eu=er,"object"==typeof en&&null!==en)el=en;else if(void 0!==en)throw TypeError("'options' must be an object.")}else if(er instanceof Uint8Array){if(eu=er,"object"==typeof en&&null!==en)el=en;else if(void 0!==en)throw TypeError("'options' must be an object.")}else{if(!(er instanceof ArrayBuffer||"undefined"!=typeof SharedArrayBuffer&&er instanceof SharedArrayBuffer))throw TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");{let eo=er,ea=0,ec=er.byteLength;if("object"==typeof en&&null!==en)el=en;else if("number"==typeof en){if(!Number.isSafeInteger(ea=en))throw RangeError("'byteOffset' must be an integer.");if(ea<0||ea>=eo.byteLength)throw RangeError(`'byteOffset' is out of range [0, ${eo.byteLength}).`);if(ec=er.byteLength-ea,"number"==typeof ei){if(!Number.isSafeInteger(ec=ei))throw RangeError("'byteLength' must be an integer.");if(ec<=0||ea+ec>eo.byteLength)throw RangeError(`'byteLength' is out of range (0, ${eo.byteLength-ea}].`);if("object"==typeof es&&null!==es)el=es;else if(void 0!==es)throw TypeError("'options' must be an object.")}else if(void 0!==ei)throw TypeError("'byteLength' must be a number.")}else if(void 0!==en)throw TypeError("'options' must be an object.");eu=new Uint8Array(eo,ea,ec)}}let ec=(el.executionProviders||[]).map(er=>"string"==typeof er?er:er.name),ep=await (async er=>{let en=0===er.length?ea:er,ei=[];for(let er of en){let en=eo[er];if(en){if(en.initialized)return en.backend;if(en.aborted)continue;let eo=!!en.initPromise;try{return eo||(en.initPromise=en.backend.init()),await en.initPromise,en.initialized=!0,en.backend}catch(ea){eo||ei.push({name:er,err:ea}),en.aborted=!0}finally{delete en.initPromise}}}throw Error(`no available backend found. ERR: ${ei.map(er=>`[${er.name}] ${er.err}`).join(", ")}`)})(ec),ed=await ep.createSessionHandler(eu,el);return new eh(ed)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}let eg=eh},5716:(er,en,ei)=>{"use strict";en.R=void 0;let eo=ei(6027),ea=ei(1723);en.R=new class{async init(){}async createSessionHandler(er,en){let ei=new eo.Session(en);return await ei.loadModel(er),new ea.OnnxjsSessionHandler(ei)}}},2818:(er,en,ei)=>{"use strict";en.c8=en.rX=void 0;let eo=ei(8453),ea=ei(5381),es=ei(9544),eu=ei(6640);en.rX=()=>{if(("number"!=typeof eo.env.wasm.initTimeout||eo.env.wasm.initTimeout<0)&&(eo.env.wasm.initTimeout=0),"boolean"!=typeof eo.env.wasm.simd&&(eo.env.wasm.simd=!0),"boolean"!=typeof eo.env.wasm.proxy&&(eo.env.wasm.proxy=!1),"number"!=typeof eo.env.wasm.numThreads||!Number.isInteger(eo.env.wasm.numThreads)||eo.env.wasm.numThreads<=0){let er="undefined"==typeof navigator?(0,ea.cpus)().length:navigator.hardwareConcurrency;eo.env.wasm.numThreads=Math.min(4,Math.ceil((er||1)/2))}},en.c8=new class{async init(){(0,en.rX)(),await (0,es.initWasm)()}async createSessionHandler(er,en){let ei=new eu.OnnxruntimeWebAssemblySessionHandler;return await ei.loadModel(er,en),Promise.resolve(ei)}}},1057:function(er,en,ei){"use strict";var eo=this&&this.__createBinding||(Object.create?function(er,en,ei,eo){void 0===eo&&(eo=ei);var ea=Object.getOwnPropertyDescriptor(en,ei);ea&&!("get"in ea?!en.__esModule:ea.writable||ea.configurable)||(ea={enumerable:!0,get:function(){return en[ei]}}),Object.defineProperty(er,eo,ea)}:function(er,en,ei,eo){void 0===eo&&(eo=ei),er[eo]=en[ei]}),ea=this&&this.__exportStar||function(er,en){for(var ei in er)"default"===ei||Object.prototype.hasOwnProperty.call(en,ei)||eo(en,er,ei)};Object.defineProperty(en,"__esModule",{value:!0}),ea(ei(8453),en);let es=ei(8453);{let er=ei(5716).R;(0,es.registerBackend)("webgl",er,-10)}{let er=ei(2818).c8;(0,es.registerBackend)("cpu",er,10),(0,es.registerBackend)("wasm",er,10),(0,es.registerBackend)("xnnpack",er,9)}},4910:(er,en)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.createAttributeWithCacheKey=void 0;class ei{constructor(er){Object.assign(this,er)}get cacheKey(){return this._cacheKey||(this._cacheKey=Object.getOwnPropertyNames(this).sort().map(er=>`${this[er]}`).join(";")),this._cacheKey}}en.createAttributeWithCacheKey=er=>new ei(er)},6874:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.Attribute=void 0;let eo=ei(1446),ea=ei(1287),es=ei(9240),eu=ei(7273);var el=ea.onnxruntime.experimental.fbs;class ec{constructor(er){if(this._attributes=new Map,null!=er){for(let en of er)en instanceof eo.onnx.AttributeProto?this._attributes.set(en.name,[ec.getValue(en),ec.getType(en)]):en instanceof el.Attribute&&this._attributes.set(en.name(),[ec.getValue(en),ec.getType(en)]);if(this._attributes.size<er.length)throw Error("duplicated attribute names")}}set(er,en,ei){this._attributes.set(er,[ei,en])}delete(er){this._attributes.delete(er)}getFloat(er,en){return this.get(er,"float",en)}getInt(er,en){return this.get(er,"int",en)}getString(er,en){return this.get(er,"string",en)}getTensor(er,en){return this.get(er,"tensor",en)}getFloats(er,en){return this.get(er,"floats",en)}getInts(er,en){return this.get(er,"ints",en)}getStrings(er,en){return this.get(er,"strings",en)}getTensors(er,en){return this.get(er,"tensors",en)}get(er,en,ei){let eo=this._attributes.get(er);if(void 0===eo){if(void 0!==ei)return ei;throw Error(`required attribute not found: ${er}`)}if(eo[1]!==en)throw Error(`type mismatch: expected ${en} but got ${eo[1]}`);return eo[0]}static getType(er){let en=er instanceof eo.onnx.AttributeProto?er.type:er.type();switch(en){case eo.onnx.AttributeProto.AttributeType.FLOAT:return"float";case eo.onnx.AttributeProto.AttributeType.INT:return"int";case eo.onnx.AttributeProto.AttributeType.STRING:return"string";case eo.onnx.AttributeProto.AttributeType.TENSOR:return"tensor";case eo.onnx.AttributeProto.AttributeType.FLOATS:return"floats";case eo.onnx.AttributeProto.AttributeType.INTS:return"ints";case eo.onnx.AttributeProto.AttributeType.STRINGS:return"strings";case eo.onnx.AttributeProto.AttributeType.TENSORS:return"tensors";default:throw Error(`attribute type is not supported yet: ${eo.onnx.AttributeProto.AttributeType[en]}`)}}static getValue(er){let en=er instanceof eo.onnx.AttributeProto?er.type:er.type();if(en===eo.onnx.AttributeProto.AttributeType.GRAPH||en===eo.onnx.AttributeProto.AttributeType.GRAPHS)throw Error("graph attribute is not supported yet");let ei=this.getValueNoCheck(er);if(en===eo.onnx.AttributeProto.AttributeType.INT&&eu.LongUtil.isLong(ei))return eu.LongUtil.longToNumber(ei);if(en===eo.onnx.AttributeProto.AttributeType.INTS){let er=ei,en=Array(er.length);for(let ei=0;ei<er.length;ei++){let eo=er[ei];en[ei]=eu.LongUtil.longToNumber(eo)}return en}if(en===eo.onnx.AttributeProto.AttributeType.TENSOR)return er instanceof eo.onnx.AttributeProto?es.Tensor.fromProto(ei):es.Tensor.fromOrtTensor(ei);if(en===eo.onnx.AttributeProto.AttributeType.TENSORS){if(er instanceof eo.onnx.AttributeProto)return ei.map(er=>es.Tensor.fromProto(er));if(er instanceof el.Attribute)return ei.map(er=>es.Tensor.fromOrtTensor(er))}if(en===eo.onnx.AttributeProto.AttributeType.STRING&&er instanceof eo.onnx.AttributeProto){let er=ei;return(0,eu.decodeUtf8String)(er)}return en===eo.onnx.AttributeProto.AttributeType.STRINGS&&er instanceof eo.onnx.AttributeProto?ei.map(eu.decodeUtf8String):ei}static getValueNoCheck(er){return er instanceof eo.onnx.AttributeProto?this.getValueNoCheckFromOnnxFormat(er):this.getValueNoCheckFromOrtFormat(er)}static getValueNoCheckFromOnnxFormat(er){switch(er.type){case eo.onnx.AttributeProto.AttributeType.FLOAT:return er.f;case eo.onnx.AttributeProto.AttributeType.INT:return er.i;case eo.onnx.AttributeProto.AttributeType.STRING:return er.s;case eo.onnx.AttributeProto.AttributeType.TENSOR:return er.t;case eo.onnx.AttributeProto.AttributeType.GRAPH:return er.g;case eo.onnx.AttributeProto.AttributeType.FLOATS:return er.floats;case eo.onnx.AttributeProto.AttributeType.INTS:return er.ints;case eo.onnx.AttributeProto.AttributeType.STRINGS:return er.strings;case eo.onnx.AttributeProto.AttributeType.TENSORS:return er.tensors;case eo.onnx.AttributeProto.AttributeType.GRAPHS:return er.graphs;default:throw Error(`unsupported attribute type: ${eo.onnx.AttributeProto.AttributeType[er.type]}`)}}static getValueNoCheckFromOrtFormat(er){switch(er.type()){case el.AttributeType.FLOAT:return er.f();case el.AttributeType.INT:return er.i();case el.AttributeType.STRING:return er.s();case el.AttributeType.TENSOR:return er.t();case el.AttributeType.GRAPH:return er.g();case el.AttributeType.FLOATS:return er.floatsArray();case el.AttributeType.INTS:{let en=[];for(let ei=0;ei<er.intsLength();ei++)en.push(er.ints(ei));return en}case el.AttributeType.STRINGS:{let en=[];for(let ei=0;ei<er.stringsLength();ei++)en.push(er.strings(ei));return en}case el.AttributeType.TENSORS:{let en=[];for(let ei=0;ei<er.tensorsLength();ei++)en.push(er.tensors(ei));return en}default:throw Error(`unsupported attribute type: ${el.AttributeType[er.type()]}`)}}}en.Attribute=ec},1975:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.resolveBackend=en.backend=void 0;let eo=ei(4418),ea=new Map;async function es(er){let ei=en.backend;if(void 0!==ei[er]&&function(er){let en=er;return"initialize"in en&&"function"==typeof en.initialize&&"createSessionHandler"in en&&"function"==typeof en.createSessionHandler&&"dispose"in en&&"function"==typeof en.dispose}(ei[er])){let en=ei[er],eo=en.initialize();if("object"==typeof eo&&"then"in eo&&(eo=await eo),eo)return ea.set(er,en),en}}en.backend={webgl:new eo.WebGLBackend},en.resolveBackend=async function er(en){if(!en)return er(["webgl"]);{let er="string"==typeof en?[en]:en;for(let en of er){let er=ea.get(en);if(er)return er;let ei=await es(en);if(ei)return ei}}throw Error("no available backend to use")}},4418:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.WebGLBackend=void 0;let eo=ei(8453),ea=ei(1315),es=ei(2171),eu=ei(3389);en.WebGLBackend=class{get contextId(){return eo.env.webgl.contextId}set contextId(er){eo.env.webgl.contextId=er}get matmulMaxBatchSize(){return eo.env.webgl.matmulMaxBatchSize}set matmulMaxBatchSize(er){eo.env.webgl.matmulMaxBatchSize=er}get textureCacheMode(){return eo.env.webgl.textureCacheMode}set textureCacheMode(er){eo.env.webgl.textureCacheMode=er}get pack(){return eo.env.webgl.pack}set pack(er){eo.env.webgl.pack=er}get async(){return eo.env.webgl.async}set async(er){eo.env.webgl.async=er}initialize(){try{return this.glContext=(0,eu.createWebGLContext)(this.contextId),"number"!=typeof this.matmulMaxBatchSize&&(this.matmulMaxBatchSize=16),"string"!=typeof this.textureCacheMode&&(this.textureCacheMode="full"),"boolean"!=typeof this.pack&&(this.pack=!1),"boolean"!=typeof this.async&&(this.async=!1),ea.Logger.setWithEnv(eo.env),ea.Logger.verbose("WebGLBackend",`Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`),!0}catch(er){return ea.Logger.warning("WebGLBackend",`Unable to initialize WebGLBackend. ${er}`),!1}}createSessionHandler(er){return new es.WebGLSessionHandler(this,er)}dispose(){this.glContext.dispose()}}},6859:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.CoordsGlslLib=void 0;let eo=ei(7273),ea=ei(1997),es=ei(6757),eu=ei(7618),el=ei(432);class ec extends ea.GlslLib{constructor(er){super(er)}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},this.offsetToCoords()),this.coordsToOffset()),this.toVec()),this.valueFrom()),this.getCommonUtilFuncs()),this.getInputsSamplingSnippets()),this.getOutputSamplingSnippet())}getCustomTypes(){return{}}offsetToCoords(){return{offsetToCoords:new ea.GlslLibRoutine("\n      vec2 offsetToCoords(int offset, int width, int height) {\n        int t = offset / width;\n        int s = offset - t*width;\n        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);\n        return coords;\n      }\n      ")}}coordsToOffset(){return{coordsToOffset:new ea.GlslLibRoutine("\n      int coordsToOffset(vec2 coords, int width, int height) {\n        float s = coords.s * float(width);\n        float t = coords.t * float(height);\n        int offset = int(t) * width + int(s);\n        return offset;\n      }\n      ")}}getOutputSamplingSnippet(){let er=this.context.outputTextureLayout;return er.isPacked?this.getPackedOutputSamplingSnippet(er):this.getUnpackedOutputSamplingSnippet(er)}getPackedOutputSamplingSnippet(er){let en=er.unpackedShape,ei=[er.width,er.height],eo={},eu="getOutputCoords";switch(en.length){case 0:eo[eu]=this.getOutputScalarCoords();break;case 1:eo[eu]=this.getOutputPacked1DCoords(en,ei);break;case 2:eo[eu]=this.getOutputPacked2DCoords(en,ei);break;case 3:eo[eu]=this.getOutputPacked3DCoords(en,ei);break;default:eo[eu]=this.getOutputPackedNDCoords(en,ei)}let el=`
      void setOutput(vec4 val) {
        ${(0,es.getGlsl)(this.context.glContext.version).output} = val;
      }
    `;return eo.floatTextureSetRGBA=new ea.GlslLibRoutine(el),eo}getUnpackedOutputSamplingSnippet(er){let en=er.unpackedShape,ei=[er.width,er.height],eo={},eu="getOutputCoords";switch(en.length){case 0:eo[eu]=this.getOutputScalarCoords();break;case 1:eo[eu]=this.getOutputUnpacked1DCoords(en,ei);break;case 2:eo[eu]=this.getOutputUnpacked2DCoords(en,ei);break;case 3:eo[eu]=this.getOutputUnpacked3DCoords(en,ei);break;case 4:eo[eu]=this.getOutputUnpacked4DCoords(en,ei);break;case 5:eo[eu]=this.getOutputUnpacked5DCoords(en,ei);break;case 6:eo[eu]=this.getOutputUnpacked6DCoords(en,ei);break;default:throw Error(`Unsupported output dimensionality: ${en.length}`)}let el=`
        void setOutput(float val) {
          ${(0,es.getGlsl)(this.context.glContext.version).output} = vec4(val, 0, 0, 0);
        }
    `;return eo.floatTextureSetR=new ea.GlslLibRoutine(el),eo}getOutputScalarCoords(){return new ea.GlslLibRoutine("\n      int getOutputCoords() {\n        return 0;\n      }\n    ")}getOutputPacked1DCoords(er,en){let ei=en,eo="";return 1===ei[0]?(eo=`
          int getOutputCoords() {
            return 2 * int(TexCoords.y * ${ei[1]}.0);
          }
        `,new ea.GlslLibRoutine(eo)):1===ei[1]?(eo=`
          int getOutputCoords() {
            return 2 * int(TexCoords.x * ${ei[0]}.0);
          }
        `,new ea.GlslLibRoutine(eo)):(eo=`
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                 vec2(${ei[0]}, ${ei[1]}));
          return 2 * (resTexRC.y * ${ei[0]} + resTexRC.x);
        }
      `,new ea.GlslLibRoutine(eo))}getOutputPacked2DCoords(er,en){let ei="";if(eo.ArrayUtil.arraysEqual(er,en))return ei=`
        ivec2 getOutputCoords() {
          return 2 * ivec2(TexCoords.xy * vec2(${en[0]}, ${en[1]}));
        }
      `,new ea.GlslLibRoutine(ei);let es=en,eu=Math.ceil(er[1]/2);return ei=`
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${es[0]}, ${es[1]}));

          int index = resTexRC.y * ${es[0]} + resTexRC.x;

          // reverse r and c order for packed texture
          int r = imod(index, ${eu}) * 2;
          int c = 2 * (index / ${eu});

          return ivec2(r, c);
        }
      `,new ea.GlslLibRoutine(ei)}getOutputPacked3DCoords(er,en){let ei=[en[0],en[1]],eo=Math.ceil(er[2]/2),es=eo*Math.ceil(er[1]/2),eu=`
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${ei[0]}, ${ei[1]}));
          int index = resTexRC.y * ${ei[0]} + resTexRC.x;

          int b = index / ${es};
          index -= b * ${es};

          // reverse r and c order for packed texture
          int r = imod(index, ${eo}) * 2;
          int c = 2 * (index / ${eo});

          return ivec3(b, r, c);
        }
      `;return new ea.GlslLibRoutine(eu)}getOutputPackedNDCoords(er,en){let ei=[en[0],en[1]],eo=Math.ceil(er[er.length-1]/2),es=eo*Math.ceil(er[er.length-2]/2),eu=es,el="",ec="b, r, c";for(let en=2;en<er.length-1;en++)eu*=er[er.length-en-1],el=`
      int b${en} = index / ${eu};
      index -= b${en} * ${eu};
    `+el,ec=`b${en}, `+ec;let ep=`
      ivec${er.length} getOutputCoords() {
        ivec2 resTexRC = ivec2(TexCoords.xy *
                              vec2(${ei[0]}, ${ei[1]}));
        int index = resTexRC.y * ${ei[0]} + resTexRC.x;

        ${el}

        int b = index / ${es};
        index -= b * ${es};

        // reverse r and c order for packed texture
        int r = imod(index, ${eo}) * 2;
        int c = 2 * (index / ${eo});

        return ivec${er.length}(${ec});
      }
    `;return new ea.GlslLibRoutine(ep)}getOutputUnpacked1DCoords(er,en){let ei=`
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${en[0]}, ${en[1]}));
          return resTexRC.y * ${en[0]} + resTexRC.x;
        }
      `;return new ea.GlslLibRoutine(ei)}getOutputUnpacked2DCoords(er,en){let ei=`
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${en[0]}, ${en[1]}));
          int index = resTexRC.y * ${en[0]} + resTexRC.x;
          int r = index / ${er[1]};
          int c = index - r * ${er[1]};
          return ivec2(r, c);
        }
      `;return new ea.GlslLibRoutine(ei)}getOutputUnpacked3DCoords(er,en){let ei="",eo=er.length,es=null;eo<2&&(es=[]),(es=Array(eo-1))[eo-2]=er[eo-1];for(let en=eo-3;en>=0;--en)es[en]=es[en+1]*er[en+1];let eu=["r","c","d"],el=es.map((er,en)=>`int ${eu[en]} = index / ${er}; ${en===es.length-1?`int ${eu[en+1]} = index - ${eu[en]} * ${er}`:`index -= ${eu[en]} * ${er}`};`).join("");return ei=`
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${en[0]}, ${en[1]}));
          int index = resTexRC.y * ${en[0]} + resTexRC.x;
          ${el}
          return ivec3(r, c, d);
        }
      `,new ea.GlslLibRoutine(ei)}getOutputUnpacked4DCoords(er,en){let ei="",eo=er.length,es=null;eo<2&&(es=[]),(es=Array(eo-1))[eo-2]=er[eo-1];for(let en=eo-3;en>=0;--en)es[en]=es[en+1]*er[en+1];let eu=["r","c","d","d2"],el=es.map((er,en)=>`int ${eu[en]} = index / ${er}; ${en===es.length-1?`int ${eu[en+1]} = index - ${eu[en]} * ${er}`:`index -= ${eu[en]} * ${er}`};`).join("");return ei=`
      ivec4 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${en[0]}, ${en[1]}));
          int index = resTexRC.y * ${en[0]} + resTexRC.x;
          ${el}
          return ivec4(r, c, d, d2);
        }
      `,new ea.GlslLibRoutine(ei)}getOutputUnpacked5DCoords(er,en){let ei="",eo=er.length,es=null;eo<2&&(es=[]),(es=Array(eo-1))[eo-2]=er[eo-1];for(let en=eo-3;en>=0;--en)es[en]=es[en+1]*er[en+1];let eu=["r","c","d","d2","d3"],el=es.map((er,en)=>`int ${eu[en]} = index / ${er}; ${en===es.length-1?`int ${eu[en+1]} = index - ${eu[en]} * ${er}`:`index -= ${eu[en]} * ${er}`};`).join("");return ei=`
      ivec5 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${en[0]}, ${en[1]}));
          int index = resTexRC.y * ${en[0]} + resTexRC.x;
          ${el}
          return ivec5(r, c, d, d2, d3);
        }
      `,new ea.GlslLibRoutine(ei)}getOutputUnpacked6DCoords(er,en){let ei="",eo=er.length,es=null;eo<2&&(es=[]),(es=Array(eo-1))[eo-2]=er[eo-1];for(let en=eo-3;en>=0;--en)es[en]=es[en+1]*er[en+1];let eu=["r","c","d","d2","d3","d4"],el=es.map((er,en)=>`int ${eu[en]} = index / ${er}; ${en===es.length-1?`int ${eu[en+1]} = index - ${eu[en]} * ${er}`:`index -= ${eu[en]} * ${er}`};`).join("");return ei=`
     ivec6 getOutputCoords() {
         ivec2 resTexRC = ivec2(TexCoords.xy *
                               vec2(${en[0]}, ${en[1]}));
         int index = resTexRC.y * ${en[0]} + resTexRC.x;
         ${el}
         return ivec6(r, c, d, d2, d3, d4);
       }
     `,new ea.GlslLibRoutine(ei)}getCommonUtilFuncs(){let er={},en="uvFromFlat";er[en]=new ea.GlslLibRoutine("\n    vec2 uvFromFlat(int texNumR, int texNumC, int index) {\n      int texC = index / texNumR;\n      int texR = index - texC * texNumR;\n      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to\n      //       v.\n      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);\n    }\n    "),er[en="packedUVfrom1D"]=new ea.GlslLibRoutine("\n      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n        int texelIndex = index / 2;\n        int texR = texelIndex / texNumC;\n        int texC = texelIndex - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "),er[en="packedUVfrom2D"]=new ea.GlslLibRoutine("\n      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {\n        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n        int texR = texelIndex / texNumC;\n        int texC = texelIndex - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "),er[en="packedUVfrom3D"]=new ea.GlslLibRoutine("\n      vec2 packedUVfrom3D(int texNumR, int texNumC,\n          int texelsInBatch, int texelsInLogicalRow, int b,\n          int row, int col) {\n        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n        int texR = index / texNumC;\n        int texC = index - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "),en="sampleTexture";let ei=(0,es.getGlsl)(this.context.glContext.version);return er[en]=new ea.GlslLibRoutine(`
        float sampleTexture(sampler2D textureSampler, vec2 uv) {
            return ${ei.texture2D}(textureSampler, uv).r;
        }`),er}getInputsSamplingSnippets(){let er={},en=this.context.outputTextureLayout;return this.context.programInfo.inputNames.forEach((ei,eo)=>{let ea=this.context.inputTextureLayouts[eo],es=(0,el.generateShaderFuncNameFromInputSamplerName)(ei);ea.isPacked?er[es]=this.getPackedSamplerFromInput(es,ei,ea):er[es]=this.getUnpackedSamplerFromInput(es,ei,ea);let eu=(0,el.generateShaderFuncNameFromInputSamplerNameAtOutCoords)(ei);ea.unpackedShape.length<=en.unpackedShape.length&&(ea.isPacked?er[eu]=this.getPackedSamplerAtOutputCoords(eu,ea,en,ei):er[eu]=this.getUnpackedSamplerAtOutputCoords(eu,ea,en,ei))}),er}getPackedSamplerAtOutputCoords(er,en,ei,es){let eu;let ec=en.unpackedShape,ep=ei.unpackedShape,ed=es,ef=(0,el.generateShaderFuncNameFromInputSamplerName)(ed),eh=ec.length,eg=ep.length,em=eo.BroadcastUtil.getBroadcastDims(ec,ep),eb=(0,el.getCoordsDataType)(eg),ey=eg-eh,ev=(0,el.getGlChannels)();eu=0===eh?"":eg<2&&em.length>=1?"coords = 0;":em.map(er=>`coords.${ev[er+ey]} = 0;`).join("\n");let e_="";e_=eg<2&&eh>0?"coords":ec.map((er,en)=>`coords.${ev[en+ey]}`).join(", ");let ex="return outputValue;",ew=1===eo.ShapeUtil.size(ec),eT=1===eo.ShapeUtil.size(ep);if(1!==eh||ew||eT){if(ew&&!eT)ex=1===eg?"\n          return vec4(outputValue.x, outputValue.x, 0., 0.);\n        ":"\n          return vec4(outputValue.x);\n        ";else if(em.length){let er=eh-2,en=eh-1;em.indexOf(er)>-1&&em.indexOf(en)>-1?ex="return vec4(outputValue.x);":em.indexOf(er)>-1?ex="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":em.indexOf(en)>-1&&(ex="return vec4(outputValue.xx, outputValue.zz);")}}else ex="\n        return vec4(outputValue.xy, outputValue.xy);\n      ";let eS=`
      vec4 ${er}() {
        ${eb} coords = getOutputCoords();
        
        int lastDim = coords.${ev[eg-1]};
        coords.${ev[eg-1]} = coords.${ev[eg-2]};
        coords.${ev[eg-2]} = lastDim;
      
        ${eu}
        vec4 outputValue = ${ef}(${e_});
        ${ex}
      }
    `;return new ea.GlslLibRoutine(eS,["coordinates.getOutputCoords"])}getUnpackedSamplerAtOutputCoords(er,en,ei,es){let eu;let ec=[ei.width,ei.height],ep=[en.width,en.height],ed=en.unpackedShape.length,ef=ei.unpackedShape.length,eh=en.unpackedShape,eg=ei.unpackedShape,em=(0,el.generateShaderFuncNameFromInputSamplerName)(es);if(ed===ef&&eo.ArrayUtil.arraysEqual(ep,ec)){let en=`
          float ${er}() {
            return sampleTexture(${es}, TexCoords);
          }
        `;return new ea.GlslLibRoutine(en,["coordinates.sampleTexture"])}let eb=(0,el.getCoordsDataType)(ef),ey=eo.BroadcastUtil.getBroadcastDims(eh,eg),ev=ef-ed,e_=(0,el.getGlChannels)();eu=0===ed?"":ef<2&&ey.length>=1?"coords = 0;":ey.map(er=>`coords.${e_[er+ev]} = 0;`).join("\n");let ex="";ex=ef<2&&ed>0?"coords":en.unpackedShape.map((er,en)=>`coords.${e_[en+ev]}`).join(", ");let ew=`
        float ${er}() {
          ${eb} coords = getOutputCoords();
          ${eu}
          return ${em}(${ex});
        }
      `;return new ea.GlslLibRoutine(ew,["coordinates.getOutputCoords"])}getPackedSamplerFromInput(er,en,ei){switch(ei.unpackedShape.length){case 0:return this.getPackedSamplerScalar(er,en);case 1:return this.getPackedSampler1D(er,en,ei);case 2:return this.getPackedSampler2D(er,en,ei);case 3:return this.getPackedSampler3D(er,en,ei);default:return this.getPackedSamplerND(er,en,ei)}}getUnpackedSamplerFromInput(er,en,ei){let eo=ei.unpackedShape;switch(eo.length){case 0:return this.getUnpackedSamplerScalar(er,en,ei);case 1:return this.getUnpackedSampler1D(er,en,ei);case 2:return this.getUnpackedSampler2D(er,en,ei);case 3:return this.getUnpackedSampler3D(er,en,ei);case 4:return this.getUnpackedSampler4D(er,en,ei);case 5:return this.getUnpackedSampler5D(er,en,ei);case 6:return this.getUnpackedSampler6D(er,en,ei);default:throw Error(`Unsupported dimension ${eo.length}-D`)}}getPackedSamplerScalar(er,en){let ei=`
          vec4 ${er}() {
            return ${(0,es.getGlsl)(this.context.glContext.version).texture2D}(${en}, halfCR);
          }
        `;return new ea.GlslLibRoutine(ei)}getPackedSampler1D(er,en,ei){let eo=[ei.width,ei.height],eu=[eo[1],eo[0]],el=(0,es.getGlsl)(this.context.glContext.version),ec=`vec4 ${er}(int index) {
      vec2 uv = packedUVfrom1D(
      ${eu[0]}, ${eu[1]}, index);
      return ${el.texture2D}(${en}, uv);
    }`;return new ea.GlslLibRoutine(ec,["coordinates.packedUVfrom1D"])}getPackedSampler2D(er,en,ei){let eu=ei.unpackedShape,el=[ei.width,ei.height],ec=(0,es.getGlsl)(this.context.glContext.version),ep=el[0],ed=el[1];if(null!=el&&eo.ArrayUtil.arraysEqual(eu,el)){let ei=`vec4 ${er}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${ed}.0, ${ep}.0);
        return ${ec.texture2D}(${en}, uv);
      }`;return new ea.GlslLibRoutine(ei)}let ef=el,eh=Math.ceil(eu[1]/2),eg=`vec4 ${er}(int row, int col) {
      vec2 uv = packedUVfrom2D(${ef[1]}, ${ef[0]}, ${eh}, row, col);
      return ${ec.texture2D}(${en}, uv);
    }`;return new ea.GlslLibRoutine(eg,["coordinates.packedUVfrom2D"])}getPackedSampler3D(er,en,ei){let eo=ei.unpackedShape,eu=[ei.width,ei.height],ec=[eu[0],eu[1]],ep=(0,es.getGlsl)(this.context.glContext.version);if(1===eo[0]){let es=eo.slice(1),eu=[1,2],ec=(0,el.squeezeInputShape)(eo,es),ep=["b","row","col"],ed=JSON.parse(JSON.stringify(ei));ed.unpackedShape=ec;let ef=this.getPackedSamplerFromInput(er,en,ed),eh=`${ef.routineBody}
      vec4 ${er}(int b, int row, int col) {
        return ${er}(${(0,el.getSqueezedParams)(ep,eu)});
      } `;return new ea.GlslLibRoutine(eh,ef.dependencies)}let ed=ec[0],ef=ec[1],eh=Math.ceil(eo[2]/2),eg=`vec4 ${er}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${ef}, ${ed}, ${eh*Math.ceil(eo[1]/2)}, ${eh}, b, row, col);
      return ${ep.texture2D}(${en}, uv);}`;return new ea.GlslLibRoutine(eg,["coordinates.packedUVfrom3D"])}getPackedSamplerND(er,en,ei){let eo=ei.unpackedShape,eu=eo.length,el=[ei.width,ei.height],ec=(0,es.getGlsl)(this.context.glContext.version),ep=[el[0],el[1]],ed=ep[1],ef=ep[0],eh=Math.ceil(eo[eu-1]/2),eg=eh*Math.ceil(eo[eu-2]/2),em="int b, int row, int col",eb=`b * ${eg} + (row / 2) * ${eh} + (col / 2)`;for(let er=2;er<eu-1;er++)em=`int b${er}, `+em,eg*=eo[eu-er-1],eb=`b${er} * ${eg} + `+eb;let ey=`vec4 ${er}(${em}) {
      int index = ${eb};
      int texR = index / ${ef};
      int texC = index - texR * ${ef};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${ef}, ${ed});
      return ${ec.texture2D}(${en}, uv);
    }`;return new ea.GlslLibRoutine(ey)}getUnpackedSamplerScalar(er,en,ei){let[eo,es]=[ei.width,ei.height];if(1===eo&&1===es){let ei=`
          float ${er}() {
            return sampleTexture(${en}, halfCR);
          }
        `;return new ea.GlslLibRoutine(ei,["coordinates.sampleTexture"])}let eu=`
        float ${er}() {
          int offset_${en} = coordsToOffset(TexCoords, ${eo}, ${es});
          vec2 uv = uvFromFlat(${eo}, ${es}, offset_${en});
          return sampleTexture(${en}, uv);
        }
      `;return new ea.GlslLibRoutine(eu,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler1D(er,en,ei){let eo=ei.width,es=ei.height;if(1===es&&1===eo){let ei=`
        float ${er}(int index) {
          return sampleTexture(${en}, halfCR);
        }
      `;return new ea.GlslLibRoutine(ei,["coordinates.sampleTexture"])}if(1===es){let ei=`
          float ${er}(int index) {
            vec2 uv = vec2((float(index) + 0.5) / ${eo}.0, 0.5);
            return sampleTexture(${en}, uv);
          }
        `;return new ea.GlslLibRoutine(ei,["coordinates.sampleTexture"])}if(1===eo){let ei=`
          float ${er}(int index) {
            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${es}.0);
            return sampleTexture(${en}, uv);
          }
        `;return new ea.GlslLibRoutine(ei,["coordinates.sampleTexture"])}let eu=`
        float ${er}(int index) {
          vec2 uv = uvFromFlat(${eo}, ${es}, index);
          return sampleTexture(${en}, uv);
        }
      `;return new ea.GlslLibRoutine(eu,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler2D(er,en,ei){let es=ei.unpackedShape,ec=[ei.height,ei.width];if(null!=ec&&eo.ArrayUtil.arraysEqual(es,ec)){let ei=`
          float ${er}(int row, int col) {
            vec2 uv = (vec2(row, col) + halfCR) / vec2(${ec[1]}.0, ${ec[0]}.0);
            return sampleTexture(${en}, uv);
          }
        `;return new ea.GlslLibRoutine(ei,["coordinates.sampleTexture"])}let{newShape:ep,keptDims:ed}=(0,eu.squeezeShape)(es),ef=ep;if(ef.length<es.length){let eo=(0,el.squeezeInputShape)(es,ef),eu=JSON.parse(JSON.stringify(ei));eu.unpackedShape=eo;let ec=["col","row"],ep=`
          ${this.getUnpackedSamplerFromInput(er,en,eu).routineBody}
          float ${er}(int row, int col) {
            return ${er}(${(0,el.getSqueezedParams)(ec,ed)});
          }
        `;return new ea.GlslLibRoutine(ep,["coordinates.sampleTexture"])}let eh=ec[1],eg=ec[0];if(1===eg){let ei=`
          float ${er}(int row, int col) {
            int offset_${en} = coordsToOffset(TexCoords, ${eh}, ${eg});
            float index = dot(vec3(row, col, offset_${en}), vec3(${es[1]}, 1, 1));
            vec2 uv = vec2(0.5, (index + 0.5) / ${eh}.0);
            return sampleTexture(${en}, uv);
          }
        `;return new ea.GlslLibRoutine(ei,["coordinates.sampleTexture","coordinates.coordsToOffset"])}if(1===eh){let ei=`
          float ${er}(int row, int col) {
            int offset_${en} = coordsToOffset(TexCoords, ${eh}, ${eg});
            float index = dot(vec3(row, col, offset_${en}), vec3(${es[1]}, 1, 1));
            vec2 uv = vec2((index + 0.5) / ${eg}.0, 0.5);
            return sampleTexture(${en}, uv);
          }
        `;return new ea.GlslLibRoutine(ei,["coordinates.sampleTexture","coordinates.coordsToOffset"])}let em=`
        float ${er}(int row, int col) {
          int index = col * ${es[1]} + row;
          vec2 uv = uvFromFlat(${eh}, ${eg}, index);
          return sampleTexture(${en}, uv);
        }
      `;return new ea.GlslLibRoutine(em,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler3D(er,en,ei){let eo=ei.unpackedShape,es=eo[1]*eo[2],ec=eo[2],{newShape:ep,keptDims:ed}=(0,eu.squeezeShape)(eo),ef=ep;if(ef.length<eo.length){let es=(0,el.squeezeInputShape)(eo,ef),eu=["batch","col","row"],ec=JSON.parse(JSON.stringify(ei));ec.unpackedShape=es;let ep=this.getUnpackedSamplerFromInput(er,en,ec),eh=ed.reverse(),eg=`
          ${ep.routineBody}
          float ${er}(int batch, int row, int col) {
            return ${er}(${(0,el.getSqueezedParams)(eu,eh)});
          }
        `;return new ea.GlslLibRoutine(eg,ep.dependencies)}let eh=`
          float ${er}(int depth, int row, int col) {
            // Explicitly use integer operations as dot() only works on floats.
            int index = depth * ${es} + col * ${ec} + row;
            vec2 uv = uvFromFlat(${ei.width}, ${ei.height}, index);
            return sampleTexture(${en}, uv);
          }
      `;return new ea.GlslLibRoutine(eh,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler4D(er,en,ei){let eo=ei.unpackedShape,es=eo[3],eu=eo[2]*es,el=`
        float ${er}(int row, int col, int depth, int depth2) {
          int index = row * ${eo[1]*eu} + col * ${eu} +
              depth2 * ${es} + depth;
          vec2 uv = uvFromFlat(${ei.width}, ${ei.height}, index);
          return sampleTexture(${en}, uv);
        }
      `;return new ea.GlslLibRoutine(el,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler5D(er,en,ei){let eo=ei.unpackedShape,es=eo[4],ec=eo[3]*es,ep=eo[2]*ec,ed=eo[1]*ep,{newShape:ef,keptDims:eh}=(0,eu.squeezeShape)(eo);if(ef.length<eo.length){let es=(0,el.squeezeInputShape)(eo,ef),eu=["row","col","depth","depth2","depth3"],ec=JSON.parse(JSON.stringify(ei));ec.unpackedShape=es;let ep=`
          ${this.getUnpackedSamplerFromInput(er,en,ec).routineBody}
          float ${er}(int row, int col, int depth, int depth2, int depth3) {
            return ${er}(${(0,el.getSqueezedParams)(eu,eh)});
          }
        `;return new ea.GlslLibRoutine(ep,["coordinates.sampleTexture","coordinates.uvFromFlat"])}let eg=`
        float ${er}(int row, int col, int depth, int depth2, int depth3) {
          int index = row * ${ed} + col * ${ep} + depth * ${ec} +
          depth3 * ${es} + depth2;
          vec2 uv = uvFromFlat(${ei.width}, ${ei.height}, index);
          return sampleTexture(${en}, uv);
        }
      `;return new ea.GlslLibRoutine(eg,["coordinates.sampleTexture","coordinates.uvFromFlat"])}getUnpackedSampler6D(er,en,ei){let eo=ei.unpackedShape,es=eo[5],ec=eo[4]*es,ep=eo[3]*ec,ed=eo[2]*ep,ef=eo[1]*ed,{newShape:eh,keptDims:eg}=(0,eu.squeezeShape)(eo);if(eh.length<eo.length){let es=(0,el.squeezeInputShape)(eo,eh),eu=["row","col","depth","depth2","depth3","depth4"],ec=JSON.parse(JSON.stringify(ei));ec.unpackedShape=es;let ep=`
            ${this.getUnpackedSamplerFromInput(er,en,ec).routineBody}
            float ${er}(int row, int col, int depth,
              int depth2, int depth3, int depth4) {
              return ${er}(${(0,el.getSqueezedParams)(eu,eg)});
            }
          `;return new ea.GlslLibRoutine(ep,["coordinates.sampleTexture","coordinates.uvFromFlat"])}let em=`
          float ${er}(int row, int col, int depth,
            int depth2, int depth3, int depth4) {
            int index = row * ${ef} + col * ${ed} + depth * ${ep} +
            depth2 * ${ec} + depth3 * ${es} + depth4;
            vec2 uv = uvFromFlat(${ei.width}, ${ei.height}, index);
            return sampleTexture(${en}, uv);
          }
        `;return new ea.GlslLibRoutine(em,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}toVec(){let er=this.context.outputTextureLayout,en=er.shape.length,ei=er.strides,eo=er.width,es=er.height,eu=[];for(let er=0;er<en-1;++er)eu.push(`
        c[${er}] = offset / ${ei[er]};`),eu.push(`
        offset -= c[${er}] * ${ei[er]};`);eu.push(`
        c[${en-1}] = offset;`);let el=`
      void toVec(vec2 texCoords, out int c[${en}]) {
        int offset = coordsToOffset(texCoords, ${eo}, ${es});
        ${eu.join("")}
      }
      void toVec(int offset, out int c[${en}]) {
        ${eu.join("")}
      }
    `;return{toVec:new ea.GlslLibRoutine(el,["coordinates.coordsToOffset"])}}valueFrom(){let er={};return this.context.programInfo.inputNames.forEach((en,ei)=>{let eo=this.context.inputTextureLayouts[ei],es=(eo.unpackedShape.length>0?eo.unpackedShape:eo.shape).length,eu=`_${en}`;er[eu]=new ea.GlslLibRoutine(this.getValueFromSingle(en,es,eo.width,eo.height,!1),[`shapeUtils.indicesToOffset${eu}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"]),er[eu+="_T"]=new ea.GlslLibRoutine(this.getValueFromSingle(en,es,eo.width,eo.height,!0),[`shapeUtils.indicesToOffset${eu}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"])}),er}getValueFromSingle(er,en,ei,eo,ea){let eu=`_${er}`;return ea&&(eu+="_T"),`
        float ${eu}(int m[${en}]) {
          int offset = indicesToOffset${eu}(m);
          vec2 coords = offsetToCoords(offset, ${ei}, ${eo});
          float value = getColorAsFloat(${(0,es.getGlsl)(this.context.glContext.version).texture2D}(${er}, coords));
          return value;
        }
        `}getPackedValueFrom(er,en,ei,eo,ea){let eu=`_${er}_Pack`;return ea&&(eu+="_T"),`
        vec4 ${eu}(int m[${en}]) {
          int offset = indicesToOffset_${er}(m);
          vec2 coords = offsetToCoords(offset, ${ei}, ${eo});
          return ${(0,es.getGlsl)(this.context.glContext.version).texture2D}(${er}, coords);
        }
        `}}en.CoordsGlslLib=ec},1997:(er,en)=>{"use strict";var ei;Object.defineProperty(en,"__esModule",{value:!0}),en.TopologicalSortGlslRoutines=en.GlslLibRoutineNode=en.GlslLibRoutine=en.GlslLib=en.GlslContext=en.FunctionType=void 0,(ei=en.FunctionType||(en.FunctionType={}))[ei.ValueBased=0]="ValueBased",ei[ei.Positional=1]="Positional",en.GlslContext=class{constructor(er,en,ei,eo){this.glContext=er,this.programInfo=en,this.inputTextureLayouts=ei,this.outputTextureLayout=eo}},en.GlslLib=class{constructor(er){this.context=er}},en.GlslLibRoutine=class{constructor(er,en){this.routineBody=er,this.dependencies=en}},en.GlslLibRoutineNode=class{constructor(er,en,ei){this.name=er,this.dependencies=ei||[],en&&(this.routineBody=en)}addDependency(er){er&&this.dependencies.push(er)}},en.TopologicalSortGlslRoutines=class{static returnOrderedNodes(er){if(!er||0===er.length)return[];if(1===er.length)return er;let en=new Set,ei=new Set,eo=[];return this.createOrderedNodes(er,en,ei,eo),eo}static createOrderedNodes(er,en,ei,eo){for(let ea=0;ea<er.length;++ea)this.dfsTraverse(er[ea],en,ei,eo)}static dfsTraverse(er,en,ei,eo){if(!er||ei.has(er.name))return;if(en.has(er.name))throw Error("Cyclic dependency detected. Can't topologically sort routines needed for shader.");en.add(er.name);let ea=er.dependencies;if(ea&&ea.length>0)for(let er=0;er<ea.length;++er)this.dfsTraverse(ea[er],en,ei,eo);eo.push(er),ei.add(er.name),en.delete(er.name)}}},1371:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.EncodingGlslLib=void 0;let eo=ei(1997);class ea extends eo.GlslLib{constructor(er){super(er)}getFunctions(){return Object.assign(Object.assign({},this.encodeFloat32()),this.decodeFloat32())}getCustomTypes(){return{}}encodeFloat32(){return{encode:new eo.GlslLibRoutine("highp vec4 encode(highp float f) {\n        return vec4(f, 0.0, 0.0, 0.0);\n      }\n        ")}}decodeFloat32(){return{decode:new eo.GlslLibRoutine("highp float decode(highp vec4 rgba) {\n        return rgba.r;\n      }\n        ")}}encodeUint8(){let er=ea.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{encode:new eo.GlslLibRoutine(`
      highp vec4 encode(highp float f) {
        highp float F = abs(f);
        highp float Sign = step(0.0,-f);
        highp float Exponent = floor(log2(F));
        highp float Mantissa = (exp2(- Exponent) * F);
        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));
        highp vec4 rgba;
        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));
        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);
        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));
        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));
        ${er}
        rgba = rgba / 255.0; // values need to be normalized to [0,1]
        return rgba;
    }
        `)}}decodeUint8(){let er=ea.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{decode:new eo.GlslLibRoutine(`
        highp float decode(highp vec4 rgba) {
          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]
          ${er}
          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;
          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;
          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);
          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));
          return Result;
      }
        `)}}static isLittleEndian(){let er=new ArrayBuffer(4),en=new Uint32Array(er),ei=new Uint8Array(er);if(en[0]=3735928559,239===ei[0])return!0;if(222===ei[0])return!1;throw Error("unknown endianness")}}en.EncodingGlslLib=ea},2691:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.FragColorGlslLib=void 0;let eo=ei(1997),ea=ei(6757);class es extends eo.GlslLib{constructor(er){super(er)}getFunctions(){return Object.assign(Object.assign({},this.setFragColor()),this.getColorAsFloat())}getCustomTypes(){return{}}setFragColor(){let er=(0,ea.getGlsl)(this.context.glContext.version);return{setFragColor:new eo.GlslLibRoutine(`
        void setFragColor(float value) {
            ${er.output} = encode(value);
        }
        `,["encoding.encode"])}}getColorAsFloat(){return{getColorAsFloat:new eo.GlslLibRoutine("\n        float getColorAsFloat(vec4 color) {\n            return decode(color);\n        }\n        ",["encoding.decode"])}}}en.FragColorGlslLib=es},3878:(er,en)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.replaceInlines=void 0;let ei=/@inline[\s\n\r]+(\w+)[\s\n\r]+([0-9a-zA-Z_]+)\s*\(([^)]*)\)\s*{(([^}]|[\n\r])*)}/gm;en.replaceInlines=function(er){let en;let eo={};for(;null!==(en=ei.exec(er));){let er=en[3].split(",").map(er=>{let en=er.trim().split(" ");return en&&2===en.length?{type:en[0],name:en[1]}:null}).filter(er=>null!==er);eo[en[2]]={params:er,body:en[4]}}for(let ei in eo){let ea="(\\w+)?\\s+([_0-9a-zA-Z]+)\\s+=\\s+__FUNC__\\((.*)\\)\\s*;".replace("__FUNC__",ei),es=RegExp(ea,"gm");for(;null!==(en=es.exec(er));){let ea=en[1],es=en[2],eu=en[3].split(","),el=ea?`${ea} ${es};`:"",ec=eo[ei].body,ep="";eo[ei].params.forEach((er,en)=>{er&&(ep+=`${er.type} ${er.name} = ${eu[en]};
`)}),ec=(ec=`${ep}
 ${ec}`).replace("return",`${es} = `);let ed=`
      ${el}
      {
        ${ec}
      }
      `;er=er.replace(en[0],ed)}}return er.replace(ei,"")}},8897:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.GlslPreprocessor=void 0;let eo=ei(1997),ea=ei(3878),es=ei(1248),eu=ei(6757);en.GlslPreprocessor=class{constructor(er,en,ei,ea){this.libs={},this.glslLibRoutineDependencyGraph={},this.context=new eo.GlslContext(er,en,ei,ea),Object.keys(es.glslRegistry).forEach(er=>{let en=new es.glslRegistry[er](this.context);this.libs[er]=en});let eu=this.glslLibRoutineDependencyGraph;for(let er in this.libs){let en=this.libs[er].getFunctions();for(let ei in en){let ea;let es=er+"."+ei;eu[es]?(ea=eu[es]).routineBody=en[ei].routineBody:(ea=new eo.GlslLibRoutineNode(es,en[ei].routineBody),eu[es]=ea);let el=en[ei].dependencies;if(el)for(let er=0;er<el.length;++er)if(eu[el[er]])ea.addDependency(eu[el[er]]);else{let en=new eo.GlslLibRoutineNode(el[er]);eu[el[er]]=en,ea.addDependency(en)}}}}preprocess(){let er=this.context.programInfo,en=er.shaderSource;return this.context.programInfo.hasMain||(en=`${en}
      ${(0,eu.getDefaultFragShaderMain)(this.context.glContext.version,this.context.outputTextureLayout.shape.length)}`),en=(0,ea.replaceInlines)(en),`${(0,eu.getFragShaderPreamble)(this.context.glContext.version)}
    ${this.getUniforms(er.inputNames,er.variables)}
    ${this.getImports(en)}
    ${en}`}getImports(er){let en=this.selectGlslLibRoutinesToBeIncluded(er);if(0===en.length)return"";let ei="";for(let er=0;er<en.length;++er){if(!en[er].routineBody)throw Error(`Missing body for the Glsl Library routine: ${en[er].name}`);ei+=en[er].routineBody+"\n"}return ei}selectGlslLibRoutinesToBeIncluded(er){let en=[];return Object.keys(this.glslLibRoutineDependencyGraph).forEach(ei=>{let eo=ei.split(".")[1];-1!==er.indexOf(eo)&&en.push(this.glslLibRoutineDependencyGraph[ei])}),eo.TopologicalSortGlslRoutines.returnOrderedNodes(en)}getUniforms(er,en){let ei=[];if(er)for(let en of er)ei.push(`uniform sampler2D ${en};`);if(en)for(let er of en)ei.push(`uniform ${er.type} ${er.name}${er.arrayLength?`[${er.arrayLength}]`:""};`);return ei.join("\n")}}},1248:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.glslRegistry=void 0;let eo=ei(6859),ea=ei(1371),es=ei(2691),eu=ei(9183),el=ei(9314);en.glslRegistry={encoding:ea.EncodingGlslLib,fragcolor:es.FragColorGlslLib,vec:el.VecGlslLib,shapeUtils:eu.ShapeUtilsGlslLib,coordinates:eo.CoordsGlslLib}},9183:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.ShapeUtilsGlslLib=void 0;let eo=ei(1997);class ea extends eo.GlslLib{constructor(er){super(er)}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},this.bcastIndex()),this.bcastMatmulIndex()),this.offsetToIndices()),this.indicesToOffset()),this.incrementIndices())}getCustomTypes(){return{}}bcastIndex(){let er=this.context.outputTextureLayout.shape.length,en={};return this.context.programInfo.inputNames.forEach((ei,ea)=>{let es=this.context.inputTextureLayouts[ea].unpackedShape;if(es.length<=er){let ea=es.length,eu=er-ea,el=`bcastIndices_${ei}`,ec="";for(let er=0;er<ea;++er)ec+=`
          realIndices[${er}] = int( mod(float(bcastedIndices[${eu+er}]), ${es[er]}.0) );
          `;let ep=`
        void ${el} (int bcastedIndices[${er}], out int realIndices[${ea}]) {
          ${ec}
        }
        `;en[el]=new eo.GlslLibRoutine(ep)}}),en}bcastMatmulIndex(){let er=this.context.outputTextureLayout.shape.length,en={};return this.context.programInfo.inputNames.forEach((ei,ea)=>{let es=this.context.inputTextureLayouts[ea].shape;if(!(es.length<2||es.length>er)){let ea=es.length,eu=er-ea,el=`bcastMatmulIndices_${ei}`,ec="";for(let er=0;er<ea-2;++er)ec+=`
          realIndices[${er}] = int( mod(float(bcastedIndices[${eu+er}]), ${es[er]}.0) );
          `;let ep=`
        void ${el}(int bcastedIndices[${er}], out int realIndices[${ea}]) {
          ${ec}
          realIndices[${ea-1}] = bcastedIndices[${er-1}];
          realIndices[${ea-2}] = bcastedIndices[${er-2}];
        }
        `;en[el]=new eo.GlslLibRoutine(ep)}}),en}indicesToOffset(){let er={};return this.context.programInfo.inputNames.forEach((en,ei)=>{let es=this.context.inputTextureLayouts[ei].shape,eu=this.context.inputTextureLayouts[ei].strides,el=es.length,ec=`indicesToOffset_${en}`;er[ec]=new eo.GlslLibRoutine(ea.indexToOffsetSingle(ec,el,eu)),er[ec=`indicesToOffset_${en}_T`]=new eo.GlslLibRoutine(ea.indexToOffsetSingle(ec,el,eu.slice().reverse()))}),er}static indexToOffsetSingle(er,en,ei){let eo="";for(let er=en-1;er>=0;--er)eo+=`
        offset += indices[${er}] * ${ei[er]};
        `;return`
      int ${er}(int indices[${en}]) {
        int offset = 0;
        ${eo}
        return offset;
      }
      `}offsetToIndices(){let er={};return this.context.programInfo.inputNames.forEach((en,ei)=>{let es=this.context.inputTextureLayouts[ei].shape,eu=this.context.inputTextureLayouts[ei].strides,el=es.length,ec=`offsetToIndices_${en}`;er[ec]=new eo.GlslLibRoutine(ea.offsetToIndicesSingle(ec,el,eu)),er[ec=`offsetToIndices_${en}_T`]=new eo.GlslLibRoutine(ea.offsetToIndicesSingle(ec,el,eu.slice().reverse()))}),er}static offsetToIndicesSingle(er,en,ei){let eo=[];for(let er=0;er<en-1;++er)eo.push(`
      indices[${er}] = offset / ${ei[er]};`),eo.push(`
        offset -= indices[${er}] * ${ei[er]};`);return eo.push(`
      indices[${en-1}] = offset;`),`
      void ${er}(int offset, out int indices[${en}]) {
        ${eo.join("")}
      }
      `}incrementIndices(){let er={};return this.context.programInfo.inputNames.forEach((en,ei)=>{let ea=this.context.inputTextureLayouts[ei].shape,es=ea.length,eu=`incrementIndices_${en}`,el="";for(let er=0;er<es;++er)el+=`
        shape[${er}] = ${ea[er]};`;let ec=`
        void ${eu}(int axis, out int indices[${es}]) {
          int shape[${es}];
          ${el};
          for(int i = ${es} -1 ; i >= 0; --i) {
            if(i > axis) continue;
            indices[i] += 1;
            if(indices[i] < shape[i]) {
              break;
            }
            indices[i] = 0;
          }
        }
        `;er[eu]=new eo.GlslLibRoutine(ec)}),er}}en.ShapeUtilsGlslLib=ea},6757:(er,en)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.getDefaultFragShaderMain=en.getFragShaderPreamble=en.getVertexShaderSource=en.getGlsl=void 0;let ei={version:"",attribute:"attribute",varyingVertex:"varying",varyingFrag:"varying",texture2D:"texture2D",output:"gl_FragColor",outputDeclaration:""},eo={version:"#version 300 es",attribute:"in",varyingVertex:"out",varyingFrag:"in",texture2D:"texture",output:"outputColor",outputDeclaration:"out vec4 outputColor;"};function ea(er){return 1===er?ei:eo}en.getGlsl=ea,en.getVertexShaderSource=function(er){let en=ea(er);return`${en.version}
      precision highp float;
      ${en.attribute} vec3 position;
      ${en.attribute} vec2 textureCoord;

      ${en.varyingVertex} vec2 TexCoords;

      void main()
      {
          gl_Position = vec4(position, 1.0);
          TexCoords = textureCoord;
      }`},en.getFragShaderPreamble=function(er){let en=ea(er);return`${en.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${en.varyingFrag} vec2 TexCoords;
    ${en.outputDeclaration}
    const vec2 halfCR = vec2(0.5, 0.5);

    // Custom vector types to handle higher dimenalities.
    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    `},en.getDefaultFragShaderMain=function(er,en){return`
  void main() {
    int indices[${en}];
    toVec(TexCoords, indices);
    vec4 result = vec4(process(indices));
    ${ea(er).output} = result;
  }
  `}},9314:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.VecGlslLib=void 0;let eo=ei(1997);class ea extends eo.GlslLib{constructor(er){super(er)}getCustomTypes(){return{}}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign({},this.binaryVecFunctions()),this.copyVec()),this.setVecItem()),this.getVecItem())}binaryVecFunctions(){let er=this.context.outputTextureLayout.shape.length,en={add:"+=",sub:"-=",mul:"*=",div:"/="},ei={};for(let ea in en){let es=`${ea}Vec`,eu="";for(let ei=0;ei<er;++ei)eu+=`
          dest[${ei}] ${en[ea]} src[${ei}];
          `;let el=`
        void ${es}(int src[${er}], out int dest[${er}]) {
          ${eu}
        }
        `;ei[es]=new eo.GlslLibRoutine(el)}return ei}copyVec(){let er=this.context.outputTextureLayout.shape.length,en="";for(let ei=0;ei<er;++ei)en+=`
        dest[${ei}] = src[${ei}];
        `;let ei=`
      void copyVec(int src[${er}], out int dest[${er}]) {
        ${en}
      }
      `;return{copyVec:new eo.GlslLibRoutine(ei)}}setVecItem(){let er=this.context.outputTextureLayout.shape.length,en=`
        if(index < 0)
            index =${er} + index;
        if (index == 0)
            m[0] = value;
        `;for(let ei=1;ei<er-1;++ei)en+=`
        else if (index == ${ei})
            m[${ei}] = value;
            `;en+=`
        else
            m[${er-1}] = value;
        `;let ei=`
      void setVecItem(out int m[${er}], int index, int value) {
        ${en}
      }
        `;return{setVecItem:new eo.GlslLibRoutine(ei)}}getVecItem(){let er=this.context.outputTextureLayout.shape.length,en=`
        if(index < 0)
            index = ${er} + index;
        if (index == 0)
            return m[0];
      `;for(let ei=1;ei<er-1;++ei)en+=`
        else if (index == ${ei})
            return m[${ei}];
      `;en+=`
        else
            return m[${er-1}];
        `;let ei=`
      int getVecItem(int m[${er}], int index) {
        ${en}
      }
    `;return{getVecItem:new eo.GlslLibRoutine(ei)}}}en.VecGlslLib=ea},7860:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.WebGLInferenceHandler=void 0;let eo=ei(1315),ea=ei(9240),es=ei(7273),eu=ei(9),el=ei(7379),ec=ei(2488),ep=ei(540),ed=ei(3314),ef=ei(5639);en.WebGLInferenceHandler=class{constructor(er){this.session=er,this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map}calculateTextureWidthAndHeight(er,en){return(0,ed.calculateTextureWidthAndHeight)(this.session.layoutStrategy,er,en)}executeProgram(er,en){if(en.length<er.inputNames.length)throw Error(`Input size mustn't be less than ${er.inputNames.length}.`);if(er.inputNames.length!==er.inputTypes.length)throw Error("input names size does not match input types");let ei=[];for(let eo=0;eo<er.inputNames.length;++eo)ei[eo]=this.getOrCreateTextureData(en[eo],er.inputTypes[eo]);let eo=((er,en)=>{let ei=en.map(er=>`${er.unpackedShape.join(",")};${er.width}x${er.height}`).join("_"),eo=er.name;return er.cacheHint&&(eo+="["+er.cacheHint+"]"),eo+=":"+ei})(er,ei),ea=this.session.programManager.getArtifact(eo),es=ea?ea.programInfo:"function"==typeof er.get?er.get():er,eu=(0,ed.createTextureLayoutFromTextureType)(this.session.layoutStrategy,es.output.dims,es.output.textureType),el=this.createTextureData(eu,es.output.type);return ea||(ea=this.session.programManager.build(es,ei,el),this.session.programManager.setArtifact(eo,ea)),this.runProgram(ea,ei,el),el}run(er,en){return this.executeProgram(er,en).tensor}runProgram(er,en,ei){for(let ei=0;ei<en.length;++ei)if(!!en[ei].isPacked!=(er.programInfo.inputTypes[ei]===ef.TextureType.packed))throw Error(`input[${ei}] property packed inconsistent`);if(!!ei.isPacked!=(er.programInfo.output.textureType===ef.TextureType.packed))throw Error("output property packed inconsistent");this.session.programManager.run(er,en,ei)}getOrCreateTextureData(er,en){let ei=this.getTextureData(er.dataId,en===ef.TextureType.packed);if(!ei&&(ei=this.getTextureData(er.dataId,en!==ef.TextureType.packed)))return en===ef.TextureType.packed?this.pack(ei):this.unpack(ei);if(!ei){let eo=(0,ed.createTextureLayoutFromTextureType)(this.session.layoutStrategy,er.dims,en);if(en===ef.TextureType.packedLastDimension){let ei=1,eo=4,ea=er.dims;if(4===ea.length){let es=[ea[0],Math.ceil(ea[1]*ea[2]*ea[3]/eo)],eu=(0,ed.createTextureLayoutFromTextureType)(this.session.layoutStrategy,es,en),el=er.numberData;if(ea[1]*ea[2]*ea[3]%eo!=0){let en=ea[0],es=ea[1]*ea[2]*ea[3],eu=Math.ceil(es*ei/eo)*eo;el=new Float32Array(en*eu);for(let eo=0;eo<en;++eo){let en=eo*es,ea=eo*eu+eo%ei*es;el.set(er.numberData.subarray(en,en+es),ea)}}return this.createTextureData(eu,er.type,el,er,1)}}if(en===ef.TextureType.packed){let en=(0,ed.createTextureLayoutFromShape)(this.session.layoutStrategy,er.dims,1,[],{reverseWH:!0}),eo=this.createTextureData(en,er.type,er.numberData,er,1);ei=this.pack(eo)}else ei=this.createTextureData(eo,er.type,er.numberData,er,1)}return ei}createTextureDataFromLayoutBindTensor(er,en,ei,eo){return this.createTextureData(er,en,ei,eo,1)}createTextureData(er,en,ei,ea,es){eo.Logger.verbose("InferenceHandler",`Creating TextureData: layout:[${JSON.stringify(er)}]`);let eu=this.session.textureManager.createTextureFromLayout(en,er,ei,es);return this.createTextureDataFromTexture(er,en,eu,ea)}reshapeUnpacked(er,en){let ei=this.getOrCreateTextureData(er,ef.TextureType.unpacked),eo={channels:ei.channels,height:ei.height,width:ei.width,shape:0!==en.length?en:[1],strides:es.ShapeUtil.computeStrides(en),unpackedShape:en};return this.createTextureDataFromTexture(eo,er.type,ei.texture).tensor}reshapePacked(er,en){let ei=this.getOrCreateTextureData(er,ef.TextureType.packed);if((0,el.isReshapeCheap)(er.dims,en)){let eo={channels:ei.channels,height:ei.height,width:ei.width,shape:0!==en.length?en:[1],strides:es.ShapeUtil.computeStrides(en),unpackedShape:en,isPacked:!0};return this.createTextureDataFromTexture(eo,er.type,ei.texture).tensor}let eo=(0,el.processDims3D)(er.dims),ea=(0,el.processDims3D)(en),eu=this.reshapePacked(er,eo),ec=this.run((0,el.createPackedReshape3DProgramInfoLoader)(this,eu,ea),[eu]);return this.reshapePacked(ec,en)}cast(er,en){let ei=this.getOrCreateTextureData(er,ef.TextureType.unpacked);return this.createTextureDataFromTexture(ei,en,ei.texture).tensor}createTextureDataFromTexture(er,en,ei,eo,es){let eu=Object.assign(Object.assign({},er),{tensor:eo||new ea.Tensor(er.unpackedShape,en,er=>this.readTexture(eu),async er=>this.readTextureAsync(eu),void 0,es),texture:ei});return this.setTextureData(eu.tensor.dataId,eu,er.isPacked),eu}getTextureData(er,en=!1){return this.session.isInitializer(er)?this.session.getTextureData(er,en):en?this.packedTextureDataCache.get(er):this.unpackedTextureDataCache.get(er)}setTextureData(er,en,ei=!1){this.session.isInitializer(er)?this.session.setTextureData(er,en,ei):(ei?this.packedTextureDataCache:this.unpackedTextureDataCache).set(er,en)}isTextureLayoutCached(er,en=!1){return!!this.getTextureData(er.dataId,en)}dispose(){this.session.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach(er=>this.session.textureManager.releaseTexture(er)),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach(er=>this.session.textureManager.releaseTexture(er)),this.unpackedTextureDataCache=new Map}readTexture(er){return er.isPacked?this.readTexture(this.unpack(er)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTexture(er,er.tensor.type,er.channels):this.session.textureManager.readUint8TextureAsFloat((0,ec.encodeAsUint8)(this,er))}async readTextureAsync(er){return er.isPacked?this.readTextureAsync(this.unpack(er)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTextureAsync(er,er.tensor.type,er.channels):this.session.textureManager.readUint8TextureAsFloat((0,ec.encodeAsUint8)(this,er))}pack(er){return this.executeProgram((0,eu.createPackProgramInfoLoader)(this,er.tensor),[er.tensor])}unpack(er){return this.executeProgram((0,ep.createUnpackProgramInfoLoader)(this,er.tensor),[er.tensor])}}},4110:function(er,en,ei){"use strict";var eo=this&&this.__createBinding||(Object.create?function(er,en,ei,eo){void 0===eo&&(eo=ei);var ea=Object.getOwnPropertyDescriptor(en,ei);ea&&!("get"in ea?!en.__esModule:ea.writable||ea.configurable)||(ea={enumerable:!0,get:function(){return en[ei]}}),Object.defineProperty(er,eo,ea)}:function(er,en,ei,eo){void 0===eo&&(eo=ei),er[eo]=en[ei]}),ea=this&&this.__setModuleDefault||(Object.create?function(er,en){Object.defineProperty(er,"default",{enumerable:!0,value:en})}:function(er,en){er.default=en}),es=this&&this.__importStar||function(er){if(er&&er.__esModule)return er;var en={};if(null!=er)for(var ei in er)"default"!==ei&&Object.prototype.hasOwnProperty.call(er,ei)&&eo(en,er,ei);return ea(en,er),en};Object.defineProperty(en,"__esModule",{value:!0}),en.WEBGL_OP_RESOLVE_RULES=void 0;let eu=ei(8817),el=es(ei(5194)),ec=ei(4752),ep=ei(6668),ed=ei(9754),ef=ei(5042),eh=ei(6742),eg=ei(4125),em=ei(6149),eb=ei(5378),ey=ei(6981),ev=ei(7413),e_=ei(7006),ex=ei(8276),ew=ei(5565),eT=ei(2834),eS=ei(1010),eO=ei(8126),eA=ei(2801),eE=ei(565),eI=ei(2444),e$=ei(815),eP=ei(564),eD=ei(5416),ek=ei(1240),eC=ei(5944),eR=ei(5707),eM=es(ei(9087)),eN=ei(7862),eF=ei(3980);en.WEBGL_OP_RESOLVE_RULES=[["Abs","","6+",eM.abs],["Acos","","7+",eM.acos],["Add","","7+",el.add],["And","","7+",el.and],["Asin","","7+",eM.asin],["Atan","","7+",eM.atan],["AveragePool","","7+",eT.averagePool,eT.parseAveragePoolAttributes],["BatchNormalization","","7+",eu.batchNormalization,eu.parseBatchNormalizationAttributes],["Cast","","6+",ec.cast,ec.parseCastAttributes],["Ceil","","6+",eM.ceil],["Clip","","6-10",eM.clip,eM.parseClipAttributes],["Clip","","11+",eM.clipV11],["Concat","","4+",ep.concat,ep.parseConcatAttributes],["Conv","","1+",ed.conv,ed.parseConvAttributes],["ConvTranspose","","1+",ef.convTranspose,ef.parseConvTransposeAttributes],["Cos","","7+",eM.cos],["Div","","7+",el.div],["Dropout","","7+",eM.identity],["DepthToSpace","","1+",eh.depthToSpace,eh.parseDepthToSpaceAttributes],["Equal","","7+",el.equal],["Elu","","6+",eM.elu,eM.parseEluAttributes],["Exp","","6+",eM.exp],["Flatten","","1+",eg.flatten,eg.parseFlattenAttributes],["Floor","","6+",eM.floor],["FusedConv","com.microsoft","1+",ed.conv,ed.parseConvAttributes],["Gather","","1+",em.gather,em.parseGatherAttributes],["Gemm","","7-10",eb.gemm,eb.parseGemmAttributesV7],["Gemm","","11+",eb.gemm,eb.parseGemmAttributesV11],["GlobalAveragePool","","1+",eT.globalAveragePool,eT.parseGlobalAveragePoolAttributes],["GlobalMaxPool","","1+",eT.globalMaxPool],["Greater","","7+",el.greater],["Identity","","1+",eM.identity],["ImageScaler","","1+",ey.imageScaler,ey.parseImageScalerAttributes],["InstanceNormalization","","6+",ev.instanceNormalization,ev.parseInstanceNormalizationAttributes],["LeakyRelu","","6+",eM.leakyRelu,eM.parseLeakyReluAttributes],["Less","","7+",el.less],["LRN","","1+",e_.lrn,e_.parseLrnAttributes],["Log","","6+",eM.log],["MatMul","","1+",ex.matMul,ex.parseMatMulAttributes],["MaxPool","","1+",eT.maxPool,eT.parseMaxPoolAttributes],["Mul","","7+",el.mul],["Neg","","6+",eM.neg],["Not","","1+",eM.not],["Or","","7+",el.or],["Pad","","2-10",ew.padV2,ew.parsePadAttributesV2],["Pad","","11+",ew.padV11,ew.parsePadAttributesV11],["Pow","","7+",el.pow],["PRelu","","7+",el.pRelu],["ReduceLogSum","","1+",eS.reduceLogSum,eS.parseReduceAttributes],["ReduceMax","","1+",eS.reduceMax,eS.parseReduceAttributes],["ReduceMean","","1+",eS.reduceMean,eS.parseReduceAttributes],["ReduceMin","","1+",eS.reduceMin,eS.parseReduceAttributes],["ReduceProd","","1+",eS.reduceProd,eS.parseReduceAttributes],["ReduceSum","","1-12",eS.reduceSum,eS.parseReduceAttributes],["ReduceSumSquare","","1+",eS.reduceLogSumSquare,eS.parseReduceAttributes],["Relu","","6+",eM.relu],["Reshape","","5+",eO.reshape],["Resize","","10",eA.resize,eA.parseResizeAttributesV10],["Resize","","11+",eA.resize,eA.parseResizeAttributesV11],["Shape","","1+",eE.shape],["Sigmoid","","6+",eM.sigmoid],["Sin","","7+",eM.sin],["Slice","","10+",eI.sliceV10],["Slice","","1-9",eI.slice,eI.parseSliceAttributes],["Softmax","","1-12",e$.softmax,e$.parseSoftmaxAttributes],["Softmax","","13+",e$.softmaxV13,e$.parseSoftmaxAttributesV13],["Split","","2-12",eP.split,eP.parseSplitAttributes],["Sqrt","","6+",eM.sqrt],["Squeeze","","1-12",eD.squeeze,eD.parseSqueezeAttributes],["Squeeze","","13+",eD.squeezeV13],["Sub","","7+",el.sub],["Sum","","6+",ek.sum],["Tan","","7+",eM.tan],["Tanh","","6+",eM.tanh],["Tile","","6+",eC.tile],["Transpose","","1+",eR.transpose,eR.parseTransposeAttributes],["Upsample","","7-8",eF.upsample,eF.parseUpsampleAttributesV7],["Upsample","","9",eF.upsample,eF.parseUpsampleAttributesV9],["Unsqueeze","","1-12",eN.unsqueeze,eN.parseUnsqueezeAttributes],["Unsqueeze","","13+",eN.unsqueezeV13],["Xor","","7+",el.xor]]},8817:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.parseBatchNormalizationAttributes=en.batchNormalization=void 0;let eo=ei(4910),ea=ei(6757),es=ei(5639),eu={name:"BatchNormalization",inputNames:["A","Scale","B","Mean","Variance"],inputTypes:[es.TextureType.unpacked,es.TextureType.unpacked,es.TextureType.unpacked,es.TextureType.unpacked,es.TextureType.unpacked]};en.batchNormalization=(er,en,ei)=>(ec(en),[er.run(Object.assign(Object.assign({},eu),{cacheHint:ei.cacheKey,get:()=>el(er,en,ei)}),en)]),en.parseBatchNormalizationAttributes=er=>{let en=er.attributes.getFloat("epsilon",1e-5),ei=er.attributes.getFloat("momentum",.9),ea=er.attributes.getInt("spatial",1);return(0,eo.createAttributeWithCacheKey)({epsilon:en,momentum:ei,spatial:ea})};let el=(er,en,ei)=>{let eo=(0,ea.getGlsl)(er.session.backend.glContext.version),el=en[0].dims.length,[ec,ep]=er.calculateTextureWidthAndHeight(en[1].dims,es.TextureType.unpacked),ed=`
  float process(int[${el}] indices) {
    vec2 position = offsetToCoords(indices[1], ${ec}, ${ep});
    float scale = getColorAsFloat(${eo.texture2D}(Scale, position));
    float mean = getColorAsFloat(${eo.texture2D}(Mean, position));
    float variance = getColorAsFloat(${eo.texture2D}(Variance, position));
    float b = getColorAsFloat(${eo.texture2D}(B, position));

    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${ei.epsilon})) ) + b;
  }`;return Object.assign(Object.assign({},eu),{output:{dims:en[0].dims,type:en[0].type,textureType:es.TextureType.unpacked},shaderSource:ed})},ec=er=>{if(!er||5!==er.length)throw Error("BatchNormalization requires 5 inputs.");let en=er[0],ei=er[1],eo=er[2],ea=er[3],es=er[4];if(en.dims.length<3||1!==ei.dims.length||1!==eo.dims.length||1!==ea.dims.length||1!==es.dims.length||ei.dims[0]!==en.dims[1]||eo.dims[0]!==en.dims[1]||ea.dims[0]!==en.dims[1]||es.dims[0]!==en.dims[1])throw Error("invalid input shape.");if("float32"!==en.type&&"float64"!==en.type||"float32"!==ei.type&&"float64"!==ei.type||"float32"!==eo.type&&"float64"!==eo.type||"float32"!==ea.type&&"float64"!==ea.type||"float32"!==es.type&&"float64"!==es.type)throw Error("invalid input tensor types.")}},5194:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.xor=en.sub=en.pRelu=en.pow=en.or=en.mul=en.less=en.greater=en.equal=en.div=en.and=en.add=en.glslPRelu=en.glslPow=en.glslXor=en.glslOr=en.glslAnd=en.glslLess=en.glslGreater=en.glslEqual=en.glslSub=en.glslMul=en.glslDiv=en.glslAdd=void 0;let eo=ei(7273),ea=ei(1997),es=ei(6757),eu=ei(5639);function el(){let er="add_";return{body:`
  float ${er}(float a, float b) {
    return a + b;
  }
  vec4 ${er}(vec4 v1, vec4 v2) {
    return v1 + v2;
  }
  `,name:er,type:ea.FunctionType.ValueBased}}function ec(){let er="div_";return{body:`
  float ${er}(float a, float b) {
    return a / b;
  }
  vec4 ${er}(vec4 v1, vec4 v2) {
    return v1 / v2;
  }
  `,name:er,type:ea.FunctionType.ValueBased}}function ep(){let er="mul_";return{body:`
  float ${er}(float a, float b) {
    return a * b;
  }
  vec4 ${er}(vec4 v1, vec4 v2) {
    return v1 * v2;
  }
  `,name:er,type:ea.FunctionType.ValueBased}}function ed(){let er="sub_";return{body:`
  float ${er}(float a, float b) {
    return a - b;
  }
  vec4 ${er}(vec4 v1, vec4 v2) {
    return v1 - v2;
  }
  `,name:er,type:ea.FunctionType.ValueBased}}function ef(){let er="equal_";return{body:`
  float ${er}(float a, float b) {
    return float(a == b);
  }
  vec4 ${er}(vec4 v1, vec4 v2) {
    return vec4(equal(v1, v2));
  }
  `,name:er,type:ea.FunctionType.ValueBased}}function eh(){let er="greater_";return{body:`
  float ${er}(float a, float b) {
    return float(a > b);
  }
  vec4 ${er}(vec4 v1, vec4 v2) {
    return vec4( v1.r > v2.r ,
      v1.g > v2.g,
      v1.b > v2.b,
      v1.a > v2.a );
  }
  `,name:er,type:ea.FunctionType.ValueBased}}function eg(){let er="less_";return{body:`
  float ${er}(float a, float b) {
    return float(a < b);
  }
  vec4 ${er}(vec4 v1, vec4 v2) {
    return vec4( v1.r < v2.r ,
                v1.g < v2.g,
                v1.b < v2.b,
                v1.a < v2.a );
  }
  `,name:er,type:ea.FunctionType.ValueBased}}function em(){let er="and_";return{body:`
  float ${er}(float a, float b) {
    return float( bool(a) && bool(b) );
  }
  vec4 ${er}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r && b2.r ,
                b1.g && b2.g,
                b1.b && b2.b,
                b1.a && b2.a );
  }
  `,name:er,type:ea.FunctionType.ValueBased}}function eb(){let er="or_";return{body:`
  float ${er}(float a, float b) {
    return float( bool(a) || bool(b) );
  }
  vec4 ${er}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r || b2.r ,
                b1.g || b2.g,
                b1.b || b2.b,
                b1.a || b2.a );
  }
  `,name:er,type:ea.FunctionType.ValueBased}}function ey(){let er="xor_";return{body:`
  float ${er}(float a, float b) {
    return float( bool(a) ^^ bool(b) );
  }
  vec4 ${er}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r ^^ b2.r ,
                b1.g ^^ b2.g,
                b1.b ^^ b2.b,
                b1.a ^^ b2.a );
  }
  `,name:er,type:ea.FunctionType.ValueBased}}function ev(){return function(er){let en=`${er}_`;return{body:`
  float ${en}(float a, float b) {
    return ${er}(a, b);
  }
  vec4 ${en}(vec4 v1, vec4 v2) {
    return ${er}(v1, v2);
  }
  `,name:en,type:ea.FunctionType.ValueBased}}("pow")}function e_(){let er="prelu_";return{body:`
  float ${er}(float a, float b) {
    return a < 0.0 ? a * b: a;
  }
  vec4 ${er}(vec4 v1, vec4 v2) {
    return vec4(
      v1.r < 0.0 ? v1.r * v2.r: v1.r,
      v1.g < 0.0 ? v1.g * v2.g: v1.g,
      v1.b < 0.0 ? v1.b * v2.b: v1.b,
      v1.a < 0.0 ? v1.a * v2.a: v1.a
      );
  }
  `,name:er,type:ea.FunctionType.ValueBased}}en.glslAdd=el,en.glslDiv=ec,en.glslMul=ep,en.glslSub=ed,en.glslEqual=ef,en.glslGreater=eh,en.glslLess=eg,en.glslAnd=em,en.glslOr=eb,en.glslXor=ey,en.glslPow=ev,en.glslPRelu=e_;let ex=(er,en,ei,eo=en[0].type,ea)=>{let es=er.session.pack?eu.TextureType.packed:eu.TextureType.unpacked;return{name:ei.name,inputNames:["A","B"],inputTypes:[es,es],cacheHint:ea,get:()=>ew(er,en,ei,eo)}},ew=(er,en,ei,ea=en[0].type)=>{let el=er.session.pack?eu.TextureType.packed:eu.TextureType.unpacked,ec=!eo.ShapeUtil.areEqual(en[0].dims,en[1].dims),ep=en[0].dims,ed=er.session.pack;if(ec){let eu=eo.BroadcastUtil.calcShape(en[0].dims,en[1].dims,!1);if(!eu)throw Error("Can't perform binary op on the given tensors");ep=eu;let ec=ep.length,ef=0!==en[0].dims.length?en[0].dims.length:1,eh=0!==en[1].dims.length?en[1].dims.length:1,eg=0!==en[0].dims.length?"bcastIndices_A(indices, aindices);":"aindices[0] = 0;",em=0!==en[1].dims.length?"bcastIndices_B(indices, bindices);":"bindices[0] = 0;",eb=(0,es.getGlsl)(er.session.backend.glContext.version),ey=ed?`
      ${ei.body}
      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();
        vec4 result = ${ei.name}(a, b);
        ${eb.output} = result;
      }`:`
      ${ei.body}
      float process(int indices[${ec}]) {
        int aindices[${ef}];
        int bindices[${eh}];
        ${eg}
        ${em}
        return ${ei.name}(_A(aindices), _B(bindices));
      }`;return{name:ei.name,inputNames:["A","B"],inputTypes:[el,el],output:{dims:ep,type:ea,textureType:el},shaderSource:ey,hasMain:ed}}let ef=(0,es.getGlsl)(er.session.backend.glContext.version),eh=`
    ${ei.body}
    void main() {
      vec4 v1 = ${ef.texture2D}(A, TexCoords);
      vec4 v2 = ${ef.texture2D}(B, TexCoords);
      vec4 result = ${ei.name}(v1, v2);
      ${ef.output} = result;
    }
    `;return{name:ei.name,inputNames:["A","B"],inputTypes:[el,el],output:{dims:en[0].dims,type:ea,textureType:el},shaderSource:eh,hasMain:!0}};en.add=(er,en)=>[er.run(ex(er,en,el()),en)],en.and=(er,en)=>[er.run(ex(er,en,em(),"bool"),en)],en.div=(er,en)=>[er.run(ex(er,en,ec()),en)],en.equal=(er,en)=>[er.run(ex(er,en,ef(),"bool"),en)],en.greater=(er,en)=>[er.run(ex(er,en,eh(),"bool"),en)],en.less=(er,en)=>[er.run(ex(er,en,eg(),"bool"),en)],en.mul=(er,en)=>[er.run(ex(er,en,ep()),en)],en.or=(er,en)=>[er.run(ex(er,en,eb(),"bool"),en)],en.pow=(er,en)=>[er.run(ex(er,en,ev()),en)],en.pRelu=(er,en)=>[er.run(ex(er,en,e_()),en)],en.sub=(er,en)=>[er.run(ex(er,en,ed()),en)],en.xor=(er,en)=>[er.run(ex(er,en,ey(),"bool"),en)]},4752:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.parseCastAttributes=en.cast=void 0;let eo=ei(7273);en.cast=(er,en,ei)=>(ea(en),[er.cast(en[0],ei)]),en.parseCastAttributes=er=>eo.ProtoUtil.tensorDataTypeFromProto(er.attributes.getInt("to"));let ea=er=>{if(!er||1!==er.length)throw Error("Cast requires 1 input.");if("string"===er[0].type)throw Error("Invalid input type.")}},4595:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.createPackedConcatProgramInfoLoader=void 0;let eo=ei(6757),ea=ei(5639),es=ei(432),eu=ei(5614);en.createPackedConcatProgramInfoLoader=(er,en,ei)=>{var ec,ep;let ed=(ec=en.length,ep=ei.cacheKey,{name:"Concat (packed)",inputNames:Array.from({length:ec},(er,en)=>`X${en}`),inputTypes:Array(ec).fill(ea.TextureType.packed),cacheHint:ep});return Object.assign(Object.assign({},ed),{get:()=>((er,en,ei,ec)=>{let ep=ei[0].dims.slice();if(ec>=ep.length||ec<-1*ep.length)throw Error("axis specified for concat doesn't match input dimensionality");ec<0&&(ec=ep.length+ec);let ed=ep.slice(0);for(let er=1;er<ei.length;er++){let en=ei[er].dims.slice();for(let er=0;er<ep.length;er++)if(er===ec)ed[ec]+=en[er];else if(ep[er]!==en[er])throw Error("non concat dimensions must match")}let ef=ed.length,eh=(0,eu.getChannels)("coords",ef),eg=(0,es.getCoordsDataType)(ef),em=(0,eu.unpackFromChannel)(),eb=ei.map(er=>er.dims),ey=(0,es.getGlChannels)(ef),ev=Array(eb.length-1);ev[0]=eb[0][ec];for(let er=1;er<ev.length;er++)ev[er]=ev[er-1]+eb[er][ec];let e_=ey[ec],ex=ey.slice(-2),ew=ey.join(),eT=`if (${e_} < ${ev[0]}) {
        return getChannel(
            getX0(${ew}), vec2(${ex.join()}));
        }`;for(let er=1;er<ev.length;er++){let en=ev[er-1];eT+=`
            if (${e_} < ${ev[er]}  && ${e_} >= ${ev[er-1]}) {
              return getChannel(
                getX${er}(${el(ey,e_,en)}),
                vec2(${el(ex,e_,en)}));
            }`}let eS=ev.length,eO=ev[ev.length-1];eT+=`
            return getChannel(
              getX${eS}(${el(ey,e_,eO)}),
              vec2(${el(ex,e_,eO)}));`;let eA=(0,eo.getGlsl)(er.session.backend.glContext.version),eE=`
          ${em}
          float getValue(${ey.map(er=>"int "+er)}) {
            ${eT}
          }

          void main() {
            ${eg} coords = getOutputCoords();
            int lastDim = coords.${ey[ef-1]};
            coords.${ey[ef-1]} = coords.${ey[ef-2]};
            coords.${ey[ef-2]} = lastDim;

            vec4 result = vec4(getValue(${eh}), 0., 0., 0.);

            ${eh[ef-1]} = ${eh[ef-1]} + 1;
            if (${eh[ef-1]} < ${ed[ef-1]}) {
              result.g = getValue(${eh});
            }

            ${eh[ef-2]} = ${eh[ef-2]} + 1;
            if (${eh[ef-2]} < ${ed[ef-2]}) {
              result.a = getValue(${eh});
            }

            ${eh[ef-1]} = ${eh[ef-1]} - 1;
            if (${eh[ef-2]} < ${ed[ef-2]} &&
                ${eh[ef-1]} < ${ed[ef-1]}) {
              result.b = getValue(${eh});
            }
            ${eA.output} = result;
          }
        `;return Object.assign(Object.assign({},en),{output:{dims:ed,type:ei[0].type,textureType:ea.TextureType.packed},shaderSource:eE,hasMain:!0})})(er,ed,en,ei.axis)})};let el=(er,en,ei)=>{let eo=er.indexOf(en);return er.map((er,en)=>en===eo?`${er} - ${ei}`:er).join()}},6668:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.parseConcatAttributes=en.concat=void 0;let eo=ei(4910),ea=ei(5639),es=ei(4595);en.concat=(er,en,ei)=>(ef(en),er.session.pack&&en[0].dims.length>1?[er.run((0,es.createPackedConcatProgramInfoLoader)(er,en,ei),en)]:[er.run(eu(er,en,ei),en)]);let eu=(er,en,ei)=>{var eo,es;let eu=(eo=en.length,es=ei.cacheKey,{name:"Concat",inputNames:Array.from({length:eo},(er,en)=>`X${en}`),inputTypes:Array(eo).fill(ea.TextureType.unpacked),cacheHint:es});return Object.assign(Object.assign({},eu),{get:()=>((er,en,ei,eo)=>{let es=ei[0].dims.slice();if(eo>=es.length||eo<-1*es.length)throw Error("axis specified for concat doesn't match input dimensionality");eo<0&&(eo=es.length+eo);let eu=es.slice(0);for(let er=1;er<ei.length;er++){let en=ei[er].dims.slice();for(let er=0;er<es.length;er++)if(er===eo)eu[eo]+=en[er];else if(es[er]!==en[er])throw Error("non concat dimensions must match")}let ef=eu.length,eh=Array(ei.length),eg=0;for(let er=0;er<eh.length;++er)eg+=ei[er].dims[eo],eh[er]=eg;let em="";em=ei.length<5?el(eh):ec(eh);let eb=`
        ${ep(ei.length,ef)}
        ${ed(eh)}
        ${em}
        float process(int indices[${ef}]) {
          int textureIndex = getTextureWhereDataResides (indices[${eo}]);

          if(textureIndex != 0) {
            indices[${eo}] = indices[${eo}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));
          }

          return fetchDataFromCorrectTexture(textureIndex, indices);
        }`;return Object.assign(Object.assign({},en),{output:{dims:eu,type:ei[0].type,textureType:ea.TextureType.unpacked},shaderSource:eb})})(0,eu,en,ei.axis)})},el=er=>`int getTextureWhereDataResides(int index) {
      ${er.map((er,en)=>`if(index<${er}) {return ${en};}
`).join("")}
    }`,ec=er=>el(er),ep=(er,en)=>{let ei=[`float fetchDataFromCorrectTexture(int textureIndex, int indices[${en}]) {`];for(let en=0;en<er;++en)0===en?ei.push(`	if (textureIndex == ${en}) { return _X${en}(indices); }`):en===er-1?ei.push(`	else { return _X${en}(indices); }`):ei.push(`	else if (textureIndex == ${en}) { return _X${en}(indices); }`);return ei.push("	}"),ei.join("\n")},ed=er=>{let en=["int getSizeInConcatAxisValueFromIndex(int index) {"];for(let ei=0;ei<er.length;++ei)0===ei?en.push(`	if (index == ${ei}) { return ${er[ei]}; }`):ei===er.length-1?en.push(`	else { return ${er[ei]}; }`):en.push(`	else if (index == ${ei}) { return ${er[ei]}; }`);return en.push("	}"),en.join("\n")};en.parseConcatAttributes=er=>(0,eo.createAttributeWithCacheKey)({axis:er.attributes.getInt("axis")});let ef=er=>{if(!er||er.length<1)throw Error("too few inputs");let en=er[0].type,ei=er[0].dims.length;if("string"===en)throw Error("string tensor is not supported yet");for(let eo of er){if(eo.type!==en)throw Error("input tensors should be one type");if(eo.dims.length!==ei)throw Error("input tensors should have the same shape")}}},7825:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.createUnpackedGroupedConvProgramInfoLoader=void 0;let eo=ei(1315),ea=ei(6757),es=ei(5639),eu=ei(9754),el=ei(2150);en.createUnpackedGroupedConvProgramInfoLoader=(er,en,ei)=>{var ec,ep;let ed=(ec=en.length>2,ep=ei.cacheKey,{name:"GroupedConv",inputNames:ec?["X","W","Bias"]:["X","W"],inputTypes:ec?[es.TextureType.unpacked,es.TextureType.unpacked,es.TextureType.unpacked]:[es.TextureType.unpacked,es.TextureType.unpacked],cacheHint:ep});return Object.assign(Object.assign({},ed),{get:()=>((er,en,ei,ec)=>{let ep=en.length>2?"value += getBias(output_channel);":"",ed=en[0].dims.slice(),ef=en[1].dims.slice(),eh=ef[0]/ec.group;eo.Logger.verbose("GroupedConv",`autpPad:${ec.autoPad}, dilations:${ec.dilations}, group:${ec.group}, kernelShape:${ec.kernelShape}, pads:${ec.pads}, strides:${ec.strides}`);let eg=(0,eu.calculateOutputShape)(ed,ef,ec.dilations,ec.pads,ec.strides),em=(0,ea.getGlsl)(er.session.backend.glContext.version),{activationFunction:eb,applyActivation:ey}=(0,el.getActivationSnippet)(ec),ev=`
  const ivec2 strides = ivec2(${ec.strides[0]}, ${ec.strides[1]});
  const ivec2 pads = ivec2(${ec.pads[0]}, ${ec.pads[1]});
  ${eb}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;
    ivec2 xRCCorner = coords.zw * strides - pads;
    int group_id = output_channel / ${eh};

    float value = 0.0;
    for (int wInChannel = 0; wInChannel < ${ef[1]}; wInChannel++) {
      int input_channel = group_id * ${ef[1]} + wInChannel;
      for (int wHeight = 0; wHeight < ${ef[2]}; wHeight++) {
        int xHeight = xRCCorner.x + wHeight * ${ec.dilations[0]};

        if (xHeight < 0 || xHeight >= ${ed[2]}) {
          continue;
        }

        for (int wWidth = 0; wWidth < ${ef[3]}; wWidth++) {
          int xWidth = xRCCorner.y + wWidth * ${ec.dilations[1]};
          if (xWidth < 0 || xWidth >= ${ed[3]}) {
            continue;
          }

          float xVal = getX(batch, input_channel, xWidth, xHeight);
          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);
          value += xVal*wVal;
        }
      }
    }
    ${ep}
    ${ey}
    ${em.output} = vec4(value, .0, .0, .0);
  }
`;return Object.assign(Object.assign({},ei),{output:{dims:eg,type:en[0].type,textureType:es.TextureType.unpacked},shaderSource:ev,hasMain:!0})})(er,en,ed,ei)})}},7708:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.conv2DPacked=en.conv2DPackedPointwise=void 0;let eo=ei(9754),ea=ei(5950),es=ei(5632);en.conv2DPackedPointwise=(er,en,ei)=>{let ea=en[0].dims,eu=en[1].dims,el=(0,eo.calculateOutputShape)(ea,eu,ei.dilations,ei.pads,ei.strides),ec=er.reshapePacked(en[0],[ea[1],ea[2]*ea[3]]),ep=er.reshapePacked(en[1],[eu[0],eu[1]]),ed=en.length>2?[ep,ec,en[2]]:[ep,ec],ef=er.run((0,es.createPackedMatmulProgramInfoLoader)(er,ed,ei),ed);return er.reshapePacked(ef,el)},en.conv2DPacked=(er,en,ei)=>{let eu=en[0].dims,el=en[1].dims,ec=(0,eo.calculateOutputShape)(eu,el,ei.dilations,ei.pads,ei.strides),ep=er.run((0,ea.createPackedIm2ColProgramInfoLoader)(er,en[0],en[1],ec,ei),[en[0]]),ed=er.reshapePacked(en[1],[el[0],el[1]*el[2]*el[3]]),ef=3===en.length?[ed,ep,en[2]]:[ed,ep],eh=er.run((0,es.createPackedMatmulProgramInfoLoader)(er,ef,ei),ef);return er.reshapePacked(eh,ec)}},5042:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.parseConvTransposeAttributes=en.convTranspose=void 0;let eo=ei(4910),ea=ei(6757),es=ei(5639),eu=ei(2150),el=(er,en,ei,eo,ea,es)=>(er-1)*en+ei+(eo-1)*ea+1-es,ec=(er,en,ei,eo,ea)=>{let es=Math.floor(er/2);"SAME_UPPER"===en?(ei[eo]=es,ei[ea]=er-es):"SAME_LOWER"===en&&(ei[eo]=er-es,ei[ea]=es)};en.convTranspose=(er,en,ei)=>(eh(en,ei),ep(er,en,ei));let ep=(er,en,ei)=>{let eo=ef(ei,en);return[ed(er,en,eo)]},ed=(er,en,ei)=>er.run(((er,en,ei)=>{var eo,el;let ec=(eo=en.length>2,el=ei.cacheKey,{name:"ConvTranspose",inputNames:eo?["X","W","B"]:["X","W"],inputTypes:eo?[es.TextureType.unpacked,es.TextureType.unpacked,es.TextureType.unpacked]:[es.TextureType.unpacked,es.TextureType.unpacked],cacheHint:el});return Object.assign(Object.assign({},ec),{get:()=>((er,en,ei,eo)=>{let el=en.length>2?"getB(output_channel)":"0.0",ec=en[0].dims,ep=en[1].dims,ed=ep[1],ef=ep[0]/eo.group,eh=[en[0].dims[0],en[1].dims[1]*eo.group,...eo.outputShape],eg=(0,ea.getGlsl)(er.session.backend.glContext.version),{activationFunction:em,applyActivation:eb}=(0,eu.getActivationSnippet)(eo),ey=`
  const ivec2 strides = ivec2(${eo.strides[0]}, ${eo.strides[1]});
  const ivec2 pads = ivec2(${eo.pads[0]}, ${eo.pads[1]});
  ${em}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;

    ivec2 loc = coords.zw + pads;

    int group_id = output_channel / ${ed};
    int wOutChannel = output_channel - group_id * ${ed};

    float value = ${el};
    for (int inChannelOffset = 0; inChannelOffset < ${ef}; inChannelOffset++) {
      int input_channel = group_id * ${ef} + inChannelOffset;
      for (int wWOff = 0; wWOff < ${ep[2]}; wWOff++) {
        for (int wHOff = 0; wHOff < ${ep[3]}; wHOff++) {
          ivec2 wOff = ivec2(wWOff * ${eo.dilations[0]}, wHOff * ${eo.dilations[1]});
          ivec2 wLoc = loc - wOff;
          ivec2 wLocIn = wLoc / strides;
          if (
            wLocIn * strides == wLoc &&
            wLocIn.x >= 0 && wLocIn.x < ${ec[2]} &&
            wLocIn.y >= 0 && wLocIn.y < ${ec[3]}
          ) {
            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);
            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);
            value += xVal * wVal;
          }
        }
      }
    }
    ${eb}
    ${eg.output} = vec4(value, .0, .0, .0);
  }
`;return Object.assign(Object.assign({},ei),{output:{dims:eh,type:en[0].type,textureType:es.TextureType.unpacked},shaderSource:ey,hasMain:!0})})(er,en,ec,ei)})})(er,en,ei),en),ef=(er,en)=>{let ei=er.kernelShape.slice();if(0===er.kernelShape.length)for(let er=2;er<en[1].dims.length;++er)ei.push(en[1].dims[er]);let eo=er.pads.slice(),ea=er.outputShape.slice();((er,en,ei,eo,ea,es,eu,ep)=>{let ed=er.length-2,ef=0===ep.length;for(let eh=0;eh<ed;++eh){let eg=ef?er[eh+2]*es[eh]:ep[eh],em=el(er[eh+2],es[eh],ea[eh],en[eh],ei[eh],eg);ec(em,eo,ea,eh,eh+ed),ef&&ep.push(es[eh]*(er[eh+2]-1)+eu[eh]+(en[eh]-1)*ei[eh]+1-ea[eh]-ea[eh+ed])}})(en[0].dims,ei,er.dilations,er.autoPad,eo,er.strides,er.outputPadding,ea);let es=Object.assign({},er);return Object.assign(es,{kernelShape:ei,pads:eo,outputShape:ea,cacheKey:er.cacheKey}),es};en.parseConvTransposeAttributes=er=>{let en=er.attributes,ei=(0,eu.parseInternalActivationAttributes)(en),ea=en.getString("auto_pad","NOTSET"),es=en.getInts("dilations",[1,1]),el=en.getInt("group",1),ec=en.getInts("kernel_shape",[]),ep=en.getInts("output_padding",[0,0]),ed=en.getInts("output_shape",[]),ef=en.getInts("pads",[0,0,0,0]),eh=en.getInts("strides",[1,1]);return(0,eo.createAttributeWithCacheKey)(Object.assign({autoPad:ea,dilations:es,group:el,kernelShape:ec,outputPadding:ep,outputShape:ed,pads:ef,strides:eh},ei))};let eh=(er,en)=>{if(!er||2!==er.length&&3!==er.length)throw Error("Conv requires 2 or 3 inputs");if(4!==er[0].dims.length||4!==er[1].dims.length)throw Error("currently only support 2-dimensional conv");if(er[0].dims[1]!==er[1].dims[0])throw Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let ei=er[1].dims[1]*en.group;if(3===er.length&&(1!==er[2].dims.length||er[2].dims[0]!==ei))throw Error("invalid bias");let eo=er[0].dims.length-2;if(en.dilations.length!==eo)throw Error(`dilations should be ${eo}D`);if(en.strides.length!==eo)throw Error(`strides should be ${eo}D`);if(en.pads.length!==2*eo)throw Error(`pads should be ${2*eo}D`);if(en.outputPadding.length!==eo)throw Error(`output_padding should be ${eo}D`);if(0!==en.kernelShape.length&&en.kernelShape.length!==er[1].dims.length-2)throw Error("invalid kernel shape");if(0!==en.outputShape.length&&en.outputShape.length!==er[0].dims.length-2)throw Error("invalid output shape");if("float32"!==er[0].type||"float32"!==er[1].type)throw Error("ConvTranspose input(X,W) should be float tensor");if(3===er.length&&"float32"!==er[2].type)throw Error("ConvTranspose input(bias) should be float tensor")}},9754:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.parseConvAttributes=en.conv=en.calculateOutputShape=void 0;let eo=ei(4910),ea=ei(7273),es=ei(7825),eu=ei(7708),el=ei(3281),ec=ei(2150),ep=ei(1625),ed=ei(8276);en.calculateOutputShape=(er,en,ei,eo,ea)=>{let es=er[0],eu=er.slice(2),el=eu.length,ec=en[0],ep=en.slice(2).map((er,en)=>er+(er-1)*(ei[en]-1)),ed=eu.map((er,en)=>er+eo[en]+eo[en+el]).map((er,en)=>Math.floor((er-ep[en]+ea[en])/ea[en]));return[es,ec].concat(...ed)},en.conv=(er,en,ei)=>(eb(en,ei),ef(er,en,ei));let ef=(er,en,ei)=>{let eo=em(ei,en),ea=er.session.pack,el=1===eo.kernelShape[0]&&1===eo.kernelShape[1];return eo.group>1?[er.run((0,es.createUnpackedGroupedConvProgramInfoLoader)(er,en,eo),en)]:el&&ea?[eh(er,en,eo)]:ea&&4===en[0].dims.length&&1===en[0].dims[0]&&!el?[(0,eu.conv2DPacked)(er,en,eo)]:[eg(er,en,eo)]},eh=(er,ei,eo)=>{let ea=ei[0].dims,es=ei[1].dims,eu=(0,en.calculateOutputShape)(ea,es,eo.dilations,eo.pads,eo.strides),el=er.reshapeUnpacked(ei[0],[ea[1],ea[2]*ea[3]]),ec=er.reshapeUnpacked(ei[1],[es[0],es[1]]),ep=ei.length>2?[ec,el,ei[2]]:[ec,el],ef=er.run((0,ed.createMatmulProgramInfoLoader)(ep,eo),ep);return er.reshapeUnpacked(ef,eu)},eg=(er,ei,eo)=>{let ea=ei[0].dims,es=ei[1].dims,eu=(0,en.calculateOutputShape)(ea,es,eo.dilations,eo.pads,eo.strides),ec=er.run((0,ep.createIm2ColProgramInfoLoader)(er,ei[0],ei[1],eu,eo),[ei[0]]),ed=3===ei.length?[ec,ei[1],ei[2]]:[ec,ei[1]];return er.run((0,el.createDotProductProgramInfoLoader)(er,ei,eu,eo),ed)},em=(er,en)=>{let ei=er.kernelShape.slice();if(0===er.kernelShape.length)for(let er=2;er<en[1].dims.length;++er)ei.push(en[1].dims[er]);let eo=er.pads.slice();ea.PoolConvUtil.adjustPadsBasedOnAutoPad(en[0].dims,er.strides,er.dilations,ei,eo,er.autoPad);let es=Object.assign({},er);return Object.assign(es,{kernelShape:ei,pads:eo,cacheKey:er.cacheKey}),es};en.parseConvAttributes=er=>{let en=er.attributes,ei=(0,ec.parseInternalActivationAttributes)(en),ea=en.getString("auto_pad","NOTSET"),es=en.getInts("dilations",[1,1]),eu=en.getInt("group",1),el=en.getInts("kernel_shape",[]),ep=en.getInts("pads",[0,0,0,0]),ed=en.getInts("strides",[1,1]);return(0,eo.createAttributeWithCacheKey)(Object.assign({autoPad:ea,dilations:es,group:eu,kernelShape:el,pads:ep,strides:ed},ei))};let eb=(er,en)=>{if(!er||2!==er.length&&3!==er.length)throw Error("Conv requires 2 or 3 inputs");if(4!==er[0].dims.length||4!==er[1].dims.length)throw Error("currently only support 2-dimensional conv");if(er[0].dims[1]!==er[1].dims[1]*en.group)throw Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(3===er.length&&(1!==er[2].dims.length||er[1].dims[0]!==er[2].dims[0]))throw Error("invalid bias");let ei=er[0].dims.length-2;if(en.dilations.length!==ei)throw Error(`dilations should be ${ei}D`);if(en.strides.length!==ei)throw Error(`strides should be ${ei}D`);if(en.pads.length!==2*ei)throw Error(`pads should be ${2*ei}D`);if(0!==en.kernelShape.length&&en.kernelShape.length!==er[1].dims.length-2)throw Error("invalid kernel shape");if("float32"!==er[0].type||"float32"!==er[1].type)throw Error("Conv input(X,W) should be float tensor");if(3===er.length&&"float32"!==er[2].type)throw Error("Conv input(bias) should be float tensor")}},6742:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.parseDepthToSpaceAttributes=en.depthToSpace=void 0;let eo=ei(5707);en.depthToSpace=(er,en,ei)=>{ea(en);let es=ei.blocksize,eu=es*es,el="DCR"===ei.mode?[0,3,4,1,5,2]:[0,1,4,2,5,3],ec="DCR"===ei.mode?[en[0].dims[0],es,es,en[0].dims[1]/eu,en[0].dims[2],en[0].dims[3]]:[en[0].dims[0],en[0].dims[1]/eu,es,es,en[0].dims[2],en[0].dims[3]],ep=er.reshapeUnpacked(en[0],ec),ed={perm:el,cacheKey:`${el}`},[ef]=(0,eo.transpose)(er,[ep],ed),eh=[en[0].dims[0],en[0].dims[1]/eu,en[0].dims[2]*es,en[0].dims[3]*es];return[er.reshapeUnpacked(ef,eh)]},en.parseDepthToSpaceAttributes=er=>{let en=er.attributes.getInt("blocksize");if(en<1)throw Error(`blocksize must be >= 1, but got : ${en} for DepthToSpace`);let ei=er.attributes.getString("mode","DCR");if("DCR"!==ei&&"CRD"!==ei)throw Error(`unrecognized mode: ${ei} for DepthToSpace`);return{mode:ei,blocksize:en}};let ea=er=>{if(1!==er.length)throw Error(`DepthToSpace expect 1 inputs, but got ${er.length}`);if("string"===er[0].type||4!==er[0].dims.length)throw TypeError("DepthToSpace input should be a 4-D numeric tensor")}},3281:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.createDotProductProgramInfoLoader=void 0;let eo=ei(7273),ea=ei(6757),es=ei(5639),eu=ei(2150),el=ei(1625);en.createDotProductProgramInfoLoader=(er,en,ei,ec)=>{var ep,ed;let ef=(ep=en.length>2,ed=ec,{name:"ConvDotProduct",inputNames:ep?["Im2Col","K","B"]:["Im2Col","K"],inputTypes:ep?[es.TextureType.unpacked,es.TextureType.packedLastDimension,es.TextureType.unpacked]:[es.TextureType.unpacked,es.TextureType.packedLastDimension],cacheKey:ed.activationCacheKey});return Object.assign(Object.assign({},ef),{get:()=>((er,en,ei,ec,ep)=>{let ed=ei[0].dims,ef=ei[1].dims,eh=[ef[0],Math.ceil(ed[1]*ef[2]*ef[3]/4)],eg=(0,el.calculateIm2ColDims)(ed,ef,ec),[em,eb]=er.calculateTextureWidthAndHeight(eh,es.TextureType.packedLastDimension),ey=eo.ShapeUtil.computeStrides(eg),[ev,e_]=er.calculateTextureWidthAndHeight(eg,es.TextureType.packedLastDimension),ex=ec.length,ew=ei.length<3?"0.0":"_B(b)",eT=Math.ceil(ed[1]*ef[2]*ef[3]/4),{activationFunction:eS,applyActivation:eO}=(0,eu.getActivationSnippet)(ep),eA=(0,ea.getGlsl)(er.session.backend.glContext.version),eE=`
${eS}
float process(int indices[${ex}]) {
  int b[1];
  b[0] = indices[1];
  int im2col[4];
  im2col[0] = indices[0];
  im2col[1] = indices[2];
  im2col[2] = indices[3];
  int im2colOffset = im2col[0] * ${ey[0]} + im2col[1] * ${ey[1]} + im2col[2] * ${ey[2]};
  int kernelOffset = indices[1] * ${eh[1]};
  float value = ${ew};
  for (int i = 0; i < ${eT}; ++i) {
    vec2 im2colCoords = offsetToCoords(im2colOffset, ${ev}, ${e_});
    vec2 kernelCoords = offsetToCoords(kernelOffset, ${em}, ${eb});
    value += dot(${eA.texture2D}(Im2Col, im2colCoords), ${eA.texture2D}(K, kernelCoords));
    ++im2colOffset;
    ++kernelOffset;
  }
  ${eO}
  return value;
}`;return Object.assign(Object.assign({},en),{output:{dims:ec,type:ei[0].type,textureType:es.TextureType.unpacked},shaderSource:eE})})(er,ef,en,ei,ec)})}},4125:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.parseFlattenAttributes=en.flatten=void 0;let eo=ei(7273);en.flatten=(er,en,ei)=>{ea(en,ei);let es=eo.ShapeUtil.flattenShape(en[0].dims,ei);return[er.reshapeUnpacked(en[0],es)]},en.parseFlattenAttributes=er=>er.attributes.getInt("axis",1);let ea=(er,en)=>{if(!er||1!==er.length)throw Error("Flatten requires 1 input.");let ei=er[0].dims.length;if(0===ei)throw Error("scalar tensor is not supported.");if(en<-ei||en>ei)throw Error("Invalid axis");if("string"===er[0].type)throw Error("string tensor is not supported.")}},2150:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.parseInternalActivationAttributes=en.getActivationSnippet=void 0;let eo=ei(7273),ea=ei(9087);en.getActivationSnippet=function(er){let en;switch(er.activation){case"Relu":en=(0,ea.glslRelu)();break;case"Sigmoid":en=(0,ea.glslSigmoid)();break;case"Clip":en=(0,ea.glslClip)(er.clipMin,er.clipMax);break;default:return{activationFunction:"",applyActivation:""}}let ei=en.name;return{activationFunction:en.body,applyActivation:`value = ${ei}_(value);`}},en.parseInternalActivationAttributes=er=>{let en=er.getString("activation","");if("Clip"===en){let[ei,ea]=er.getFloats("activation_params",[eo.MIN_CLIP,eo.MAX_CLIP]);return{activation:en,clipMax:ea,clipMin:ei,activationCacheKey:`${en}:${ei},${ea}`}}return{activation:en,activationCacheKey:en}}},6149:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.parseGatherAttributes=en.gather=void 0;let eo=ei(4910),ea=ei(6145),es=ei(7273),eu=ei(5639);en.gather=(er,en,ei)=>(ep(en,ei.axis),[er.run(ec(er,en,ei),en)]),en.parseGatherAttributes=er=>(0,eo.createAttributeWithCacheKey)({axis:er.attributes.getInt("axis",0)});let el={name:"Gather",inputNames:["A","B"],inputTypes:[eu.TextureType.unpacked,eu.TextureType.unpacked]},ec=(er,en,ei)=>{let eo=Object.assign(Object.assign({},el),{cacheHint:ei.cacheKey});return Object.assign(Object.assign({},eo),{get:()=>((er,en,ei,eo)=>{let ea=ei[0].dims.slice(),el=ei[1].dims.slice(),ec=Array(ea.length+el.length-1);eo=es.ShapeUtil.normalizeAxis(eo,ea.length);let ep=[];for(let er=0;er<ec.length;er++)er<eo?(ec[er]=ea[er],ep.push(`inputIdx[${er}] = outputIdx[${er}];`)):er<eo+el.length?(ec[er]=el[er-eo],ep.push(`indexDataIdx[${er-eo}] = outputIdx[${er}];`)):(ec[er]=ea[er-el.length+1],ep.push(`inputIdx[${er-el.length+1}] = outputIdx[${er}];`));let ed=`
      float process(int outputIdx[${ec.length||1}]) {
        int inputIdx[${ea.length}];
        int indexDataIdx[${el.length||1}];
        indexDataIdx[0] = 0;
        ${ep.join("\n        ")}
        int idx = int(_B(indexDataIdx));
        inputIdx[${eo}] = idx < 0 ? idx + ${ea[eo]} : idx;
        return _A(inputIdx);
      }`;return Object.assign(Object.assign({},en),{output:{dims:ec,type:ei[0].type,textureType:eu.TextureType.unpacked},shaderSource:ed})})(0,eo,en,ei.axis)})},ep=(er,en)=>{if(!er||2!==er.length)throw Error("Gather requires 2 inputs.");let ei=er[0].dims.length;if(ei<1)throw Error("Invalid input shape.");if(en<-ei||en>ei-1)throw Error("Invalid axis.");if(-1===ea.NUMBER_TYPES.indexOf(er[0].type)||"int32"!==er[1].type&&"int16"!==er[1].type)throw Error("Invaid input type.")}},5378:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.parseGemmAttributesV11=en.parseGemmAttributesV7=en.gemm=void 0;let eo=ei(4910),ea=ei(7273),es=ei(5639);en.gemm=(er,en,ei)=>(ep(en,ei),[er.run(el(en,ei),en)]);let eu=(er,en)=>{let ei=0!==er.attributes.getInt("transA",0),ea=0!==er.attributes.getInt("transB",0),es=er.attributes.getFloat("alpha",1),eu=er.attributes.getFloat("beta",1);return(0,eo.createAttributeWithCacheKey)({transA:ei,transB:ea,alpha:es,beta:eu,isOptionalC:en})};en.parseGemmAttributesV7=er=>eu(er,!1),en.parseGemmAttributesV11=er=>eu(er,!0);let el=(er,en)=>{let ei={name:"Gemm",inputNames:3===er.length?["A","B","C"]:["A","B"],inputTypes:3===er.length?[es.TextureType.unpacked,es.TextureType.unpacked,es.TextureType.unpacked]:[es.TextureType.unpacked,es.TextureType.unpacked],key:en.cacheKey};return Object.assign(Object.assign({},ei),{get:()=>ec(ei,er,en)})},ec=(er,en,ei)=>{let eo=en[0].dims.slice(),eu=en[1].dims.slice(),[el,ec]=ea.GemmUtil.getShapeOfGemmResult(eo,ei.transA,eu,ei.transB,3===en.length?en[2].dims:void 0),ep=[el,ec];if(!ep)throw Error("Can't use gemm on the given tensors");let ed=eo[eo.length-1],ef="";ei.transA&&(ed=eo[0]),ei.transA&&ei.transB?ef="value += _A_T(a) * _B_T(b);":ei.transA&&!ei.transB?ef="value += _A_T(a) * _B(b);":!ei.transA&&ei.transB?ef="value += _A(a) * _B_T(b);":ei.transA||ei.transB||(ef="value += _A(a) * _B(b);");let eh=ep.length,eg=`
      float process(int indices[${eh}]) {
          int a[${eh}];
          int b[${eh}];
          ${3===en.length?`int c[${en[2].dims.length}];`:""}

          copyVec(indices, a);
          copyVec(indices, b);
          ${3===en.length?"bcastIndices_C(indices, c);":""}

          float value = 0.0;
          for (int k=0; k<${ed}; ++k) {
              a[${eh-1}] = k;
              b[${eh-2}] = k;
              ${ef}
          }

          value = value * alpha;
          ${3===en.length?"value += beta * _C(c);":""}
          return value;
      }`;return Object.assign(Object.assign({},er),{output:{dims:ep,type:en[0].type,textureType:es.TextureType.unpacked},variables:[{name:"alpha",type:"float",data:ei.alpha},{name:"beta",type:"float",data:ei.beta}],shaderSource:eg})},ep=(er,en)=>{if(!er)throw Error("Input is missing");if(en.isOptionalC&&(er.length<2||er.length>3))throw Error("Invaid input shape.");if(!en.isOptionalC&&3!==er.length)throw Error("Gemm requires 3 inputs");if(3===er.length&&1!==er[2].dims.length&&2!==er[2].dims.length)throw Error("Invalid input shape of C");if("float32"!==er[0].type&&"float64"!==er[0].type||"float32"!==er[1].type&&"float64"!==er[1].type||3===er.length&&"float32"!==er[2].type&&"float64"!==er[2].type)throw Error("Invalid input type.");if(er[0].type!==er[1].type||3===er.length&&er[0].type!==er[2].type)throw Error("Input types are mismatched")}},5950:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.createPackedIm2ColProgramInfoLoader=void 0;let eo=ei(6757),ea=ei(5639),es=ei(5614);en.createPackedIm2ColProgramInfoLoader=(er,en,ei,eu,el)=>{var ec;let ep=(ec=el.cacheKey,{name:"Im2Col (packed)",inputNames:["A"],inputTypes:[ea.TextureType.packed],cacheHint:ec});return Object.assign(Object.assign({},ep),{get:()=>((er,en,ei,eu,el,ec)=>{let ep=ei.dims,ed=eu.dims,ef=el.length,eh=[ed[1]*ed[2]*ed[3],el[2]*el[3]],eg=ed[2]*ed[3],em=(0,es.unpackFromChannel)(),eb=(0,eo.getGlsl)(er.session.backend.glContext.version),ey="";for(let er=0;er<=1;er++)for(let en=0;en<=1;en++)ey+=`
            blockIndex = rc.x + ${en};
            pos = rc.y + ${er};

            if(blockIndex < ${eh[1]} && pos < ${eh[0]}) {
              offsetY = int(blockIndex / (${el[ef-1]})) * ${ec.strides[0]} -
                ${ec.pads[0]};
              d0 = offsetY + ${ec.dilations[0]} * (imod(pos, ${eg}) / ${ed[2]});

              if(d0 < ${ep[2]} && d0 >= 0) {
                offsetX = imod(blockIndex, ${el[ef-1]}) * ${ec.strides[1]} -
                  ${ec.pads[1]};
                d1 = offsetX + ${ec.dilations[1]} * imod(imod(pos, ${eg}), ${ed[2]});

                if(d1 < ${ep[3]} && d1 >= 0) {

                  ch = int(float(pos)/ ${eg}.);
                    innerDims = vec2(d0, d1);
                    result[${2*er+en}] = getChannel(
                      getA(0, ch, int(innerDims.x),
                      int(innerDims.y)), innerDims);
                }
              }
            }

          `;let ev=`
      ${em}

      void main() {
        ivec2 rc = getOutputCoords();
          vec4 result = vec4(0.0);
          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
          vec2 innerDims;
          ${ey}
          ${eb.output} = result;
      }
            `;return Object.assign(Object.assign({},en),{output:{dims:eh,type:ei.type,textureType:ea.TextureType.packed},shaderSource:ev,hasMain:!0})})(er,ep,en,ei,eu,el)})}},1625:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.calculateIm2ColDims=en.createIm2ColProgramInfoLoader=void 0;let eo=ei(5639);en.createIm2ColProgramInfoLoader=(er,ei,ea,es,eu)=>{var el;let ec=(el=eu.cacheKey,{name:"Im2Col",inputNames:["X"],inputTypes:[eo.TextureType.unpacked],cacheHint:el});return Object.assign(Object.assign({},ec),{get:()=>((er,ei,ea,es,eu,el)=>{let ec=ea.dims,ep=es.dims,ed=eu.length,ef=(0,en.calculateIm2ColDims)(ec,ep,eu,4),eh=`
        const int XC = ${ec[1]};
        const int XH = ${ec[2]};
        const int XW = ${ec[3]};
        const int KH = ${el.kernelShape[0]};
        const int KW = ${el.kernelShape[1]};
        const int dilationH = ${el.dilations[0]};
        const int dilationW = ${el.dilations[1]};
        const int strideH = ${el.strides[0]};
        const int strideW = ${el.strides[1]};
        const int padH = ${el.pads[0]};
        const int padW = ${el.pads[1]};
        const int KHKW = KH*KW;
        const int XCKHKW = XC * KHKW;
        const int outputChannels = 4;
        vec4 process(int indices[${ed}]) {
          int b  = indices[0]; // batch size
          int oh = indices[1] * strideH - padH; //output height
          int ow = indices[2] * strideW - padW; //output width
          int p = indices[3] * outputChannels; //patch
          vec4 value = vec4(0.0);
          for(int i=0; i < outputChannels; ++i) {
            if(p < XCKHKW) {
              int patchC = p / KHKW;
              int patchH = (p - patchC*KHKW) / KW;
              int patchW = (p - patchC*KHKW) - patchH * KW;
              int xh2 = oh + patchH * dilationH;
              int xw2 = ow + patchW * dilationW;
              int x[${ec.length}];
              x[0] = b;
              x[1] = patchC;
              x[2] = xh2;
              x[3] = xw2;
              if(xh2 >= 0 &&
                  xh2 < XH &&
                  xw2 >= 0 &&
                  xw2 < XW) {
                value[i] = _X(x);
              }
            }
            ++p;
          }
          return value;
        }
        `;return Object.assign(Object.assign({},ei),{output:{dims:ef,type:ea.type,textureType:eo.TextureType.packedLastDimension},shaderSource:eh})})(0,ec,ei,ea,es,eu)})},en.calculateIm2ColDims=(er,en,ei,eo=4)=>[ei[0],ei[2],ei[3],Math.ceil(er[1]*en[2]*en[3]/eo)]},6981:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.parseImageScalerAttributes=en.imageScaler=void 0;let eo=ei(4910),ea=ei(5639);en.imageScaler=(er,en,ei)=>(ec(en),[er.run(eu(er,en,ei),en)]),en.parseImageScalerAttributes=er=>{let en=er.attributes.getFloat("scale"),ei=er.attributes.getFloats("bias");return(0,eo.createAttributeWithCacheKey)({scale:en,bias:ei})};let es={name:"ImageScaler",inputNames:["X"],inputTypes:[ea.TextureType.unpacked]},eu=(er,en,ei)=>{let eo=Object.assign(Object.assign({},es),{cacheHint:ei.cacheKey});return Object.assign(Object.assign({},eo),{get:()=>((er,en,ei,eo)=>{let es=ei[0].dims.slice(),eu=es.length,ec=`
      ${el(eo.bias.length)}
      float process(int indices[${eu}]) {
        return _X(indices) * scale + getBias(bias, indices[1]);
      }`;return Object.assign(Object.assign({},en),{output:{dims:es,type:ei[0].type,textureType:ea.TextureType.unpacked},variables:[{name:"bias",type:"float",arrayLength:eo.bias.length,data:eo.bias},{name:"scale",type:"float",data:eo.scale}],shaderSource:ec})})(0,eo,en,ei)})},el=er=>{let en=[`float getBias(float bias[${er}], int channel) {`];for(let ei=0;ei<er;++ei)0===ei?en.push(`	if (channel == ${ei}) { return bias[${ei}]; }`):ei===er-1?en.push(`	else { return bias[${ei}]; }`):en.push(`	else if (channel == ${ei}) { return bias[${ei}]; }`);return en.push("	}"),en.join("\n")},ec=er=>{if(!er||1!==er.length)throw Error("ImageScaler requires 1 input.");if(4!==er[0].dims.length)throw Error("Invalid input shape.");if("float32"!==er[0].type&&"float64"!==er[0].type)throw Error("Invalid input type.")}},7413:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.parseInstanceNormalizationAttributes=en.instanceNormalization=void 0;let eo=ei(6757),ea=ei(5639);en.instanceNormalization=(er,en,ei)=>{ep(en);let eo=er.run(eu(en[0]),en);return[er.run(ec(er,en[0],ei,eo.dims),[en[0],eo,en[1],en[2]])]},en.parseInstanceNormalizationAttributes=er=>er.attributes.getFloat("epsilon",1e-5);let es={name:"InstanceNormalization_MeanAndVariance",inputNames:["X"],inputTypes:[ea.TextureType.unpacked]},eu=er=>Object.assign(Object.assign({},es),{get:()=>((er,en)=>{let ei=en.dims.slice(),eo=ei[1],es=ei[2]*ei[3],eu=[ei[0],eo],el=`
      vec4 process(int[2] indices) {
        vec4 v = vec4(0.0);
        int a[4];
        a[0] = indices[0];
        a[1] = indices[1];
        float temp = 0.0;
        for(int a2=0; a2<${ei[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${ei[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += x;
          }
        }
        float mean = temp / float(${es});
        temp = 0.0;
        for(int a2=0; a2<${ei[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${ei[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += (x - mean) * (x - mean);
          }
        }
        v.r = mean;
        v.g = temp / float(${es});

        return v;
      }`;return Object.assign(Object.assign({},er),{output:{dims:eu,type:en.type,textureType:ea.TextureType.packedLastDimension},shaderSource:el})})(es,er)}),el={name:"InstanceNormalization_ComputeOutput",inputNames:["X","MeanAndVariance","Scale","B"],inputTypes:[ea.TextureType.unpacked,ea.TextureType.packedLastDimension,ea.TextureType.unpacked,ea.TextureType.unpacked]},ec=(er,en,ei,es)=>{let eu=Object.assign(Object.assign({},el),{cacheHint:`${ei}`});return Object.assign(Object.assign({},eu),{get:()=>((er,en,ei,es,eu)=>{let el=(0,eo.getGlsl)(er.session.backend.glContext.version),[ec,ep]=er.calculateTextureWidthAndHeight(eu,ea.TextureType.packedLastDimension),[ed,ef]=[ec/4,ep],eh=`
      vec4 get_MeanAndVariance(int[2] mv) {
        int offset = indicesToOffset_MeanAndVariance(mv);
        vec2 coords = offsetToCoords(offset, ${ed}, ${ef});
        return ${el.texture2D}(MeanAndVariance, coords);
      }

      float process(int[4] indices) {
        int mv[2];
        mv[0] = indices[0];
        mv[1] = indices[1];
        vec4 mean_and_variance = get_MeanAndVariance(mv);
        float mean = mean_and_variance.r;
        float variance = mean_and_variance.g;

        int sb[1];
        sb[0] = indices[1];
        float scale = _Scale(sb);
        float b = _B(sb);

        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;
      }`;return Object.assign(Object.assign({},en),{output:{dims:ei.dims,type:ei.type,textureType:ea.TextureType.unpacked},variables:[{name:"epsilon",type:"float",data:es}],shaderSource:eh})})(er,eu,en,ei,es)})},ep=er=>{if(!er||3!==er.length)throw Error("InstanceNormalization requires 3 inputs.");let en=er[0],ei=er[1],eo=er[2];if(en.dims.length<3||1!==ei.dims.length||1!==eo.dims.length)throw Error("Invalid input shape.");if(ei.dims[0]!==en.dims[1]||eo.dims[0]!==en.dims[1])throw Error("Input shapes are mismatched.");if("float32"!==en.type&&"float64"!==en.type||"float32"!==ei.type&&"float64"!==ei.type||"float32"!==eo.type&&"float64"!==eo.type)throw Error("Invalid input type.");if(4!==er[0].dims.length)throw Error("Only support 4-D input shape.")}},7006:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.createLrnProgramInfoLoader=en.parseLrnAttributes=en.lrn=void 0;let eo=ei(4910),ea=ei(5639);en.lrn=(er,en,ei)=>(el(en),[er.run(eu(en,ei),en)]),en.parseLrnAttributes=er=>{let en=er.attributes.getFloat("alpha",1e-4),ei=er.attributes.getFloat("beta",.75),ea=er.attributes.getFloat("bias",1),es=er.attributes.getInt("size");return(0,eo.createAttributeWithCacheKey)({alpha:en,beta:ei,bias:ea,size:es})};let es={name:"LRN",inputNames:["X"],inputTypes:[ea.TextureType.unpacked]};function eu(er,en){return Object.assign(Object.assign({},es),{cacheHint:en.cacheKey,get:()=>(function(er,en){let ei=er[0].dims[1],eo=er[0].dims.length,eu=-Math.floor((en.size-1)/2),el=Math.ceil((en.size-1)/2),ec=`float(${en.alpha}) / float(${en.size})`,ep=`
    float process(int indices[${eo}]) {
        int c = indices[1];
        float x = _X(indices);
        float square_sum = 0.0;

        for (int i = ${eu}; i <= ${el}; i++) {
          int idx = c + i;
          if (c >= 0 && c < ${ei}) {
            indices[1] = idx;
            float j = _X(indices);
            square_sum += j * j;
          }
        }
        return x / pow(float(${en.bias}) + ${ec} * square_sum, float(${en.beta}));
    }`;return Object.assign(Object.assign({},es),{cacheHint:en.cacheKey,output:{dims:er[0].dims,type:er[0].type,textureType:ea.TextureType.unpacked},shaderSource:ep})})(er,en)})}en.createLrnProgramInfoLoader=eu;let el=er=>{if(!er||1!==er.length)throw Error("LRN requires 1 input.");if(4!==er[0].dims.length)throw Error('currently only support LRN for input with "NCHW" format');if("float32"!==er[0].type)throw Error("input should be float type")}},5632:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.createPackedMatmulProgramInfoLoader=void 0;let eo=ei(7273),ea=ei(6757),es=ei(5639),eu=ei(432),el=ei(2150),ec=ei(8276);en.createPackedMatmulProgramInfoLoader=(er,en,ei)=>{var ep,ed;let ef=(ep=en.length>2,ed=ei.activationCacheKey,{name:"MatMul (packed)",inputNames:ep?["A","B","Bias"]:["A","B"],inputTypes:ep?[es.TextureType.packed,es.TextureType.packed,es.TextureType.packed]:[es.TextureType.packed,es.TextureType.packed],cacheHint:ed});return Object.assign(Object.assign({},ef),{get:()=>((er,en,ei,ep)=>{let ed=ei.length>2,ef=ed?"value += getBiasForMatmul();":"",eh=ei[0].dims,eg=ei[1].dims,em=eo.BroadcastUtil.calcShape(eh,eg,!0),eb=!eo.ShapeUtil.areEqual(ei[0].dims,ei[1].dims);if(!em)throw Error("Can't use matmul on the given tensors");let ey=eh[eh.length-1],ev=Math.ceil(ey/2),e_=eh.length,ex=eg.length,ew=(0,ea.getGlsl)(er.session.backend.glContext.version),eT=(0,eu.getCoordsDataType)(em.length),eS=em.length,eO=(0,eu.getGlChannels)(),{activationFunction:eA,applyActivation:eE}=(0,el.getActivationSnippet)(ep),eI=ed?`${(0,ec.getBiasForMatmul)(eT,eO,ei[2].dims,em,!0)}`:"",e$=eb?`${function(er,en,ei,ea){let es=[],eu=[],el=ei[0].dims,ec=ei[1].dims,ep=el.length,ed=ec.length,ef=ea.length,eh=ef-ep,eg=ef-ed;(es=el.map((er,ei)=>`coords.${en[ei+eh]}`))[ep-1]="i*2",es.join(", "),(eu=ec.map((er,ei)=>`coords.${en[ei+eg]}`))[ed-2]="i*2",eu.join(", ");let em=eo.BroadcastUtil.getBroadcastDims(el,ea),eb=eo.BroadcastUtil.getBroadcastDims(ec,ea),ey=em.map(er=>`coords.${en[er+eh]} = 0;`).join("\n"),ev=eb.map(er=>`coords.${en[er+eg]} = 0;`).join("\n"),e_=`int lastDim = coords.${en[ef-1]};
  coords.${en[ef-1]} = coords.${en[ef-2]};
  coords.${en[ef-2]} = lastDim;`;return`
vec4 getAAtOutCoordsMatmul(int i) {
  ${er} coords = getOutputCoords();
  ${e_}
  ${ey}
  vec4 outputValue = getA(${es});
  return outputValue;
}

vec4 getBAtOutCoordsMatmul(int i) {
  ${er} coords = getOutputCoords();
  ${e_}
  ${ev}
  vec4 outputValue = getB(${eu});
  return outputValue;
}`}(eT,eO,ei,em)}`:"",eP=eb?"getAAtOutCoordsMatmul(i)":`getA(${function(er,en){let ei="";for(let eo=0;eo<en-2;eo++)ei+=`rc.${er[eo]}, `;return ei+`rc.${er[en-2]}, i*2`}(eO,e_)})`,eD=eb?"getBAtOutCoordsMatmul(i)":`getB(${function(er,en){let ei="";for(let eo=0;eo<en-2;eo++)ei+=`rc.${er[eo]}, `;return ei+`i*2, rc.${er[en-1]}`}(eO,ex)})`,ek=`
            ${e$}
            ${eI}
            ${eA}
            void main() {
              ${eb?"":`${eT} rc =
          getOutputCoords(); int lastDim = rc.${eO[eS-1]}; rc.${eO[eS-1]} =
          rc.${eO[eS-2]}; rc.${eO[eS-2]} = lastDim;
      `}

              vec4 value = vec4(0);
              for (int i = 0; i < ${ev}; i++) {
                vec4 a = ${eP};
                vec4 b = ${eD};

                value += (a.rrbb * b.rgrg);
                value += (a.ggaa * b.baba);
              }
              ${ef}
              ${eE}
              ${ew.output} = value;
            }`;return Object.assign(Object.assign({},en),{output:{dims:em,type:ei[0].type,textureType:es.TextureType.packed},shaderSource:ek,hasMain:!0})})(er,ef,en,ei)})}},8276:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.getBiasForMatmul=en.createMatmulProgramInfoLoader=en.parseMatMulAttributes=en.matMul=void 0;let eo=ei(7273),ea=ei(5639),es=ei(432),eu=ei(2150),el=ei(5632);en.matMul=(er,en,ei)=>(ed(en),er.session.pack?[er.run((0,el.createPackedMatmulProgramInfoLoader)(er,en,ei),en)]:[er.run(ep(en,ei),en)]),en.parseMatMulAttributes=er=>(0,eu.parseInternalActivationAttributes)(er.attributes);let ec=(er,en)=>({name:"MatMul",inputNames:er?["A","B","Bias"]:["A","B"],inputTypes:er?[ea.TextureType.unpacked,ea.TextureType.unpacked,ea.TextureType.unpacked]:[ea.TextureType.unpacked,ea.TextureType.unpacked],cacheHint:en});function ep(er,en){let ei=ec(er.length>2,en.activationCacheKey);return Object.assign(Object.assign({},ei),{get:()=>(function(er,en,ei){let el=en[0].dims,ec=en[1].dims,ep=eo.BroadcastUtil.calcShape(el,ec,!0);if(!ep)throw Error("Can't use matmul on the given tensors");let ed=(0,es.getCoordsDataType)(ep.length),eh=(0,es.getGlChannels)(),{activationFunction:eg,applyActivation:em}=(0,eu.getActivationSnippet)(ei),eb=en.length>2,ey=eb?"value += getBiasForMatmul();":"",ev=eb?`${ef(ed,eh,en[2].dims,ep,!1)}`:"",e_=ep.length,ex=el.length,ew=ec.length,eT=`
    ${eg}
    ${ev}
    float process(int indices[${e_}]) {
        int a[${ex}];
        int b[${ew}];
        bcastMatmulIndices_A(indices, a);
        bcastMatmulIndices_B(indices, b);

        float value;
        for (int k=0; k<${el[el.length-1]}; ++k) {
            a[${ex-1}] = k;
            b[${ew-2}] = k;
            value += _A(a) * _B(b);
        }
        ${ey}
        ${em}
        return value;
    }`;return Object.assign(Object.assign({},er),{output:{dims:ep,type:en[0].type,textureType:ea.TextureType.unpacked},shaderSource:eT})})(ei,er,en)})}en.createMatmulProgramInfoLoader=ep;let ed=er=>{if(!er||2!==er.length)throw Error("MatMul requires 2 inputs.");if(er[0].dims[er[0].dims.length-1]!==er[1].dims[er[1].dims.length-2])throw Error("shared dimension does not match.");if("float32"!==er[0].type&&"float64"!==er[0].type||"float32"!==er[1].type&&"float64"!==er[1].type)throw Error("inputs should be float type");if(er[0].type!==er[1].type)throw Error("inputs types should match")};function ef(er,en,ei,ea,es){let eu="",el=ei.length,ec=ea.length,ep=ec-el;eu=ec<2&&el>0?"coords":ei.map((er,ei)=>`coords.${en[ei+ep]}`).join(", ");let ed=eo.BroadcastUtil.getBroadcastDims(ei,ea).map(er=>`coords.${en[er+ep]} = 0;`).join("\n"),ef="vec4(outputValue.xx, outputValue.yy)";return 1===eo.ShapeUtil.size(ei)&&(ef="vec4(outputValue.x)"),es?`
vec4 getBiasForMatmul() {
  ${er} coords = getOutputCoords();
  ${ed}
  vec4 outputValue = getBias(${eu});
  return ${ef};
}`:`
float getBiasForMatmul() {
  ${er} coords = getOutputCoords();
  ${ed}
  return getBias(coords.x);
}`}en.getBiasForMatmul=ef},9:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.createPackProgramInfoLoader=void 0;let eo=ei(6757),ea=ei(5639),es=ei(432),eu=ei(5614),el={name:"pack",inputNames:["A"],inputTypes:[ea.TextureType.unpackedReversed]};en.createPackProgramInfoLoader=(er,en)=>Object.assign(Object.assign({},el),{get:()=>((er,en)=>{var ei,ec,ep,ed;let ef;let eh=(0,eo.getGlsl)(er.session.backend.glContext.version),eg=en.dims,em=eg.length,eb=en.dims.length,ey=(0,es.getCoordsDataType)(eb),ev=(0,eu.getChannels)("rc",eb),e_=(ei=eb,ec=ev,ep=eg[eg.length-2],ed=eg[eg.length-1],0===ei||1===ei?"":`
    int r = ${ec[ei-2]};
    int c = ${ec[ei-1]};
    int rp1 = ${ec[ei-2]} + 1;
    int cp1 = ${ec[ei-1]} + 1;
    bool rEdge = rp1 >= ${ed};
    bool cEdge = cp1 >= ${ep};
    `);ef=0===em?[1,1]:1===em?[eg[0],1]:[eg[eb-1],eg[eb-2]];let ex=function(er,en,ei){if(0===er)return"false";if(1===er)return`rc > ${en[0]}`;let eo="";for(let ea=er-2;ea<er;ea++)eo+=`${ei[ea]} >= ${en[ea-er+2]}`,ea<er-1&&(eo+="||");return eo}(eb,ef,ev),ew=function(er,en){let ei=er.length;if(0===ei)return"getA(), 0, 0, 0";if(1===ei)return`getA(rc),
            rc + 1 >= ${er[0]} ? 0. : getA(rc + 1),
            0, 0`;let eo="";if(ei>2)for(let er=0;er<ei-2;++er)eo+=`${en[er]},`;return`getA(${eo}r, c),
          rEdge ? 0. : getA(${eo}rp1, c),
          cEdge ? 0. : getA(${eo}r, cp1),
          rEdge || cEdge ? 0. : getA(${eo}rp1, cp1)`}(eg,ev),eT=`
        void main() {
          ${ey} rc = getOutputCoords();

          if(${ex}) {
            ${eh.output} = vec4(0);
          } else {
            ${e_}

            ${eh.output} = vec4(${ew});
          }
        }
      `;return Object.assign(Object.assign({},el),{hasMain:!0,output:{dims:en.dims,type:en.type,textureType:ea.TextureType.packed},shaderSource:eT})})(er,en)})},5614:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.unpackFromChannel=en.getChannels=en.getVecChannels=void 0;let eo=ei(432);function ea(er,en){return(0,eo.getGlChannels)(en).map(en=>`${er}.${en}`)}en.getVecChannels=ea,en.getChannels=function(er,en){return 1===en?[er]:ea(er,en)},en.unpackFromChannel=function(){return"\n    float getChannel(vec4 frag, int dim) {\n      int modCoord = imod(dim, 2);\n      return modCoord == 0 ? frag.r : frag.g;\n    }\n\n    float getChannel(vec4 frag, vec2 innerDims) {\n      vec2 modCoord = mod(innerDims, 2.);\n      return modCoord.x == 0. ?\n        (modCoord.y == 0. ? frag.r : frag.g) :\n        (modCoord.y == 0. ? frag.b : frag.a);\n    }\n  "}},5565:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.parsePadAttributesV11=en.padV11=en.parsePadAttributesV2=en.padV2=void 0;let eo=ei(4910),ea=ei(7273),es=ei(6757),eu=ei(5639),el={name:"Pad",inputNames:["A"],inputTypes:[eu.TextureType.unpacked]};en.padV2=(er,en,ei)=>(ed(en),[er.run(Object.assign(Object.assign({},el),{cacheHint:ei.cacheKey,get:()=>ep(er,en[0],ei)}),en)]),en.parsePadAttributesV2=er=>{let en=er.attributes.getString("mode","constant"),ei=er.attributes.getFloat("value",0),ea=er.attributes.getInts("pads");return(0,eo.createAttributeWithCacheKey)({mode:en,value:ei,pads:ea})},en.padV11=(er,ei,eo)=>{ef(ei);let ea=ec(er,ei,eo);return(0,en.padV2)(er,[ei[0]],ea)},en.parsePadAttributesV11=er=>er.attributes.getString("mode","constant");let ec=(er,en,ei)=>{if(!er.session.isInitializer(en[1].dataId)||en.length>=3&&!er.session.isInitializer(en[2].dataId))throw Error("dynamic pad attributes are not allowed");let ea=Array.from(en[1].integerData),es=en.length>=3?en[2].floatData[0]:0;return(0,eo.createAttributeWithCacheKey)({mode:ei,pads:ea,value:es})},ep=(er,en,ei)=>{let eo=ea.ShapeUtil.padShape(en.dims.slice(),ei.pads),es=eo.length,el=`
      ${eh(er,en,ei)}
      float process(int[${es}] indices) {
          return padA(indices);
      }`;return{name:"Pad",inputNames:["A"],inputTypes:[eu.TextureType.unpacked],output:{dims:eo,type:en.type,textureType:eu.TextureType.unpacked},shaderSource:el}},ed=er=>{if(!er||1!==er.length)throw Error("Pad requires 1 input");if("float32"!==er[0].type&&"float64"!==er[0].type)throw Error("Invalid input type.")},ef=er=>{if(!er||2!==er.length&&3!==er.length)throw Error("Pad requires 2 or 3 inputs");if("int32"!==er[1].type||er.length>=3&&"string"===er[2].type)throw Error("Invalid input type.")},eh=(er,en,ei)=>{let eo=(0,es.getGlsl)(er.session.backend.glContext.version),[el,ec]=er.calculateTextureWidthAndHeight(en.dims,eu.TextureType.unpacked),ep=ea.ShapeUtil.computeStrides(en.dims);switch(ei.mode){case"constant":return eg(eo,en.dims,ep,el,ec,ei.pads,ei.value);case"reflect":return em(eo,en.dims,ep,el,ec,ei.pads);case"edge":return eb(eo,en.dims,ep,el,ec,ei.pads);default:throw Error("Invalid mode")}},eg=(er,en,ei,eo,ea,es,eu)=>{let el=en.length,ec="";for(let er=el-1;er>=0;--er)ec+=`
        k = m[${er}] - ${es[er]};
        if (k < 0)  return constant;
        if (k >= ${en[er]}) return constant;
        offset += k * ${ei[er]};
        `;return`
      float padA(int m[${el}]) {
        const float constant = float(${eu});
        int offset = 0;
        int k = 0;
        ${ec}
        vec2 coords = offsetToCoords(offset, ${eo}, ${ea});
        float value = getColorAsFloat(${er.texture2D}(A, coords));
        return value;
      }
      `},em=(er,en,ei,eo,ea,es)=>{let eu=en.length,el="";for(let er=eu-1;er>=0;--er)el+=`
        k = m[${er}] - ${es[er]};
        if (k < 0) { k = -k; }
        {
          const int _2n_1 = ${2*(en[er]-1)};
          k = int( mod( float(k), float(_2n_1) ) ) ;
          if(k >= ${en[er]}) { k = _2n_1 - k; }
        }
        offset += k * ${ei[er]};
        `;return`
      float padA(int m[${eu}]) {
        int offset = 0;
        int k = 0;
        ${el}
        vec2 coords = offsetToCoords(offset, ${eo}, ${ea});
        float value = getColorAsFloat(${er.texture2D}(A, coords));
        return value;
      }
      `},eb=(er,en,ei,eo,ea,es)=>{let eu=en.length,el="";for(let er=eu-1;er>=0;--er)el+=`
        k = m[${er}] - ${es[er]};
        if (k < 0)  k = 0;
        if (k >= ${en[er]}) k = ${en[er]-1};
        offset += k * ${ei[er]};
      `;return`
      float padA(int m[${eu}]) {
        int offset = 0;
        int k = 0;
        ${el}
        vec2 coords = offsetToCoords(offset, ${eo}, ${ea});
        float value = getColorAsFloat(${er.texture2D}(A, coords));
        return value;
      }
      `}},2834:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.globalMaxPool=en.parseMaxPoolAttributes=en.maxPool=en.parseGlobalAveragePoolAttributes=en.globalAveragePool=en.parseAveragePoolAttributes=en.averagePool=void 0;let eo=ei(4910),ea=ei(7273),es=ei(5639);en.averagePool=(er,en,ei)=>{ef(en);let eo={name:"AveragePool",inputNames:["X"],inputTypes:[es.TextureType.unpacked],cacheHint:ei.cacheKey};return[er.run(Object.assign(Object.assign({},eo),{get:()=>eu(en,eo,!1,ei)}),en)]},en.parseAveragePoolAttributes=er=>{let en=er.attributes.getString("auto_pad","NOTSET"),ei=er.attributes.getInt("ceil_mode",0),ea=0!==er.attributes.getInt("count_include_pad",0),es=er.attributes.getInts("kernel_shape"),eu=er.attributes.getInts("strides",[]),el=er.attributes.getInts("pads",[]);if(0!==ei)throw Error("using ceil() in shape computation is not yet supported for AveragePool");return(0,eo.createAttributeWithCacheKey)({autoPad:en,ceilMode:ei,countIncludePad:ea,kernelShape:es,strides:eu,pads:el})};let eu=(er,en,ei,eo)=>{let[eu,el]=ec(er,eo,ei),ep=ea.ShapeUtil.size(eu.kernelShape),ed="";eu.countIncludePad?ed+=`value /= float(${ep});`:ed+=`value /= float(${ep} - pad);`;let ef=`
        ${eh(er[0].dims,eu,"value += _X(x);",ed,"0.0")}
      `;return Object.assign(Object.assign({},en),{output:{dims:el,type:er[0].type,textureType:es.TextureType.unpacked},shaderSource:ef})};en.globalAveragePool=(er,en,ei)=>{ef(en);let eo={name:"GlobalAveragePool",inputNames:["X"],inputTypes:[es.TextureType.unpacked],cacheHint:`${ei.countIncludePad}`};return[er.run(Object.assign(Object.assign({},eo),{get:()=>eu(en,eo,!0,ei)}),en)]},en.parseGlobalAveragePoolAttributes=er=>{let en=0!==er.attributes.getInt("count_include_pad",0);return(0,eo.createAttributeWithCacheKey)({autoPad:"",ceilMode:0,countIncludePad:en,kernelShape:[],strides:[],pads:[]})},en.maxPool=(er,en,ei)=>{ef(en);let eo={name:"MaxPool",inputNames:["X"],inputTypes:[es.TextureType.unpacked],cacheHint:ei.cacheKey};return[er.run(Object.assign(Object.assign({},eo),{get:()=>el(en,eo,!1,ei)}),en)]},en.parseMaxPoolAttributes=er=>{let en=er.attributes.getString("auto_pad","NOTSET"),ei=er.attributes.getInt("ceil_mode",0),ea=er.attributes.getInts("kernel_shape"),es=er.attributes.getInts("strides",[]),eu=er.attributes.getInts("pads",[]),el=er.attributes.getInt("storage_order",0),ec=er.attributes.getInts("dilations",[]);if(0!==el)throw Error("column major storage order is not yet supported for MaxPool");if(0!==ei)throw Error("using ceil() in shape computation is not yet supported for MaxPool");return(0,eo.createAttributeWithCacheKey)({autoPad:en,ceilMode:ei,countIncludePad:!1,kernelShape:ea,strides:es,pads:eu,storageOrder:el,dilations:ec})};let el=(er,en,ei,eo)=>{let[ea,eu]=ec(er,eo,ei),el=`
      ${eh(er[0].dims,ea,"\n      value = max(_X(x), value);\n    ","","-1e5")}
    `;return Object.assign(Object.assign({},en),{output:{dims:eu,type:er[0].type,textureType:es.TextureType.unpacked},shaderSource:el})},ec=(er,en,ei)=>{let eo=er[0].dims.slice(),es=Object.hasOwnProperty.call(en,"dilations"),eu=en.kernelShape.slice(),el=en.strides.slice(),ec=es?en.dilations.slice():[],ep=en.pads.slice();ea.PoolConvUtil.adjustPoolAttributes(ei,eo,eu,el,ec,ep);let ed=ea.PoolConvUtil.computePoolOutputShape(ei,eo,el,ec,eu,ep,en.autoPad),ef=Object.assign({},en);return es?Object.assign(ef,{kernelShape:eu,strides:el,pads:ep,dilations:ec,cacheKey:en.cacheKey}):Object.assign(ef,{kernelShape:eu,strides:el,pads:ep,cacheKey:en.cacheKey}),[ef,ed]},ep={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},ed={name:"GlobalMaxPool",inputNames:["X"],inputTypes:[es.TextureType.unpacked]};en.globalMaxPool=(er,en)=>(ef(en),[er.run(Object.assign(Object.assign({},ed),{get:()=>el(en,ed,!0,ep)}),en)]);let ef=er=>{if(!er||1!==er.length)throw Error("Pool ops requires 1 input.");if("float32"!==er[0].type&&"float64"!==er[0].type)throw Error("Invalid input type.")},eh=(er,en,ei,eo,es)=>{let eu=er.length;if(en.kernelShape.length<=2){let ea=en.kernelShape[en.kernelShape.length-1],el=en.strides[en.strides.length-1],ec=en.pads[en.pads.length/2-1],ep=en.pads[en.pads.length-1],ed=er[eu-1],ef="",eh="",eg="";if(ef=ec+ep!==0?`
          for (int i = 0; i < ${ea}; i++) {
            x[${eu} - 1] = indices[${eu} - 1] * ${el} - ${ec} + i;
            if (x[${eu} - 1] < 0 || x[${eu} - 1] >= ${ed}) {
              pad++;
              continue;
            }
            ${ei}
          }`:`
          for (int i = 0; i < ${ea}; i++) {
            x[${eu} - 1] = indices[${eu} - 1] * ${el} - ${ec} + i;
            ${ei}
          }`,2===en.kernelShape.length){let ei=en.kernelShape[en.kernelShape.length-2],eo=en.strides[en.strides.length-2],es=en.pads[en.pads.length/2-2],el=en.pads[en.pads.length-2],ec=er[eu-2];eh=es+el!==0?`
            for (int j = 0; j < ${ei}; j++) {
              x[${eu} - 2] = indices[${eu} - 2] * ${eo} - ${es} + j;
              if (x[${eu} - 2] < 0 || x[${eu} - 2] >= ${ec}) {
                pad+= ${ea};
                continue;
              }
          `:`
            for (int j = 0; j < ${ei}; j++) {
              x[${eu} - 2] = indices[${eu} - 2] * ${eo} - ${es} + j;
            `,eg="\n          }\n        "}return`
        float process(int indices[${eu}]) {
          int x[${eu}];
          copyVec(indices, x);

          float value = ${es};
          int pad = 0;
          ${eh}
          ${ef}
          ${eg}
          ${eo}
          return value;
        }
      `}{let el=ea.ShapeUtil.size(en.kernelShape),ec=ea.ShapeUtil.computeStrides(en.kernelShape),ep=ec.length,ed=en.pads.length,ef=em(ep),eh=eg(er,"inputDims"),eb=eg(en.pads,"pads"),ey=eg(ec,"kernelStrides"),ev=eg(en.strides,"strides"),e_="";return`
        ${ef}
        float process(int indices[${eu}]) {
          int x[${eu}];
          copyVec(indices, x);
          int offset[${ep}];
          int pads[${ed}];
          int inputDims[${eu}];
          int kernelStrides[${ep}];
          int strides[${ep}];
          ${eb}
          ${eh}
          ${ev}
          ${ey}

          float value = ${es};
          int pad = 0;
          bool isPad = false;
          for (int i = 0; i < ${el}; i++) {
            offsetToIndices(i, kernelStrides, offset);
            isPad = false;
            for (int j = ${eu} - ${ep}; j < ${eu}; j++) {
              x[j] = indices[j] * strides[j - ${eu} + ${ep}]
                + offset[j - ${eu} + ${ep}] - pads[j - 2];
              ${e_=en.pads.reduce((er,en)=>er+en)?`
            if (x[j] >= inputDims[j] || x[j] < 0) {
              pad++;
              isPad = true;
              break;
            }
          }
          if (!isPad) {
            ${ei}
          }`:`
          }
          ${ei}
        `}
          }
          ${eo}

          return value;
        }
      `}},eg=(er,en)=>{let ei="";for(let eo=0;eo<er.length;eo++)ei+=`
      ${en}[${eo}] = ${er[eo]};
    `;return ei},em=er=>`
  void offsetToIndices(int offset, int[${er}] strides, out int[${er}] indices) {
    if (${er} == 0) {
      return;
    }
    for (int i = 0; i < ${er} - 1; ++i) {
      indices[i] = offset / strides[i];
      offset -= indices[i] * strides[i];
    }
    indices[${er} - 1] = offset;
  }`},1010:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.reduceLogSumSquare=en.reduceLogSum=en.reduceProd=en.reduceMin=en.reduceMax=en.reduceMean=en.reduceSum=en.parseReduceAttributes=void 0;let eo=ei(4910),ea=ei(6145),es=ei(7273),eu=ei(5639),el=(er,en,ei,eo,ea)=>{ep(en);let es={name:eo,inputNames:["A"],inputTypes:[eu.TextureType.unpacked]};return[er.run(Object.assign(Object.assign({},es),{cacheHint:ei.cacheKey,get:()=>ec(er,en,ei,eo,ea,es)}),en)]};en.parseReduceAttributes=er=>{let en=er.attributes.getInts("axes",[]),ei=1===er.attributes.getInt("keepdims",1);return(0,eo.createAttributeWithCacheKey)({axes:en,keepDims:ei})};let ec=(er,en,ei,eo,ea,el)=>{let ec=[],ep=en[0].dims.length||1,ed=[],ef=es.ShapeUtil.normalizeAxes(ei.axes,en[0].dims.length),eh=ea(en,ef),eg=eh[1];for(let er=0;er<en[0].dims.length;er++)ef.indexOf(er)>=0||0===ef.length?(ei.keepDims&&ec.push(1),eg=`
          for(int j${er} = 0; j${er} < ${en[0].dims[er]}; j${er}++) {
            inputIdx[${er}] = j${er};
            ${eg}
          }`):(ed.push(`inputIdx[${er}] = outputIdx[${ec.length}];`),ec.push(en[0].dims[er]));let em=`
      float process(int outputIdx[${ec.length||1}]) {
        float value;                 // final result
        int inputIdx[${ep}];      // addressing input data
        ${ed.join("\n")}
        ${eh[0]}       // init ops for reduce max/min
        ${eg}
        ${eh[2]}       // final computation for reduce mean
        return value;
      }`;return Object.assign(Object.assign({},el),{output:{dims:ec,type:en[0].type,textureType:eu.TextureType.unpacked},shaderSource:em})},ep=er=>{if(!er||1!==er.length)throw Error("Reduce op requires 1 input.");if(-1===ea.NUMBER_TYPES.indexOf(er[0].type))throw Error("Invalid input type.")};en.reduceSum=(er,en,ei)=>el(er,en,ei,"ReduceSum",()=>["value = 0.0;","value += _A(inputIdx);",""]),en.reduceMean=(er,en,ei)=>el(er,en,ei,"ReduceMean",(er,en)=>{let ei=1;for(let eo=0;eo<er[0].dims.length;eo++)(en.indexOf(eo)>=0||0===en.length)&&(ei*=er[0].dims[eo]);return["value = 0.0;","value += _A(inputIdx);",`value /= ${ei}.;`]}),en.reduceMax=(er,en,ei)=>el(er,en,ei,"ReduceMax",(er,en)=>{let ei=[];for(let eo=0;eo<er[0].dims.length;eo++)(en.indexOf(eo)>=0||0===en.length)&&ei.push(`inputIdx[${eo}] = 0;`);return[`${ei.join("\n")}
value = _A(inputIdx);`,"value = max(value, _A(inputIdx));",""]}),en.reduceMin=(er,en,ei)=>el(er,en,ei,"ReduceMin",(er,en)=>{let ei=[];for(let eo=0;eo<er[0].dims.length;eo++)(en.indexOf(eo)>=0||0===en.length)&&ei.push(`inputIdx[${eo}] = 0;`);return[`${ei.join("\n")}
value = _A(inputIdx);`,"value = min(value, _A(inputIdx));",""]}),en.reduceProd=(er,en,ei)=>el(er,en,ei,"ReduceProd",()=>["value = 1.0;","value *= _A(inputIdx);",""]),en.reduceLogSum=(er,en,ei)=>el(er,en,ei,"ReduceLogSum",()=>["value = 0.0;","value += _A(inputIdx);","value = log(value);"]),en.reduceLogSumSquare=(er,en,ei)=>el(er,en,ei,"ReduceLogSumSquare",()=>["float t; value = 0.0;","t = _A(inputIdx); value += t * t;",""])},7379:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.isReshapeCheap=en.processDims3D=en.createPackedReshape3DProgramInfoLoader=void 0;let eo=ei(7273),ea=ei(6757),es=ei(5639),eu=ei(5614);en.createPackedReshape3DProgramInfoLoader=(er,en,ei)=>{var el;let ec=(el=ei,{name:"Reshape (packed)",inputTypes:[es.TextureType.packed],inputNames:["A"],cacheHint:`${el}`});return Object.assign(Object.assign({},ec),{get:()=>((er,en,ei,el)=>{let ec=en.dims,ep=el,ed="";for(let er=0;er<4;er++){let en="";switch(er){case 0:en="outputCoords = rc;";break;case 1:en="outputCoords = ivec3(rc.x, rc.y+1, rc.z);";break;case 2:en="outputCoords = ivec3(rc.x, rc.y, rc.z+1);";break;case 3:en="outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);";break;default:throw Error()}ed+=`
        ${en}
        ${er>0?"if(outputCoords.y < rows && outputCoords.z < cols){":""}
          int flattenedIndex = getFlattenedIndex(outputCoords);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);
          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${er}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);

        ${er>0?"}":""}
      `}let ef=(0,ea.getGlsl)(er.session.backend.glContext.version),eh=`
      ${function(er){let en=eo.ShapeUtil.computeStrides(er),ei=["b","r","c"],ea="index";return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${en.map((er,eo)=>`int ${ei[eo]} = ${ea} / ${er}; ${eo===en.length-1?`int ${ei[eo+1]} = ${ea} - ${ei[eo]} * ${er}`:`index -= ${ei[eo]} * ${er}`};`).join("")}
      return ivec3(b, r, c);
    }
  `}(ec)}
      ${function(er){let en=eo.ShapeUtil.computeStrides(er);return`
  int getFlattenedIndex(ivec3 coords) {
    // reverse y, z order
    return coords.x * ${en[0]} + coords.z * ${en[1]} + coords.y;
  }
`}(ep)}
      ${(0,eu.unpackFromChannel)()}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.0);

        ivec3 outputCoords;
        int rows = ${ep[2]};
        int cols = ${ep[1]};

        ${ed}
        ${ef.output} = result;
      }
    `;return Object.assign(Object.assign({},ei),{output:{dims:ep,type:en.type,textureType:es.TextureType.packed},shaderSource:eh,hasMain:!0})})(er,en,ec,ei)})},en.processDims3D=function(er){if(0===er.length)return[1,1,1];let en=1;for(let ei=0;ei<er.length-2;++ei)en*=er[ei];return[en,er.length>1?er[er.length-2]:1,er[er.length-1]]},en.isReshapeCheap=function(er,en){return 0===er.length||0===en.length||(er.length<2||en.length<2?er[er.length-1]===en[en.length-1]:er[er.length-1]===en[en.length-1]&&er[er.length-2]===en[en.length-2])}},8126:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.reshape=void 0;let eo=ei(7273);en.reshape=(er,en)=>{let ei=eo.ShapeUtil.calculateReshapedDims(en[0].dims,en[1].integerData);return er.session.pack?[er.reshapePacked(en[0],ei)]:[er.reshapeUnpacked(en[0],ei)]}},2801:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.parseResizeAttributesV11=en.parseResizeAttributesV10=en.resize=void 0;let eo=ei(6757),ea=ei(5639),es=ei(432),eu=ei(5614),el=ei(3980),ec={name:"Resize",inputNames:["A"],inputTypes:[ea.TextureType.packed]};en.resize=(er,en,ei)=>((0,el.validateInputs)(en,ei),[er.run(Object.assign(Object.assign({},ec),{cacheHint:ei.cacheKey,get:()=>ep(er,en,ei)}),en)]),en.parseResizeAttributesV10=er=>(0,el.parseUpsampleAttributes)(er,10),en.parseResizeAttributesV11=er=>(0,el.parseUpsampleAttributes)(er,11);let ep=(er,en,ei)=>{let el=(0,eo.getGlsl)(er.session.backend.glContext.version),[ep,ef]=ed(en,ei);if(ep.every(er=>1===er)&&"tf_crop_and_resize"!==ei.coordinateTransformMode)return Object.assign(Object.assign({},ec),{output:{dims:ef,type:en[0].type,textureType:ea.TextureType.packed},hasMain:!0,shaderSource:`void main() {
                    vec4 v = ${el.texture2D}(X, TexCoords);
                    ${el.output} = v;
                }`});let eh=ef.length;if(eh<2)throw Error(`output dimension should be at least 2, but got ${eh}`);let eg=ef[eh-2],em=ef[eh-1],eb=en[0].dims;if(eh!==eb.length)throw Error(`output dimension should match input ${eb.length}, but got ${eh}`);let ey=eb[eh-2],ev=eb[eh-1],e_=ep[eh-2],ex=ep[eh-1],ew="";if("linear"!==ei.mode)throw Error(`resize (packed) does not support mode: '${ei.mode}'`);switch(ei.coordinateTransformMode){case"asymmetric":ew="\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        return vec4(coords) / scaleWHWH;\n                    }\n                ";break;case"half_pixel":ew="\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;\n                    }\n                ";break;case"pytorch_half_pixel":ew=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 fcoords = vec4(coords);
                        return vec4(
                            ${em}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,
                            ${eg}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,
                            ${em}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,
                            ${eg}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0
                          );
                    }
                `;break;case"align_corners":ew=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 resized = vec4(${em}.0 - 1.0, ${eg}.0 - 1.0, ${em}.0 - 1.0,
                            ${eg}.0 - 1.0);
                        vec4 original = vec4(${ev}.0 - 1.0, ${ey}.0 - 1.0, ${ev}.0 - 1.0,
                            ${ey}.0 - 1.0);
                        vec4 new_scale = original / resized;
                        return vec4(coords) * new_scale;
                    }
                `;break;default:throw Error(`resize (packed) does not support coordinateTransformMode:                                 '${ei.coordinateTransformMode}'`)}let eT=(0,es.getCoordsDataType)(eh),eS=`
            const vec2 inputWH = vec2(${ey}.0, ${ev}.0);
            const vec4 scaleWHWH = vec4(float(${e_}), float(${ex}), float(${e_}), float(${ex}));
            ${(0,eu.unpackFromChannel)()}
            ${ew}
            float getAValue(int x10, int r, int c, int d) {
                return getChannel(getA(x10, r, c, d), vec2(c, d));
            }
            void main() {
                ${eT} rc = getOutputCoords();

                int batch = rc[0];
                int depth = rc[1];

                // retrieve the 4 coordinates that is used in the 4 packed output values.
                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);

                // calculate the source index in fraction
                vec4 sourceFrac = getSourceFracIndex(coords);

                // get the lower and upper bound of the 4 values that will be packed into one texel.
                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));
                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));
                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));
                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));

                bool hasNextRow = rc.w < ${eg-1};
                bool hasNextCol = rc.z < ${em-1};

                // pack x00, x01, x10, x11's top-left corner into one vec4 structure
                vec4 topLeft = vec4(
                    getAValue(batch, depth, x00.x, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);

                // pack x00, x01, x10, x11's top-right corner into one vec4 structure
                vec4 topRight = vec4(
                    getAValue(batch, depth, x00.x, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);

                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure
                vec4 bottomLeft = vec4(
                    getAValue(batch, depth, x00.z, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);

                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure
                vec4 bottomRight = vec4(
                    getAValue(batch, depth, x00.z, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);

                // calculate the interpolation fraction on u and v direction
                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);
                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));

                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);
                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);
                vec4 newValue = mix(top, bottom, clampFrac.xxzz);

                ${el.output} = vec4(newValue);
            }
        `;return Object.assign(Object.assign({},ec),{output:{dims:ef,type:en[0].type,textureType:ea.TextureType.packed},hasMain:!0,shaderSource:eS})},ed=(er,en)=>{let ei=er[0].dims,eo,ea=en.scales;if(0===ea.length){let es=er[en.scalesInputIdx];if(es&&0!==es.size){if(er[en.sizesInputIdx])throw Error("Only one of scales or sizes must be provided as input.");ea=ef(es,en.mode,en.isResize)}else{let es=er[en.sizesInputIdx];if(!es||0===es.size)throw Error("Either scales or sizes MUST be provided as input.");ea=eh(eo=Array.from(es.integerData),ei,en.mode,en.isResize)}}else if(er[en.sizesInputIdx])throw Error("Only one of scales or sizes must be provided as input.");let es=eo||ei.map((er,en)=>Math.floor(er*ea[en]));return[ea,es]},ef=(er,en,ei)=>{let eo=Array.from(er.floatData);return(0,el.scalesValidation)(eo,en,ei),eo},eh=(er,en,ei,eo)=>{let ea=en.length,es=Array(ea);for(let ei=0,eo=ea;ei<eo;ei++)if(0===en[ei]){if(0!==er[ei])throw Error("Input dim is zero but required output dim is non-zero.");es[ei]=1}else es[ei]=er[ei]/en[ei];return(0,el.scalesValidation)(es,ei,eo),es}},565:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.shape=void 0;let eo=ei(9240);en.shape=(er,en)=>(ea(en),[new eo.Tensor([en[0].dims.length],"int32",void 0,void 0,new Int32Array(en[0].dims))]);let ea=er=>{if(!er||1!==er.length)throw Error("Shape requires 1 input.")}},2444:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.sliceV10=en.parseSliceAttributes=en.slice=void 0;let eo=ei(4910),ea=ei(6145),es=ei(7273),eu=ei(5639),el={name:"Slice",inputNames:["A"],inputTypes:[eu.TextureType.unpacked]};en.slice=(er,en,ei)=>(ep(en),[er.run(Object.assign(Object.assign({},el),{cacheHint:ei.cacheKey,get:()=>ec(er,en[0],ei)}),en)]),en.parseSliceAttributes=er=>{let en=er.attributes.getInts("starts"),ei=er.attributes.getInts("ends"),ea=er.attributes.getInts("axes",[]);return(0,eo.createAttributeWithCacheKey)({starts:en,ends:ei,axes:ea})};let ec=(er,en,ei)=>{let eo=0===ei.axes.length?en.dims.slice(0).map((er,en)=>en):ei.axes,ea=es.ShapeUtil.normalizeAxes(eo,en.dims.length),ec=ei.starts.map((er,ei)=>er>en.dims[ea[ei]]-1?en.dims[ea[ei]]:es.ShapeUtil.normalizeAxis(er,en.dims[ea[ei]])),ep=ei.ends.map((er,ei)=>er>en.dims[ea[ei]]-1?en.dims[ea[ei]]:es.ShapeUtil.normalizeAxis(er,en.dims[ea[ei]])),ed=en.dims.slice(),ef=[];for(let er=0;er<ea.length;er++)ed[ea[er]]=ep[er]-ec[er],ec[er]>0&&ef.push(`outputIdx[${ea[er]}] += ${ec[er]};`);let eh=`
      float process(int outputIdx[${ed.length}]) {
        ${ef.join("\n      ")}
        return _A(outputIdx);
      }`;return Object.assign(Object.assign({},el),{output:{dims:ed,type:en.type,textureType:eu.TextureType.unpacked},shaderSource:eh})},ep=er=>{if(!er||1!==er.length)throw Error("Slice requires 1 input.");if(-1===ea.NUMBER_TYPES.indexOf(er[0].type))throw Error("Invalid input type.")};en.sliceV10=(er,en)=>{ef(en);let ei=ed(er,en);return[er.run(Object.assign(Object.assign({},el),{cacheHint:ei.cacheKey,get:()=>ec(er,en[0],ei)}),[en[0]])]};let ed=(er,en)=>{if(!er.session.isInitializer(en[1].dataId)||!er.session.isInitializer(en[2].dataId)||en.length>=4&&!er.session.isInitializer(en[3].dataId)||en.length>=5&&!er.session.isInitializer(en[4].dataId))throw Error("dynamic slice attributes are not allowed");if(en.length>=5&&en[4].integerData.some(er=>1!==er))throw Error("currently non-1 steps is not supported for Slice");let ei=Array.from(en[1].integerData),eo=Array.from(en[2].integerData),ea=en.length>=4?Array.from(en[3].integerData):[];return{starts:ei,ends:eo,axes:ea,cacheKey:`${ea};${ei};${eo}`}},ef=er=>{if(!er||er.length<3||er.length>5)throw Error("Invalid input number.");if("int32"!==er[1].type||1!==er[1].dims.length||"int32"!==er[2].type||1!==er[2].dims.length||er.length>=4&&("int32"!==er[3].type||1!==er[3].dims.length)||er.length>=5&&("int32"!==er[4].type||1!==er[4].dims.length))throw Error("Invalid input type.")}},815:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.softmaxV13=en.parseSoftmaxAttributesV13=en.parseSoftmaxAttributes=en.softmax=void 0;let eo=ei(4910),ea=ei(7273),es=ei(6757),eu=ei(5639),el=ei(5707),ec={name:"SoftmaxComputeMax",inputNames:["A"],inputTypes:[eu.TextureType.unpacked]},ep={name:"SoftmaxComputeScale",inputNames:["A","Max"],inputTypes:[eu.TextureType.unpacked,eu.TextureType.unpacked]},ed={name:"SoftMax",inputNames:["A","Max","Norm"],inputTypes:[eu.TextureType.unpacked,eu.TextureType.unpacked,eu.TextureType.unpacked]};en.softmax=(er,en,ei)=>{eb(en);let eo=en[0].dims.slice(),es=ea.ShapeUtil.normalizeAxis(ei.axis,eo.length),eu=ea.ShapeUtil.sizeToDimension(eo,es),el=ea.ShapeUtil.sizeFromDimension(eo,es);return ef(er,en,ei,eu,el)},en.parseSoftmaxAttributes=er=>(0,eo.createAttributeWithCacheKey)({axis:er.attributes.getInt("axis",1)}),en.parseSoftmaxAttributesV13=er=>(0,eo.createAttributeWithCacheKey)({axis:er.attributes.getInt("axis",-1)}),en.softmaxV13=(er,en,ei)=>{eb(en);let es=en[0].dims.slice(),eu=ea.ShapeUtil.normalizeAxis(ei.axis,es.length),ec=es.length,ep=eu!==ec-1,ed=[],eh,eg=[],em=[];ep&&((eg=Array.from({length:ec}).map((er,en)=>en))[eu]=ec-1,eg[ec-1]=eu,eg.map(er=>ed.push(es[er])),eh=(0,eo.createAttributeWithCacheKey)({perm:eg}),em=(0,el.transpose)(er,en,eh));let ey=ep?ea.ShapeUtil.sizeToDimension(ed,ec-1):ea.ShapeUtil.sizeToDimension(es,ec-1),ev=ep?ea.ShapeUtil.sizeFromDimension(ed,ec-1):ea.ShapeUtil.sizeFromDimension(es,ec-1),e_=ef(er,ep?em:en,ei,ey,ev);return ep?(0,el.transpose)(er,e_,eh):e_};let ef=(er,en,ei,eo,ea)=>{let es=eh(er,en[0],eo,ea,[eo]),eu=er.run(Object.assign(Object.assign({},ec),{cacheHint:ei.cacheKey,get:()=>es}),en),el=eg(er,en[0],eo,ea,es.output.dims,[eo]),ef=er.run(Object.assign(Object.assign({},ep),{cacheHint:ei.cacheKey,get:()=>el}),[en[0],eu]),eb=em(er,en[0],eo,ea,es.output.dims,el.output.dims);return[er.run(Object.assign(Object.assign({},ed),{cacheHint:ei.cacheKey,get:()=>eb}),[en[0],eu,ef])]},eh=(er,en,ei,eo,ea)=>{let[el,ep]=er.calculateTextureWidthAndHeight(en.dims,eu.TextureType.unpacked),ed=ea.length;if(ei<1||eo<1)throw Error("Logical row count N and feature count D must be greater than or equal to 1");if(1!==ea.length)throw Error("Dimensionality of the output should be 1");if(ea[0]!==ei)throw Error("Shape of the output should be equal to logical row count");let ef=(0,es.getGlsl)(er.session.backend.glContext.version),eh=`
      float process(int[${ed}] indices) {
        int logical_row_start_offset = indices[0] * ${eo};

        float max = getColorAsFloat(${ef.texture2D}(A, offsetToCoords(logical_row_start_offset, ${el},
        ${ep} )));
        for(int i=1; i<${eo}; ++i)
        {
          float current = getColorAsFloat(${ef.texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${el}, ${ep})));
          if(current > max)
          max = current;
        }

        return max;
      }`;return Object.assign(Object.assign({},ec),{output:{dims:ea,type:en.type,textureType:eu.TextureType.unpacked},shaderSource:eh})},eg=(er,en,ei,eo,ea,el)=>{let[ec,ed]=er.calculateTextureWidthAndHeight(en.dims,eu.TextureType.unpacked),ef=el.length;if(ei<1||eo<1)throw Error("Logical row count N and feature count D must be greater than or equal to 1");if(1!==el.length)throw Error("Dimensionality of the output should be 1");if(el[0]!==ei)throw Error("Shape of the output should be equal to logical row count");if(1!==ea.length)throw Error("Dimensionality of the intermediate results should be 1");if(ea[0]!==ei)throw Error("Shape of the intermediate results should be equal to logical row count");let eh=`
      float process(int[${ef}] indices) {
        int logical_row_start_offset = indices[0] * ${eo};

        float norm_factor = 0.0;
        float max = _Max(indices);
        for(int i=0; i<${eo}; ++i)
        {
          norm_factor += exp(getColorAsFloat(${(0,es.getGlsl)(er.session.backend.glContext.version).texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${ec}, ${ed}))) - max);
        }

        return norm_factor;
      }`;return Object.assign(Object.assign({},ep),{output:{dims:el,type:en.type,textureType:eu.TextureType.unpacked},shaderSource:eh})},em=(er,en,ei,eo,ea,es)=>{let[el,ec]=er.calculateTextureWidthAndHeight(en.dims,eu.TextureType.unpacked),ep=en.dims.length;if(ei<1||eo<1)throw Error("Logical row count N and feature count D must be greater than or equal to 1");if(1!==ea.length||1!==es.length)throw Error("Dimensionality of the intermediate results should be 1");if(ea[0]!==ei||es[0]!==ei)throw Error("Shape of the intermediate results should be equal to logical row count");let ef=`
      float process(int[${ep}] indices) {

      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)
      int offset = coordsToOffset(TexCoords, ${el}, ${ec});

      //determine the logical row for this index
      int logical_row_index[1];
      logical_row_index[0] = offset / ${eo};

      float norm_factor = _Norm(logical_row_index);

      // avoid possible division by 0
      // if norm_facor is 0, all elements are zero
      // if so, return 0
      if(norm_factor == 0.0)
        return 0.0;

      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;
    }`;return Object.assign(Object.assign({},ed),{output:{dims:en.dims,type:en.type,textureType:eu.TextureType.unpacked},shaderSource:ef})},eb=er=>{if(!er||1!==er.length)throw Error("Softmax requires 1 input.");if("float32"!==er[0].type&&"float64"!==er[0].type)throw Error("Invalid input type")}},564:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.parseSplitAttributes=en.split=void 0;let eo=ei(4910),ea=ei(7273),es=ei(5639),eu={name:"Split",inputNames:["A"],inputTypes:[es.TextureType.unpacked]};en.split=(er,en,ei)=>{ep(en);let eo=ea.ShapeUtil.normalizeAxis(ei.axis,en[0].dims.length),es=el(er,en,eo,ei),ed=[];for(let ea=0;ea<es;++ea)ed.push(er.run(Object.assign(Object.assign({},eu),{cacheHint:`${ei.cacheKey};${ea}`,get:()=>ec(er,en[0],ei,eo,ea)}),en));return ed},en.parseSplitAttributes=er=>{let en=er.attributes.getInt("axis",0),ei=er.attributes.getInts("split",[]),ea=er.outputs.length;return(0,eo.createAttributeWithCacheKey)({axis:en,split:ei,numOutputs:ea})};let el=(er,en,ei,eo)=>{let[,es]=ea.SplitUtil.splitShape(en[0].dims,ei,eo.split,eo.numOutputs);return es.length},ec=(er,en,ei,eo,el)=>{let[ec,ep]=ea.SplitUtil.splitShape(en.dims,eo,ei.split,ei.numOutputs),ed=ep[el],ef=ec[el],eh=`
      float process(int indices[${ef.length}]) {
        indices[${eo}] += ${ed};
        return _A(indices);
      }
    `;return Object.assign(Object.assign({},eu),{cacheHint:`${ei.cacheKey}:${el}`,output:{dims:ef,type:en.type,textureType:es.TextureType.unpacked},shaderSource:eh})},ep=er=>{if(!er||1!==er.length)throw Error("Split requires one input.");if("int8"!==er[0].type&&"uint8"!==er[0].type&&"int16"!==er[0].type&&"uint16"!==er[0].type&&"int32"!==er[0].type&&"uint32"!==er[0].type&&"float32"!==er[0].type&&"float64"!==er[0].type&&"bool"!==er[0].type)throw Error("Invalid input type.")}},5416:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.parseSqueezeAttributes=en.squeezeV13=en.squeeze=void 0;let eo=ei(7273);en.squeeze=(er,en,ei)=>{ea(en);let es=eo.ShapeUtil.squeezeShape(en[0].dims,ei);return[er.reshapeUnpacked(en[0],es)]},en.squeezeV13=(er,ei)=>(es(ei),(0,en.squeeze)(er,[ei[0]],Array.from(ei[1].integerData))),en.parseSqueezeAttributes=er=>er.attributes.getInts("axes");let ea=er=>{if(!er||1!==er.length)throw Error("Squeeze requires 1 input.");if("string"===er[0].type)throw Error("invalid input tensor types.")},es=er=>{if(!er||2!==er.length)throw Error("Squeeze requires 2 inputs.");if("int32"!==er[1].type)throw Error("Invalid input type.")}},1240:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.sum=void 0;let eo=ei(6757),ea=ei(5639);en.sum=(er,en)=>{eu(en);let ei={name:"Sum",inputNames:en.map((er,en)=>`X${en}`),inputTypes:Array(en.length).fill(ea.TextureType.unpacked)};return[er.run(Object.assign(Object.assign({},ei),{get:()=>es(er,en,ei)}),en)]};let es=(er,en,ei)=>{let es=(0,eo.getGlsl)(er.session.backend.glContext.version),eu=en[0].dims.slice(),el=`
      void main() {
        vec4 result = ${en.map((er,en)=>`${es.texture2D}(X${en},TexCoords)`).join(" + ")};
        ${es.output} = result;
      }
    `;return Object.assign(Object.assign({},ei),{output:{dims:eu,type:en[0].type,textureType:ea.TextureType.unpacked},hasMain:!0,shaderSource:el})},eu=er=>{if(!er||0===er.length)throw Error("Sum requires inputs.");let en=er[0].dims.length;for(let ei=1;ei<er.length;ei++){if(en!==er[ei].dims.length)throw Error("Input shapes are mismatched.");for(let eo=0;eo<en;eo++)if(er[0].dims[eo]!==er[ei].dims[eo])throw Error("Input shapes are not matched.")}if("float32"!==er[0].type&&"float64"!==er[0].type)throw Error("Invalid input type.");for(let en=1;en<er.length;en++)if(er[0].type!==er[en].type)throw Error("Input types are not matched.")}},5944:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.tile=void 0;let eo=ei(6145),ea=ei(5639);en.tile=(er,en)=>{eu(en);let ei={name:"Tile",inputNames:["A"],inputTypes:[ea.TextureType.unpacked]};return[er.run(Object.assign(Object.assign({},ei),{get:()=>es(er,en,ei)}),en)]};let es=(er,en,ei)=>{let eo=en[0].dims.slice(),es=Array(eo.length),eu=[];for(let er=0;er<eo.length;er++)es[er]=eo[er]*en[1].numberData[er],eu.push(`inputIdx[${er}] = int(mod(float(outputIdx[${er}]), ${eo[er]}.));`);let el=es.length,ec=`
      float process(int outputIdx[${el}]) {
        int inputIdx[${el}];
        ${eu.join("\n")}
        return _A(inputIdx);
      }
    `;return Object.assign(Object.assign({},ei),{output:{dims:es,type:en[0].type,textureType:ea.TextureType.unpacked},shaderSource:ec})},eu=er=>{if(!er||2!==er.length)throw Error("Tile requires 2 input.");if(1!==er[1].dims.length)throw Error("The second input shape must 1 dimension.");if(er[1].dims[0]!==er[0].dims.length)throw Error("Invalid input shape.");if(-1===eo.NUMBER_TYPES.indexOf(er[0].type))throw Error("Invalid input type.");if("int32"!==er[1].type&&"int16"!==er[1].type)throw Error("Invalid repeat type.")}},5707:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.parseTransposeAttributes=en.transpose=void 0;let eo=ei(4910),ea=ei(7273),es=ei(5639),eu={name:"Transpose",inputNames:["A"],inputTypes:[es.TextureType.unpacked]};en.transpose=(er,en,ei)=>(ef(en),[er.run(Object.assign(Object.assign({},eu),{cacheHint:ei.cacheKey,get:()=>el(er,en[0],ei.perm)}),en)]),en.parseTransposeAttributes=er=>(0,eo.createAttributeWithCacheKey)({perm:er.attributes.getInts("perm",[])});let el=(er,en,ei)=>{let eo=en.dims;ei=ec(eo,ei);let ea=ep(eo,ei),el=eo.length,ef=`
      ${ed("perm",ei,el)}
      float process(int indices[${el}]) {
        int a[${el}];
        perm(a, indices);
        return _A(a);
      }`;return Object.assign(Object.assign({},eu),{output:{dims:ea,type:en.type,textureType:es.TextureType.unpacked},shaderSource:ef})},ec=(er,en)=>(en&&en.length!==er.length&&(en=[...er.keys()].reverse()),en),ep=(er,en)=>(en=ec(er,en),ea.ShapeUtil.sortBasedOnPerm(er,en)),ed=(er,en,ei)=>{let eo=[];eo.push(`void ${er}(out int a[${ei}], int src[${ei}]) {`);for(let er=0;er<ei;++er)eo.push(`	a[${en[er]}]=src[${er}];`);return eo.push("	}"),eo.join("\n")},ef=er=>{if(!er||1!==er.length)throw Error("Transpose requires 1 input.");if("float32"!==er[0].type&&"float64"!==er[0].type)throw Error("input should be float tensor")}},2488:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.encodeAsUint8=void 0;let eo=ei(6757),ea=ei(5639);en.encodeAsUint8=(er,en)=>{let ei=en.shape,es=(0,eo.getGlsl)(er.session.backend.glContext.version),eu=`
    const float FLOAT_MAX = 1.70141184e38;
    const float FLOAT_MIN = 1.17549435e-38;

    bool isNaN(float val) {
      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;
    }

    highp vec4 encodeAsUint8(highp float v) {
      if (isNaN(v)) {
        return vec4(255, 255, 255, 255);
      }

      highp float av = abs(v);

      if(av < FLOAT_MIN) {
        return vec4(0.0, 0.0, 0.0, 0.0);
      } else if(v > FLOAT_MAX) {
        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
      } else if(v < -FLOAT_MAX) {
        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
      }

      highp vec4 c = vec4(0,0,0,0);

      highp float e = floor(log2(av));
      highp float m = exp2(fract(log2(av))) - 1.0;

      c[2] = floor(128.0 * m);
      m -= c[2] / 128.0;
      c[1] = floor(32768.0 * m);
      m -= c[1] / 32768.0;
      c[0] = floor(8388608.0 * m);

      highp float ebias = e + 127.0;
      c[3] = floor(ebias / 2.0);
      ebias -= c[3] * 2.0;
      c[2] += floor(ebias) * 128.0;

      c[3] += 128.0 * step(0.0, -v);

      return c / 255.0;
    }

    void main() {
      float value = ${es.texture2D}(X,TexCoords).r;
      ${es.output} = encodeAsUint8(value);
    }`,el={name:"Uint8Encode",inputTypes:[ea.TextureType.unpacked],inputNames:["X"],output:{dims:ei,type:en.tensor.type,textureType:ea.TextureType.downloadUint8AsFloat},shaderSource:eu,hasMain:!0};return er.executeProgram(el,[en.tensor])}},9087:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.tanh=en.tan=en.sqrt=en.sin=en.sigmoid=en.relu=en.not=en.neg=en.log=en.parseLeakyReluAttributes=en.leakyRelu=en.identity=en.floor=en.exp=en.parseEluAttributes=en.elu=en.cos=en.ceil=en.clipV11=en.parseClipAttributes=en.clip=en.atan=en.asin=en.acos=en.abs=en.glslTanh=en.glslTan=en.glslSqrt=en.glslSigmoid=en.glslRelu=en.glslSin=en.glslNot=en.glslNeg=en.glslLog=en.glslLeakyRelu=en.glslIdentity=en.glslClip=en.glslFloor=en.glslExp=en.glslElu=en.glslCos=en.glslCeil=en.glslAtan=en.glslAsin=en.glslAcos=en.glslAbs=void 0;let eo=ei(4910),ea=ei(7273),es=ei(1997),eu=ei(6757),el=ei(5639);function ec(){return eD("abs")}function ep(){return eD("acos")}function ed(){return eD("asin")}function ef(){return eD("atan")}function eh(){return eD("ceil")}function eg(){return eD("cos")}function em(er){let en="elu";return{body:`
  const float alpha = float(${er});

  float ${en}_(float a) {
    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;
  }
  vec4 ${en}_(vec4 v) {
    return vec4(${en}_(v.x), ${en}_(v.y), ${en}_(v.z), ${en}_(v.w));
  }
  `,name:en,type:es.FunctionType.ValueBased}}function eb(){return eD("exp")}function ey(){return eD("floor")}function ev(er,en){let ei="clip";return{body:`
  const float min = float(${er});
  const float max = float(${en});

  float ${ei}_(float a) {
    return clamp(a, min, max);
  }
  vec4 ${ei}_(vec4 v) {
    return clamp(v, min, max);
  }
  `,name:ei,type:es.FunctionType.ValueBased}}function e_(){let er="indentity";return{body:`
  float ${er}_(float a) {
    return a;
  }
  vec4 ${er}_(vec4 v) {
    return v;
  }
  `,name:er,type:es.FunctionType.ValueBased}}function ex(er){let en="leakyRelu";return{body:`
  const float alpha = float(${er});

  float ${en}_(float a) {
    return a < 0.0 ? a * alpha : a;
  }
  vec4 ${en}_(vec4 v) {
    return vec4(${en}_(v.x), ${en}_(v.y), ${en}_(v.z), ${en}_(v.w));
  }
  `,name:en,type:es.FunctionType.ValueBased}}function ew(){return eD("log")}function eT(){let er="neg";return{body:`
  float ${er}_(float a) {
    return -a;
  }
  vec4 ${er}_(vec4 v) {
    return -v;
  }
  `,name:er,type:es.FunctionType.ValueBased}}function eS(){let er="not";return{body:`
  float ${er}_(float a) {
    return float( ! bool(a) );
  }
  bool ${er}_(bool a) {
    return !a;
  }
  vec4 ${er}_(vec4 v) {
    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));
  }
  bvec4 ${er}_(bvec4 v) {
    return bvec4(!v.x, !v.y, !v.z, !v.w);
  }
  `,name:er,type:es.FunctionType.ValueBased}}function eO(){return eD("sin")}function eA(){let er="relu";return{body:`
  float ${er}_(float a) {
    return max( a, 0.0 );
  }
  vec4 ${er}_(vec4 v) {
    return max( v, 0.0 );
  }
  `,name:er,type:es.FunctionType.ValueBased}}function eE(){let er="sigmoid";return{body:`
  float ${er}_(float a) {
    return 1.0 / (1.0 + exp(-a));
  }
  vec4 ${er}_(vec4 v) {
    return 1.0 / (1.0 + exp(-v));
  }
  `,name:er,type:es.FunctionType.ValueBased}}function eI(){return eD("sqrt")}function e$(){return eD("tan")}function eP(){let er="tanh";return{body:`
  float ${er}_(float a) {
    a = clamp(a, -10., 10.);
    a = exp(2.*a);
    return (a - 1.) / (a + 1.);
  }
  vec4 ${er}_(vec4 v) {
    v = clamp(v, -10., 10.);
    v = exp(2.*v);
    return (v - 1.) / (v + 1.);
  }
  `,name:er,type:es.FunctionType.ValueBased}}function eD(er){return{body:`
  float ${er}_(float a) {
    return ${er}(a);
  }
  vec4 ${er}_(vec4 v) {
    return ${er}(v);
  }
  `,name:er,type:es.FunctionType.ValueBased}}en.glslAbs=ec,en.glslAcos=ep,en.glslAsin=ed,en.glslAtan=ef,en.glslCeil=eh,en.glslCos=eg,en.glslElu=em,en.glslExp=eb,en.glslFloor=ey,en.glslClip=ev,en.glslIdentity=e_,en.glslLeakyRelu=ex,en.glslLog=ew,en.glslNeg=eT,en.glslNot=eS,en.glslSin=eO,en.glslRelu=eA,en.glslSigmoid=eE,en.glslSqrt=eI,en.glslTan=e$,en.glslTanh=eP;let ek=(er,en,ei,eo)=>{let ea=er.session.pack?el.TextureType.packed:el.TextureType.unpacked,es={name:ei.name,inputTypes:[ea],inputNames:["A"],cacheHint:eo};return Object.assign(Object.assign({},es),{get:()=>((er,en,ei,eo)=>{let ea=er.session.pack?el.TextureType.packed:el.TextureType.unpacked,es=(0,eu.getGlsl)(er.session.backend.glContext.version);return Object.assign(Object.assign({},en),{output:{dims:ei.dims,type:ei.type,textureType:ea},shaderSource:`
     ${eo.body}
     void main() {
       vec4 v = ${es.texture2D}(A, TexCoords);
       v = ${eo.name}_(v);
       ${es.output} = v;
     }
     `,hasMain:!0})})(er,es,en,ei)})};en.abs=(er,en)=>[er.run(ek(er,en[0],ec()),en)],en.acos=(er,en)=>[er.run(ek(er,en[0],ep()),en)],en.asin=(er,en)=>[er.run(ek(er,en[0],ed()),en)],en.atan=(er,en)=>[er.run(ek(er,en[0],ef()),en)],en.clip=(er,en,ei)=>[er.run(ek(er,en[0],ev(ei.min,ei.max),ei.cacheKey),en)],en.parseClipAttributes=er=>(0,eo.createAttributeWithCacheKey)({min:er.attributes.getFloat("min",ea.MIN_CLIP),max:er.attributes.getFloat("max",ea.MAX_CLIP)}),en.clipV11=(er,ei)=>{let eo=eC(er,ei);return(0,en.clip)(er,[ei[0]],eo)};let eC=(er,en)=>{if(en.length>=3&&(!er.session.isInitializer(en[1].dataId)||!er.session.isInitializer(en[2].dataId)))throw Error("dynamic clip attributes are not allowed");let ei=en.length>=3?en[1].numberData[0]:ea.MIN_CLIP,es=en.length>=3?en[2].numberData[0]:ea.MAX_CLIP;return(0,eo.createAttributeWithCacheKey)({min:ei,max:es})};en.ceil=(er,en)=>[er.run(ek(er,en[0],eh()),en)],en.cos=(er,en)=>[er.run(ek(er,en[0],eg()),en)],en.elu=(er,en,ei)=>[er.run(ek(er,en[0],em(ei.alpha),ei.cacheKey),en)],en.parseEluAttributes=er=>(0,eo.createAttributeWithCacheKey)({alpha:er.attributes.getFloat("alpha",1)}),en.exp=(er,en)=>[er.run(ek(er,en[0],eb()),en)],en.floor=(er,en)=>[er.run(ek(er,en[0],ey()),en)],en.identity=(er,en)=>[er.run(ek(er,en[0],e_()),en)],en.leakyRelu=(er,en,ei)=>[er.run(ek(er,en[0],ex(ei.alpha),ei.cacheKey),en)],en.parseLeakyReluAttributes=er=>(0,eo.createAttributeWithCacheKey)({alpha:er.attributes.getFloat("alpha",.01)}),en.log=(er,en)=>[er.run(ek(er,en[0],ew()),en)],en.neg=(er,en)=>[er.run(ek(er,en[0],eT()),en)],en.not=(er,en)=>[er.run(ek(er,en[0],eS()),en)],en.relu=(er,en)=>[er.run(ek(er,en[0],eA()),en)],en.sigmoid=(er,en)=>[er.run(ek(er,en[0],eE()),en)],en.sin=(er,en)=>[er.run(ek(er,en[0],eO()),en)],en.sqrt=(er,en)=>[er.run(ek(er,en[0],eI()),en)],en.tan=(er,en)=>[er.run(ek(er,en[0],e$()),en)],en.tanh=(er,en)=>[er.run(ek(er,en[0],eP()),en)]},540:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.createUnpackProgramInfoLoader=en.createUnpackProgramInfo=void 0;let eo=ei(6757),ea=ei(5639),es=ei(432),eu=ei(5614),el={name:"unpack",inputNames:["A"],inputTypes:[ea.TextureType.packed]};en.createUnpackProgramInfo=(er,en)=>{let ei=en.dims.length,ec=(0,eu.getChannels)("rc",ei),ep=ec.slice(-2),ed=(0,es.getCoordsDataType)(ei),ef=(0,eu.unpackFromChannel)(),eh=0===en.dims.length?"":function(er,en){if(1===er)return"rc";let ei="";for(let eo=0;eo<er;eo++)ei+=en[eo],eo<er-1&&(ei+=",");return ei}(ei,ec),eg=ei<=1?"rc":`vec2(${ep.join(",")})`,em=`
    ${ef}
    void main() {
      ${ed} rc = getOutputCoords();

       // Sample the texture with the coords to get the rgba channel value.
       vec4 packedInput = getA(${eh});

       ${(0,eo.getGlsl)(er.session.backend.glContext.version).output} = vec4(getChannel(packedInput, ${eg}), 0, 0, 0);
     }
   `;return Object.assign(Object.assign({},el),{hasMain:!0,output:{dims:en.dims,type:en.type,textureType:ea.TextureType.unpacked},shaderSource:em})},en.createUnpackProgramInfoLoader=(er,ei)=>Object.assign(Object.assign({},el),{get:()=>(0,en.createUnpackProgramInfo)(er,ei)})},7862:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.parseUnsqueezeAttributes=en.unsqueezeV13=en.unsqueeze=void 0;let eo=ei(7273);en.unsqueeze=(er,en,ei)=>{ea(en);let es=eo.ShapeUtil.unsqueezeShape(en[0].dims,ei);return[er.reshapeUnpacked(en[0],es)]},en.unsqueezeV13=(er,ei)=>(es(ei),(0,en.unsqueeze)(er,[ei[0]],Array.from(ei[1].integerData))),en.parseUnsqueezeAttributes=er=>er.attributes.getInts("axes");let ea=er=>{if(!er||1!==er.length)throw Error("Unsqueeze requires 1 input.");if("string"===er[0].type)throw Error("invalid input tensor types.")},es=er=>{if(!er||2!==er.length)throw Error("Unsqueeze requires 2 inputs.");if("int32"!==er[1].type)throw Error("Invalid input type.")}},3980:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.scalesValidation=en.validateInputs=en.parseUpsampleAttributes=en.parseUpsampleAttributesV9=en.parseUpsampleAttributesV7=en.upsample=void 0;let eo=ei(4910),ea=ei(6757),es=ei(5639),eu={name:"Upsample",inputNames:["X"],inputTypes:[es.TextureType.unpacked]};en.upsample=(er,ei,eo)=>((0,en.validateInputs)(ei,eo),[er.run(Object.assign(Object.assign({},eu),{cacheHint:eo.cacheKey,get:()=>el(er,ei,eo)}),ei)]),en.parseUpsampleAttributesV7=er=>(0,en.parseUpsampleAttributes)(er,7),en.parseUpsampleAttributesV9=er=>(0,en.parseUpsampleAttributes)(er,9),en.parseUpsampleAttributes=(er,ei)=>{let ea=ei>=10,es=er.attributes.getString("mode","nearest");if("nearest"!==es&&"linear"!==es&&(ei<11||"cubic"!==es))throw Error(`unrecognized mode: ${es}`);let eu=[];ei<9&&(eu=er.attributes.getFloats("scales"),(0,en.scalesValidation)(eu,es,ea));let el=er.attributes.getFloat("extrapolation_value",0),ec=ei>10?er.attributes.getString("coordinate_transformation_mode","half_pixel"):"asymmetric";if(-1===["asymmetric","pytorch_half_pixel","tf_half_pixel_for_nn","align_corners","tf_crop_and_resize","half_pixel"].indexOf(ec))throw Error(`coordinate_transform_mode '${ec}' is not supported`);let ep="tf_crop_and_resize"===ec,ed=ep,ef="nearest"===es&&ei>=11?er.attributes.getString("nearest_mode","round_prefer_floor"):"";if(-1===["round_prefer_floor","round_prefer_ceil","floor","ceil",""].indexOf(ef))throw Error(`nearest_mode '${ef}' is not supported`);let eh=er.attributes.getFloat("cubic_coeff_a",-.75),eg=0!==er.attributes.getInt("exclude_outside",0);if(eg&&"cubic"!==es)throw Error("exclude_outside can be set to 1 only when mode is CUBIC.");let em=ei<11||"nearest"===es&&"asymmetric"===ec&&"floor"===ef,eb=0,ey=0,ev=0;return ei>10?er.inputs.length>2?(eb=1,ey=2,ev=3):(ey=1,ev=2):9===ei&&(ey=1),(0,eo.createAttributeWithCacheKey)({opset:ei,isResize:ea,mode:es,scales:eu,extrapolationValue:el,coordinateTransformMode:ec,useExtrapolation:ed,needRoiInput:ep,nearestMode:ef,cubicCoefficientA:eh,excludeOutside:eg,useNearest2xOptimization:em,roiInputIdx:eb,scalesInputIdx:ey,sizesInputIdx:ev})};let el=(er,en,ei)=>{let eo=(0,ea.getGlsl)(er.session.backend.glContext.version),[el,ec]=er.calculateTextureWidthAndHeight(en[0].dims,es.TextureType.unpacked),ep=en[0].dims.map((er,en)=>Math.floor(er*ei.scales[en])),[ed,ef]=er.calculateTextureWidthAndHeight(ep,es.TextureType.unpacked),eh=ep.length,eg=Array(eh),em=Array(eh),eb=`
      int output_pitches[${eh}];
      int input_pitches[${eh}];
      `;for(let er=eh-1;er>=0;er--)eg[er]=er===eh-1?1:eg[er+1]*ep[er+1],em[er]=er===eh-1?1:em[er+1]*en[0].dims[er+1],eb+=`
        output_pitches[${er}] = ${eg[er]};
        input_pitches[${er}] = ${em[er]};
        `;let ey=`
      float getInputFloat(int index) {
        vec2 coords = offsetToCoords(index, ${el}, ${ec});
        float value = getColorAsFloat(${eo.texture2D}(X, coords));
        return value;
      }
      `,ev="nearest"===ei.mode?`
    ${ey}
    float process(int indices[${eh}]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${ed}, ${ef});

      ${eb}

      int d, m;
      for (int dim = 0; dim < ${eh}; ++dim) {
        d = output_index / output_pitches[dim];
        m = output_index - d * output_pitches[dim];
        output_index = m;

        if (scales[dim] != 1 && d > 0) {
          int d2 = d / scales[dim];
          m = d - d2 * scales[dim];
          d = d2;
        }
        input_index += input_pitches[dim] * d;
      }

      return getInputFloat(input_index);
    }`:4===eh?`
    ${ey}
    float process(int indices[4]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${ed}, ${ef});

      ${eb}

      int m;
      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m / output_pitches[1];
      m = m - index_of_dim1 * output_pitches[1];
      index_of_dim2 = m / output_pitches[2];
      m = m - index_of_dim2 * output_pitches[2];
      index_of_dim3 = m;

      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;
      index_of_input_dim2 = index_of_dim2 / scales[2];
      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];
      index_of_input_dim3 = index_of_dim3 / scales[3];
      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];

      input_index = index_of_dim0 * input_pitches[0] +
            index_of_dim1 * input_pitches[1] +
            index_of_input_dim2 * input_pitches[2] +
            index_of_input_dim3;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim2 = false;
      if (index_of_input_dim2 == (${en[0].dims[2]} - 1)) {
        // It's the end in dimension 2
        x01 = x00;
        end_of_dim2 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[2]);
      }

      if (index_of_input_dim3 == (input_pitches[2] - 1)) {
        // It's the end in dimension 3
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);
    }`:`
    ${ey}
    float process(int indices[2]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${ed}, ${ef});

      ${eb}

      int m;
      int index_of_dim0, index_of_dim1;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m;

      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;
      index_of_input_dim0 = index_of_dim0 / scales[0];
      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];
      index_of_input_dim1 = index_of_dim1 / scales[1];
      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];

      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim0 = false;
      if (index_of_input_dim0 == (${en[0].dims[0]} - 1)) {
        // It's the end in dimension 0
        x01 = x00;
        end_of_dim0 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[0]);
      }

      if (index_of_input_dim1 == (input_pitches[0] - 1)) {
        // It's the end in dimension 1
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);
    }`;return Object.assign(Object.assign({},eu),{output:{dims:ep,type:en[0].type,textureType:es.TextureType.unpacked},shaderSource:ev,variables:[{name:"scales",type:"int",arrayLength:ei.scales.length,data:ei.scales.map(er=>Math.ceil(er))}]})};en.validateInputs=(er,en)=>{if(!er||en.opset<9&&1!==er.length||en.opset>=9&&en.opset<11&&2!==er.length||en.opset>=11&&er.length<2)throw Error("invalid inputs.");if(en.scales.length>0&&er[0].dims.length!==en.scales.length)throw Error("Invalid input shape.");if("string"===er[0].type)throw Error("Invalid input tensor types.")},en.scalesValidation=(er,en,ei)=>{if(ei){for(let en of er)if(en<=0)throw Error("Scale value should be greater than 0.")}else for(let en of er)if(en<1)throw Error("Scale value should be greater than or equal to 1.");if(!("linear"!==en&&"cubic"!==en||2===er.length||4===er.length&&1===er[0]&&1===er[1]))throw Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic')         or 4-D inputs with the corresponding outermost 2 scale values being 1         in the ${ei?"Resize":"Upsample"} opeartor.`)}},2757:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.ProgramManager=void 0;let eo=ei(8453),ea=ei(1315),es=ei(8897),eu=ei(6757);en.ProgramManager=class{constructor(er,en,ei){this.profiler=er,this.glContext=en,this.textureLayoutStrategy=ei,this.repo=new Map,this.attributesBound=!1}getArtifact(er){return this.repo.get(er)}setArtifact(er,en){this.repo.set(er,en)}run(er,en,ei){var eo;this.profiler.event("op",`ProgramManager.run ${null!==(eo=er.programInfo.name)&&void 0!==eo?eo:"unknown kernel"}`,()=>{var eo;let es=this.glContext.gl,eu=er.program;es.useProgram(eu);try{this.bindOutput(ei),this.attributesBound||this.bindAttributes(er.attribLocations),this.bindUniforms(er.uniformLocations,null!==(eo=er.programInfo.variables)&&void 0!==eo?eo:[],en)}catch(en){throw ea.Logger.error("ProgramManager",er.programInfo.shaderSource),en}this.profiler.event("backend","GlContext.draw()",()=>{this.glContext.draw()})},this.glContext)}dispose(){this.vertexShader&&this.glContext.deleteShader(this.vertexShader),this.repo.forEach(er=>this.glContext.deleteProgram(er.program))}build(er,en,ei){return this.profiler.event("backend","ProgramManager.build",()=>{let eo=new es.GlslPreprocessor(this.glContext,er,en,ei),ea=eo.preprocess(),eu=this.compile(ea);return{programInfo:er,program:eu,uniformLocations:this.getUniformLocations(eu,eo.context.programInfo.inputNames,eo.context.programInfo.variables),attribLocations:this.getAttribLocations(eu)}})}compile(er){if(!this.vertexShader){ea.Logger.verbose("ProrgramManager","Compiling and caching Vertex shader for the first time");let er=(0,eu.getVertexShaderSource)(this.glContext.version);this.vertexShader=this.glContext.compileShader(er,this.glContext.gl.VERTEX_SHADER)}eo.env.debug&&ea.Logger.verbose("ProrgramManager",`FragShader:
${er}
`);let en=this.glContext.compileShader(er,this.glContext.gl.FRAGMENT_SHADER),ei=this.glContext.createProgram(this.vertexShader,en);return this.glContext.deleteShader(en),ei}bindOutput(er){let en=er.width,ei=er.height;ea.Logger.verbose("ProrgramManager",`Binding output texture to Framebuffer: w/h=${en}/${ei}, shape=${er.shape}, type=${er.tensor.type}`),this.glContext.attachFramebuffer(er.texture,en,ei)}bindAttributes(er){let en=er.position,ei=er.textureCoord;this.glContext.setVertexAttributes(en,ei),this.attributesBound=!0}bindUniforms(er,en,ei){var eo;let ea=this.glContext.gl,es=0;for(let{name:eu,type:el,location:ec,arrayLength:ep}of er){let er=null===(eo=en.find(er=>er.name===eu))||void 0===eo?void 0:eo.data;if("sampler2D"!==el&&!er)throw Error(`variable '${eu}' does not have data defined in program info`);switch(el){case"sampler2D":this.bindTexture(ei[es],ec,es),es++;break;case"float":ep?ea.uniform1fv(ec,er):ea.uniform1f(ec,er);break;case"int":ep?ea.uniform1iv(ec,er):ea.uniform1i(ec,er);break;default:throw Error(`Uniform not implemented: ${el}`)}}}bindTexture(er,en,ei){this.glContext.bindTextureToUniform(er.texture,ei,en)}getAttribLocations(er){return{position:this.getAttribLocation(er,"position"),textureCoord:this.getAttribLocation(er,"textureCoord")}}getUniformLocations(er,en,ei){let eo=[];if(en)for(let ei of en)eo.push({name:ei,type:"sampler2D",location:this.getUniformLocation(er,ei)});if(ei)for(let en of ei)eo.push(Object.assign(Object.assign({},en),{location:this.getUniformLocation(er,en.name)}));return eo}getUniformLocation(er,en){let ei=this.glContext.gl.getUniformLocation(er,en);if(null===ei)throw Error(`Uniform ${en} not found.`);return ei}getAttribLocation(er,en){return this.glContext.gl.getAttribLocation(er,en)}}},2171:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.WebGLSessionHandler=void 0;let eo=ei(1315),ea=ei(5881),es=ei(7860),eu=ei(4110),el=ei(2757),ec=ei(7618),ep=ei(5243);en.WebGLSessionHandler=class{constructor(er,en){this.backend=er,this.context=en,this.layoutStrategy=new ec.PreferLogicalStrategy(er.glContext.maxTextureSize),this.programManager=new el.ProgramManager(this.context.profiler,er.glContext,this.layoutStrategy),this.textureManager=new ep.TextureManager(er.glContext,this.layoutStrategy,this.context.profiler,{reuseTextures:"full"===er.textureCacheMode}),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map,this.pack=er.pack,this.pack2unpackMap=new Map,this.unpack2packMap=new Map}createInferenceHandler(){return new es.WebGLInferenceHandler(this)}onGraphInitialized(er){let en=er.getValues().filter(er=>-1===er.from&&er.tensor).map(er=>er.tensor.dataId);this.initializers=new Set(en)}isInitializer(er){return!!this.initializers&&this.initializers.has(er)}addInitializer(er){this.initializers.add(er)}getTextureData(er,en){return en?this.packedTextureDataCache.get(er):this.unpackedTextureDataCache.get(er)}setTextureData(er,en,ei=!1){eo.Logger.verbose("WebGLSessionHandler","Storing Texture data in cache"),ei?this.packedTextureDataCache.set(er,en):this.unpackedTextureDataCache.set(er,en)}dispose(){this.programManager.dispose(),this.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach(er=>this.textureManager.releaseTexture(er,!0)),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach(er=>this.textureManager.releaseTexture(er,!0)),this.unpackedTextureDataCache=new Map}resolve(er,en,ei){let eo=(0,ea.resolveOperator)(er,en,eu.WEBGL_OP_RESOLVE_RULES);return{impl:eo.opImpl,context:eo.opInit?eo.opInit(er,ei):er}}}},9622:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.Uint8DataEncoder=en.RGBAFloatDataEncoder=en.RedFloat32DataEncoder=void 0;let eo=ei(1315);en.RedFloat32DataEncoder=class{constructor(er,en=1){if(1===en)this.internalFormat=er.R32F,this.format=er.RED,this.textureType=er.FLOAT,this.channelSize=en;else{if(4!==en)throw Error(`Invalid number of channels: ${en}`);this.internalFormat=er.RGBA32F,this.format=er.RGBA,this.textureType=er.FLOAT,this.channelSize=en}}encode(er,en){let ei,ea;return er.constructor!==Float32Array&&(eo.Logger.warning("Encoder","data was not of type Float32; creating new Float32Array"),ea=new Float32Array(er)),en*this.channelSize>er.length?(eo.Logger.warning("Encoder","Source data too small. Allocating larger array"),ea=er,ei=this.allocate(en*this.channelSize),ea.forEach((er,en)=>ei[en]=er)):ei=ea=er,ei}allocate(er){return new Float32Array(4*er)}decode(er,en){return 1===this.channelSize?er.filter((er,en)=>en%4==0).subarray(0,en):er.subarray(0,en)}},en.RGBAFloatDataEncoder=class{constructor(er,en=1,ei){if(1!==en&&4!==en)throw Error(`Invalid number of channels: ${en}`);this.internalFormat=er.RGBA,this.format=er.RGBA,this.channelSize=en,this.textureType=ei||er.FLOAT}encode(er,en){let ei=er;return 1===this.channelSize&&(eo.Logger.verbose("Encoder","Exploding into a larger array"),ei=this.allocate(en),er.forEach((er,en)=>ei[4*en]=er)),ei}allocate(er){return new Float32Array(4*er)}decode(er,en){return 1===this.channelSize?er.filter((er,en)=>en%4==0).subarray(0,en):er.subarray(0,en)}},en.Uint8DataEncoder=class{constructor(er,en=1){if(this.channelSize=4,1===en)this.internalFormat=er.ALPHA,this.format=er.ALPHA,this.textureType=er.UNSIGNED_BYTE,this.channelSize=en;else{if(4!==en)throw Error(`Invalid number of channels: ${en}`);this.internalFormat=er.RGBA,this.format=er.RGBA,this.textureType=er.UNSIGNED_BYTE,this.channelSize=en}}encode(er,en){return new Uint8Array(er.buffer,er.byteOffset,er.byteLength)}allocate(er){return new Uint8Array(er*this.channelSize)}decode(er,en){if(er instanceof Uint8Array)return er.subarray(0,en);throw Error(`Invalid array type: ${er.constructor}`)}}},7618:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.getBatchDim=en.sizeToSquarishShape=en.getRowsCols=en.sizeFromShape=en.isInt=en.parseAxisParam=en.squeezeShape=en.PreferLogicalStrategy=en.AlwaysKeepOriginalSizeStrategy=void 0;let eo=ei(1315),ea=ei(7273);function es(er,en){let ei=[],eo=[],ea=null!=en&&Array.isArray(en)&&0===en.length,es=null==en||ea?null:eu(en,er).sort(),el=0;for(let en=0;en<er.length;++en){if(null!=es){if(es[el]===en&&1!==er[en])throw Error(`Can't squeeze axis ${en} since its dim '${er[en]}' is not 1`);(null==es[el]||es[el]>en)&&1===er[en]&&(ei.push(er[en]),eo.push(en)),es[el]<=en&&el++}1!==er[en]&&(ei.push(er[en]),eo.push(en))}return{newShape:ei,keptDims:eo}}function eu(er,en){let ei=en.length;return er=null==er?en.map((er,en)=>en):[].concat(er),(0,ea.assert)(er.every(er=>er>=-ei&&er<ei),()=>`All values in axis param must be in range [-${ei}, ${ei}) but got axis ${er}`),(0,ea.assert)(er.every(el),()=>`All values in axis param must be integers but got axis ${er}`),er.map(er=>er<0?ei+er:er)}function el(er){return er%1==0}function ec(er){if(0===er.length)return 1;let en=er[0];for(let ei=1;ei<er.length;ei++)en*=er[ei];return en}function ep(er){let en=Math.ceil(Math.sqrt(er));return[en,Math.ceil(er/en)]}en.AlwaysKeepOriginalSizeStrategy=class{constructor(er){this.maxTextureSize=er}computeTextureWH(er,en){if(0===er.length)return[1,1];let ei=this.maxTextureSize;if(en&&void 0!==en.breakAxis){let ea=en.breakAxis>=er.length?1:er.slice(en.breakAxis).reduce((er,en)=>er*en),es=en.breakAxis<=0?1:er.slice(0,en.breakAxis).reduce((er,en)=>er*en);if(!(ea>ei||es>ei))return[ea,es];eo.Logger.verbose("TextureLayout",`Given width/height preferences were unattainable: shape:${er}, breakAxis:${en.breakAxis}`)}let ea=er.reduce((er,en)=>er*en),es=Math.floor(Math.sqrt(ea));for(;es<ei&&es<ea&&ea%es!=0;es++);if(es>=ei||ea%es!=0)throw Error(`The given dimensions are outside this GPU's boundaries: ${er}`);return[es,ea/es]}},en.PreferLogicalStrategy=class{constructor(er){this.maxTextureSize=er}computeTextureWH(er,en){let ei=this.computeTexture(er,en);return en&&en.isPacked&&(ei[0]/=2,ei[1]/=2),en&&en.reverseWH?[ei[1],ei[0]]:ei}computeTexture(er,en){let ei=en&&en.isPacked;if(0===er.length)return ei?[2,2]:[1,1];let ea=this.maxTextureSize;if(en&&void 0!==en.breakAxis){let ei=en.breakAxis>=er.length?1:er.slice(en.breakAxis).reduce((er,en)=>er*en),es=en.breakAxis<=0?1:er.slice(0,en.breakAxis).reduce((er,en)=>er*en);if(!(ei>ea||es>ea))return[ei,es];eo.Logger.verbose("TextureLayout",`Given width/height preferences were unattainable: shape:${er}, breakAxis:${en.breakAxis}`)}let eu=er.slice(0);if(ei&&(ea*=2,1===(eu=eu.map((er,en)=>en>=eu.length-2?eu[en]%2==0?eu[en]:eu[en]+1:eu[en])).length&&(eu=[2,eu[0]])),2!==eu.length){let er=es(eu);eu=er.newShape}let el=ec(eu);return eu.length<=1&&el<=ea?[1,el]:2===eu.length&&eu[0]<=ea&&eu[1]<=ea?eu:3===eu.length&&eu[0]*eu[1]<=ea&&eu[2]<=ea?[eu[0]*eu[1],eu[2]]:3===eu.length&&eu[0]<=ea&&eu[1]*eu[2]<=ea?[eu[0],eu[1]*eu[2]]:4===eu.length&&eu[0]*eu[1]*eu[2]<=ea&&eu[3]<=ea?[eu[0]*eu[1]*eu[2],eu[3]]:4===eu.length&&eu[0]<=ea&&eu[1]*eu[2]*eu[3]<=ea?[eu[0],eu[1]*eu[2]*eu[3]]:ei?ep(el/4).map(er=>2*er):ep(el)}},en.squeezeShape=es,en.parseAxisParam=eu,en.isInt=el,en.sizeFromShape=ec,en.getRowsCols=function(er){if(0===er.length)throw Error("Cannot get rows and columns of an empty shape array.");return[er.length>1?er[er.length-2]:1,er[er.length-1]]},en.sizeToSquarishShape=ep,en.getBatchDim=function(er,en=2){return ec(er.slice(0,er.length-en))}},3314:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.createTextureLayoutFromShape=en.calculateTextureWidthAndHeight=en.createTextureLayoutFromTextureType=void 0;let eo=ei(7273),ea=ei(5639);en.createTextureLayoutFromTextureType=(er,ei,eo)=>{let es=eo===ea.TextureType.unpacked||eo===ea.TextureType.unpackedReversed?1:4,eu=eo===ea.TextureType.packed,el=eo===ea.TextureType.unpackedReversed||eo===ea.TextureType.packed,ec=eo===ea.TextureType.packedLastDimension?ei.length-1:void 0,ep=eo===ea.TextureType.packedLastDimension?ei.map((er,en)=>en===ei.length-1?4*er:er):void 0;return(0,en.createTextureLayoutFromShape)(er,ei,es,ep,{isPacked:eu,reverseWH:el,breakAxis:ec})},en.calculateTextureWidthAndHeight=(er,ei,eo)=>{let ea=(0,en.createTextureLayoutFromTextureType)(er,ei,eo);return[ea.width,ea.height]},en.createTextureLayoutFromShape=(er,en,ei=1,ea,es)=>{let eu=!(!es||!es.isPacked),[el,ec]=er.computeTextureWH(eu&&ea||en,es),ep=en.length,ed=en.slice(0);if(0===ep&&(ed=[1]),1===ei)ea=en;else if(eu){if(4!==ei)throw Error("a packed texture must be 4-channel");ea=en,ep>0&&(ed[ep-1]=Math.ceil(ed[ep-1]/2)),ep>1&&(ed[ep-2]=Math.ceil(ed[ep-2]/2))}else if(!ea)throw Error("Unpacked shape is needed when using channels > 1");return{width:el,height:ec,channels:ei,isPacked:eu,shape:ed,strides:eo.ShapeUtil.computeStrides(ed),unpackedShape:ea,reversedWH:es&&es.reverseWH}}},5243:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.TextureManager=void 0;let eo=ei(1315);en.TextureManager=class{constructor(er,en,ei,eo){this.glContext=er,this.layoutStrategy=en,this.profiler=ei,this.config=eo,this.pendingRead=new Map,eo.reuseTextures&&(this.inUseTextures=new Map,this.idleTextures=new Map,this.textureLookup=new Map)}createTextureFromLayout(er,en,ei,ea){let es,eu;let el=this.toEncoderType(er),ec=this.glContext.getEncoder(el,en.channels||1,ea);if(en.isPacked&&1===ea)throw Error("not implemented");let ep=en.width,ed=en.height;if(this.config.reuseTextures){es=`${ep}x${ed}_${ec.format}_${ec.internalFormat}_${ec.textureType}`,(eu=this.inUseTextures.get(es))||(eu=[],this.inUseTextures.set(es,eu));let en=this.idleTextures.get(es);if(en&&en.length>0){let eo=en.pop();return eu.push(eo),1===ea&&this.glContext.updateTexture(eo,ep,ed,ec,this.toTextureData(er,ei)),eo}}eo.Logger.verbose("TextureManager",`Creating new texture of size ${en.width}x${en.height}`);let ef=this.glContext.allocateTexture(ep,ed,ec,this.toTextureData(er,ei));return this.config.reuseTextures&&(eu.push(ef),this.textureLookup.set(ef,es)),ef}readTexture(er,en,ei){return ei||(ei=1),this.profiler.event("backend","TextureManager.readTexture",()=>{let eo=er.shape.reduce((er,en)=>er*en)*ei,ea=this.glContext.readTexture(er.texture,er.width,er.height,eo,this.toEncoderType(en),ei);return this.toTensorData(en,ea)})}async readTextureAsync(er,en,ei){let eo=er.tensor.dataId;if(ei||(ei=1),this.pendingRead.has(eo)){let er=this.pendingRead.get(eo);return new Promise(en=>null==er?void 0:er.push(en))}return this.profiler.event("backend","TextureManager.readTextureAsync",async()=>{this.pendingRead.set(eo,[]);let ea=er.shape.reduce((er,en)=>er*en)*ei;await this.glContext.createAndWaitForFence();let es=this.glContext.readTexture(er.texture,er.width,er.height,ea,this.toEncoderType(en),ei),eu=this.toTensorData(en,es),el=this.pendingRead.get(eo);return this.pendingRead.delete(eo),null==el||el.forEach(er=>er(eu)),eu})}readUint8TextureAsFloat(er){return this.profiler.event("backend","TextureManager.readUint8TextureAsFloat",()=>{let en=er.shape.reduce((er,en)=>er*en),ei=this.glContext.readTexture(er.texture,er.width,er.height,4*en,"byte",4);return new Float32Array(ei.buffer,ei.byteOffset,en)})}releaseTexture(er,en){let ei;if(this.config.reuseTextures&&(ei=this.textureLookup.get(er.texture))){en&&this.textureLookup.delete(ei);let eo=this.inUseTextures.get(ei);if(eo){let en=eo.indexOf(er.texture);if(-1!==en){eo.splice(en,1);let ea=this.idleTextures.get(ei);ea||(ea=[],this.idleTextures.set(ei,ea)),ea.push(er.texture)}}}ei&&!en||(eo.Logger.verbose("TextureManager",`Deleting texture of size ${er.width}x${er.height}`),this.glContext.deleteTexture(er.texture))}toTensorData(er,en){switch(er){case"int16":return en instanceof Int16Array?en:Int16Array.from(en);case"int32":return en instanceof Int32Array?en:Int32Array.from(en);case"int8":return en instanceof Int8Array?en:Int8Array.from(en);case"uint16":return en instanceof Uint16Array?en:Uint16Array.from(en);case"uint32":return en instanceof Uint32Array?en:Uint32Array.from(en);case"uint8":case"bool":return en instanceof Uint8Array?en:Uint8Array.from(en);case"float32":return en instanceof Float32Array?en:Float32Array.from(en);case"float64":return en instanceof Float64Array?en:Float64Array.from(en);default:throw Error(`TensorData type ${er} is not supported`)}}toTextureData(er,en){if(en)return en instanceof Float32Array?en:new Float32Array(en)}toEncoderType(er){return"float"}clearActiveTextures(){this.glContext.clearActiveTextures()}}},5639:(er,en)=>{"use strict";var ei;Object.defineProperty(en,"__esModule",{value:!0}),en.TextureType=void 0,(ei=en.TextureType||(en.TextureType={}))[ei.unpacked=0]="unpacked",ei[ei.unpackedReversed=1]="unpackedReversed",ei[ei.packed=2]="packed",ei[ei.downloadUint8AsFloat=3]="downloadUint8AsFloat",ei[ei.packedLastDimension=4]="packedLastDimension"},432:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.getGlChannels=en.getCoordsDataType=en.getSqueezedParams=en.squeezeInputShape=en.generateShaderFuncNameFromInputSamplerNameAtOutCoords=en.generateShaderFuncNameFromInputSamplerName=en.repeatedTry=en.getPackedShape=void 0;let eo=ei(7273);en.getPackedShape=function(er){let en=er.length;return er.slice(0,en-1).concat(er[en-1]/4)},en.repeatedTry=async function(er,en=er=>0,ei){return new Promise((eo,ea)=>{let es=0,eu=()=>{if(er())return void eo();es++;let el=en(es);null!=ei&&es>=ei?ea():setTimeout(eu,el)};eu()})},en.generateShaderFuncNameFromInputSamplerName=function(er){return(0,eo.assert)(void 0!==er&&0!==er.length,()=>"empty string found for sampler name"),"get"+er.charAt(0).toUpperCase()+er.slice(1)},en.generateShaderFuncNameFromInputSamplerNameAtOutCoords=function(er){return(0,eo.assert)(void 0!==er&&0!==er.length,()=>"empty string found for sampler name"),"get"+er.charAt(0).toUpperCase()+er.slice(1)+"AtOutCoords"},en.squeezeInputShape=function(er,en){return JSON.parse(JSON.stringify(er)),en},en.getSqueezedParams=function(er,en){return en.map(en=>er[en]).join(", ")},en.getCoordsDataType=function(er){if(er<=1)return"int";if(2===er)return"ivec2";if(3===er)return"ivec3";if(4===er)return"ivec4";if(5===er)return"ivec5";if(6===er)return"ivec6";throw Error(`GPU for rank ${er} is not yet supported`)},en.getGlChannels=function(er=6){return["x","y","z","w","u","v"].slice(0,er)}},3389:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.createNewWebGLContext=en.createWebGLContext=void 0;let eo=ei(1315),ea=ei(3524),es={};function eu(er){let en;let ei=function(){if("undefined"==typeof document){if("undefined"==typeof OffscreenCanvas)throw TypeError("failed to create canvas: OffscreenCanvas is not supported");return new OffscreenCanvas(1,1)}let er=document.createElement("canvas");return er.width=1,er.height=1,er}(),es={alpha:!1,depth:!1,antialias:!1,stencil:!1,preserveDrawingBuffer:!1,premultipliedAlpha:!1,failIfMajorPerformanceCaveat:!1};if((!er||"webgl2"===er)&&(en=ei.getContext("webgl2",es)))try{return new ea.WebGLContext(en,2)}catch(er){eo.Logger.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl2'. Error: ${er}`)}if((!er||"webgl"===er)&&(en=ei.getContext("webgl",es)||ei.getContext("experimental-webgl",es)))try{return new ea.WebGLContext(en,1)}catch(er){eo.Logger.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${er}`)}throw Error("WebGL is not supported")}en.createWebGLContext=function er(en){let ei;(!en||"webgl2"===en)&&"webgl2"in es?ei=es.webgl2:(!en||"webgl"===en)&&"webgl"in es&&(ei=es.webgl),ei=ei||eu(en),en=en||1===ei.version?"webgl":"webgl2";let eo=ei.gl;return es[en]=ei,eo.isContextLost()?(delete es[en],er(en)):(eo.disable(eo.DEPTH_TEST),eo.disable(eo.STENCIL_TEST),eo.disable(eo.BLEND),eo.disable(eo.DITHER),eo.disable(eo.POLYGON_OFFSET_FILL),eo.disable(eo.SAMPLE_COVERAGE),eo.enable(eo.SCISSOR_TEST),eo.enable(eo.CULL_FACE),eo.cullFace(eo.BACK),ei)},en.createNewWebGLContext=eu},3524:function(er,en,ei){"use strict";var eo=this&&this.__createBinding||(Object.create?function(er,en,ei,eo){void 0===eo&&(eo=ei);var ea=Object.getOwnPropertyDescriptor(en,ei);ea&&!("get"in ea?!en.__esModule:ea.writable||ea.configurable)||(ea={enumerable:!0,get:function(){return en[ei]}}),Object.defineProperty(er,eo,ea)}:function(er,en,ei,eo){void 0===eo&&(eo=ei),er[eo]=en[ei]}),ea=this&&this.__setModuleDefault||(Object.create?function(er,en){Object.defineProperty(er,"default",{enumerable:!0,value:en})}:function(er,en){er.default=en}),es=this&&this.__importStar||function(er){if(er&&er.__esModule)return er;var en={};if(null!=er)for(var ei in er)"default"!==ei&&Object.prototype.hasOwnProperty.call(er,ei)&&eo(en,er,ei);return ea(en,er),en};Object.defineProperty(en,"__esModule",{value:!0}),en.WebGLContext=en.linearSearchLastTrue=void 0;let eu=ei(8453),el=es(ei(9622)),ec=ei(432);function ep(er){let en=0;for(;en<er.length&&er[en]();++en);return en-1}en.linearSearchLastTrue=ep,en.WebGLContext=class{constructor(er,en){this.frameBufferBound=!1,this.itemsToPoll=[],this.gl=er,this.version=en,this.getExtensions(),this.vertexbuffer=this.createVertexbuffer(),this.framebuffer=this.createFramebuffer(),this.queryVitalParameters()}allocateTexture(er,en,ei,eo){let ea=this.gl,es=ea.createTexture();ea.bindTexture(ea.TEXTURE_2D,es),ea.texParameteri(ea.TEXTURE_2D,ea.TEXTURE_MIN_FILTER,ea.NEAREST),ea.texParameteri(ea.TEXTURE_2D,ea.TEXTURE_MAG_FILTER,ea.NEAREST),ea.texParameteri(ea.TEXTURE_2D,ea.TEXTURE_WRAP_S,ea.CLAMP_TO_EDGE),ea.texParameteri(ea.TEXTURE_2D,ea.TEXTURE_WRAP_T,ea.CLAMP_TO_EDGE);let eu=eo?ei.encode(eo,er*en):null;return ea.texImage2D(ea.TEXTURE_2D,0,ei.internalFormat,er,en,0,ei.format,ei.textureType,eu),this.checkError(),es}updateTexture(er,en,ei,eo,ea){let es=this.gl;es.bindTexture(es.TEXTURE_2D,er);let eu=eo.encode(ea,en*ei);es.texSubImage2D(es.TEXTURE_2D,0,0,0,en,ei,eo.format,eo.textureType,eu),this.checkError()}attachFramebuffer(er,en,ei){let eo=this.gl;eo.bindTexture(eo.TEXTURE_2D,er),eo.bindFramebuffer(eo.FRAMEBUFFER,this.framebuffer),eo.framebufferTexture2D(eo.FRAMEBUFFER,eo.COLOR_ATTACHMENT0,eo.TEXTURE_2D,er,0),this.checkError(),eo.viewport(0,0,en,ei),eo.scissor(0,0,en,ei)}readTexture(er,en,ei,eo,ea,es){let eu=this.gl;es||(es=1),this.frameBufferBound||this.attachFramebuffer(er,en,ei);let el=this.getEncoder(ea,es),ec=el.allocate(en*ei);return eu.bindTexture(eu.TEXTURE_2D,er),eu.framebufferTexture2D(eu.FRAMEBUFFER,eu.COLOR_ATTACHMENT0,eu.TEXTURE_2D,er,0),eu.readPixels(0,0,en,ei,eu.RGBA,el.textureType,ec),this.checkError(),el.decode(ec,eo)}isFramebufferReady(){return!0}getActiveTexture(){let er=this.gl;return"TEXTURE"+(er.getParameter(this.gl.ACTIVE_TEXTURE)-er.TEXTURE0)}getTextureBinding(){return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D)}getFramebufferBinding(){return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING)}setVertexAttributes(er,en){let ei=this.gl;ei.vertexAttribPointer(er,3,ei.FLOAT,!1,20,0),ei.enableVertexAttribArray(er),-1!==en&&(ei.vertexAttribPointer(en,2,ei.FLOAT,!1,20,12),ei.enableVertexAttribArray(en)),this.checkError()}createProgram(er,en){let ei=this.gl,eo=ei.createProgram();return ei.attachShader(eo,er),ei.attachShader(eo,en),ei.linkProgram(eo),eo}compileShader(er,en){let ei=this.gl,eo=ei.createShader(en);if(!eo)throw Error(`createShader() returned null with type ${en}`);if(ei.shaderSource(eo,er),ei.compileShader(eo),!1===ei.getShaderParameter(eo,ei.COMPILE_STATUS))throw Error(`Failed to compile shader: ${ei.getShaderInfoLog(eo)}
Shader source:
${er}`);return eo}deleteShader(er){this.gl.deleteShader(er)}bindTextureToUniform(er,en,ei){let eo=this.gl;eo.activeTexture(eo.TEXTURE0+en),this.checkError(),eo.bindTexture(eo.TEXTURE_2D,er),this.checkError(),eo.uniform1i(ei,en),this.checkError()}draw(){this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.checkError()}checkError(){if(eu.env.debug){let er=this.gl,en=er.getError(),ei="";switch(en){case er.NO_ERROR:return;case er.INVALID_ENUM:ei="INVALID_ENUM";break;case er.INVALID_VALUE:ei="INVALID_VALUE";break;case er.INVALID_OPERATION:ei="INVALID_OPERATION";break;case er.INVALID_FRAMEBUFFER_OPERATION:ei="INVALID_FRAMEBUFFER_OPERATION";break;case er.OUT_OF_MEMORY:ei="OUT_OF_MEMORY";break;case er.CONTEXT_LOST_WEBGL:ei="CONTEXT_LOST_WEBGL";break;default:ei=`Unknown WebGL Error: ${en.toString(16)}`}throw Error(ei)}}deleteTexture(er){this.gl.deleteTexture(er)}deleteProgram(er){this.gl.deleteProgram(er)}getEncoder(er,en,ei=0){if(2===this.version)return new el.RedFloat32DataEncoder(this.gl,en);switch(er){case"float":return 1===ei||this.isRenderFloat32Supported?new el.RGBAFloatDataEncoder(this.gl,en):new el.RGBAFloatDataEncoder(this.gl,en,this.textureHalfFloatExtension.HALF_FLOAT_OES);case"int":throw Error("not implemented");case"byte":return new el.Uint8DataEncoder(this.gl,en);default:throw Error(`Invalid dataType: ${er}`)}}clearActiveTextures(){let er=this.gl;for(let en=0;en<this.maxTextureImageUnits;++en)er.activeTexture(er.TEXTURE0+en),er.bindTexture(er.TEXTURE_2D,null)}dispose(){if(this.disposed)return;let er=this.gl;er.bindFramebuffer(er.FRAMEBUFFER,null),er.deleteFramebuffer(this.framebuffer),er.bindBuffer(er.ARRAY_BUFFER,null),er.deleteBuffer(this.vertexbuffer),er.bindBuffer(er.ELEMENT_ARRAY_BUFFER,null),er.finish(),this.disposed=!0}createDefaultGeometry(){return new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0])}createVertexbuffer(){let er=this.gl,en=er.createBuffer();if(!en)throw Error("createBuffer() returned null");let ei=this.createDefaultGeometry();return er.bindBuffer(er.ARRAY_BUFFER,en),er.bufferData(er.ARRAY_BUFFER,ei,er.STATIC_DRAW),this.checkError(),en}createFramebuffer(){let er=this.gl.createFramebuffer();if(!er)throw Error("createFramebuffer returned null");return er}queryVitalParameters(){let er=this.gl;if(this.isFloatTextureAttachableToFrameBuffer=this.checkFloatTextureAttachableToFrameBuffer(),this.isRenderFloat32Supported=this.checkRenderFloat32(),this.isFloat32DownloadSupported=this.checkFloat32Download(),1===this.version&&!this.textureHalfFloatExtension&&!this.isRenderFloat32Supported)throw Error("both float32 and float16 TextureType are not supported");this.isBlendSupported=!this.isRenderFloat32Supported||this.checkFloat32Blend(),this.maxTextureSize=er.getParameter(er.MAX_TEXTURE_SIZE),this.maxTextureImageUnits=er.getParameter(er.MAX_TEXTURE_IMAGE_UNITS),this.version}getExtensions(){2===this.version?(this.colorBufferFloatExtension=this.gl.getExtension("EXT_color_buffer_float"),this.disjointTimerQueryWebgl2Extension=this.gl.getExtension("EXT_disjoint_timer_query_webgl2")):(this.textureFloatExtension=this.gl.getExtension("OES_texture_float"),this.textureHalfFloatExtension=this.gl.getExtension("OES_texture_half_float"))}checkFloatTextureAttachableToFrameBuffer(){let er=this.gl,en=er.createTexture();er.bindTexture(er.TEXTURE_2D,en);let ei=2===this.version?er.RGBA32F:er.RGBA;er.texImage2D(er.TEXTURE_2D,0,ei,1,1,0,er.RGBA,er.FLOAT,null);let eo=er.createFramebuffer();er.bindFramebuffer(er.FRAMEBUFFER,eo),er.framebufferTexture2D(er.FRAMEBUFFER,er.COLOR_ATTACHMENT0,er.TEXTURE_2D,en,0);let ea=er.checkFramebufferStatus(er.FRAMEBUFFER)===er.FRAMEBUFFER_COMPLETE;return er.bindTexture(er.TEXTURE_2D,null),er.bindFramebuffer(er.FRAMEBUFFER,null),er.deleteTexture(en),er.deleteFramebuffer(eo),ea}checkRenderFloat32(){if(2===this.version){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension)return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Download(){if(2===this.version){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension||!this.gl.getExtension("WEBGL_color_buffer_float"))return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Blend(){let er,en,ei,eo,ea;let es=this.gl;try{er=es.createTexture(),en=es.createFramebuffer(),es.bindTexture(es.TEXTURE_2D,er);let eu=2===this.version?es.RGBA32F:es.RGBA;return es.texImage2D(es.TEXTURE_2D,0,eu,1,1,0,es.RGBA,es.FLOAT,null),es.bindFramebuffer(es.FRAMEBUFFER,en),es.framebufferTexture2D(es.FRAMEBUFFER,es.COLOR_ATTACHMENT0,es.TEXTURE_2D,er,0),es.enable(es.BLEND),!!(ei=es.createShader(es.VERTEX_SHADER))&&(es.shaderSource(ei,"void main(){}"),es.compileShader(ei),!!(eo=es.createShader(es.FRAGMENT_SHADER))&&(es.shaderSource(eo,"precision highp float;void main(){gl_FragColor=vec4(0.5);}"),es.compileShader(eo),!!(ea=es.createProgram())&&(es.attachShader(ea,ei),es.attachShader(ea,eo),es.linkProgram(ea),es.useProgram(ea),es.drawArrays(es.POINTS,0,1),es.getError()===es.NO_ERROR)))}finally{es.disable(es.BLEND),ea&&es.deleteProgram(ea),ei&&es.deleteShader(ei),eo&&es.deleteShader(eo),en&&(es.bindFramebuffer(es.FRAMEBUFFER,null),es.deleteFramebuffer(en)),er&&(es.bindTexture(es.TEXTURE_2D,null),es.deleteTexture(er))}}beginTimer(){if(2===this.version&&this.disjointTimerQueryWebgl2Extension){let er=this.gl,en=this.disjointTimerQueryWebgl2Extension,ei=er.createQuery();return er.beginQuery(en.TIME_ELAPSED_EXT,ei),ei}throw Error("WebGL1 profiling currently not supported.")}endTimer(){if(2!==this.version||!this.disjointTimerQueryWebgl2Extension)throw Error("WebGL1 profiling currently not supported");{let er=this.gl,en=this.disjointTimerQueryWebgl2Extension;er.endQuery(en.TIME_ELAPSED_EXT)}}isTimerResultAvailable(er){let en=!1,ei=!1;if(2!==this.version||!this.disjointTimerQueryWebgl2Extension)throw Error("WebGL1 profiling currently not supported");{let eo=this.gl,ea=this.disjointTimerQueryWebgl2Extension;en=eo.getQueryParameter(er,eo.QUERY_RESULT_AVAILABLE),ei=eo.getParameter(ea.GPU_DISJOINT_EXT)}return en&&!ei}getTimerResult(er){let en=0;if(2!==this.version)throw Error("WebGL1 profiling currently not supported");{let ei=this.gl;en=ei.getQueryParameter(er,ei.QUERY_RESULT),ei.deleteQuery(er)}return en/1e6}async waitForQueryAndGetTime(er){return await (0,ec.repeatedTry)(()=>this.isTimerResultAvailable(er)),this.getTimerResult(er)}async createAndWaitForFence(){let er=this.createFence(this.gl);return this.pollFence(er)}createFence(er){let en;let ei=er,eo=ei.fenceSync(ei.SYNC_GPU_COMMANDS_COMPLETE,0);return er.flush(),en=null===eo?()=>!0:()=>{let er=ei.clientWaitSync(eo,0,0);return er===ei.ALREADY_SIGNALED||er===ei.CONDITION_SATISFIED},{query:eo,isFencePassed:en}}async pollFence(er){return new Promise(en=>{this.addItemToPoll(()=>er.isFencePassed(),()=>en())})}pollItems(){let er=ep(this.itemsToPoll.map(er=>er.isDoneFn));for(let en=0;en<=er;++en){let{resolveFn:er}=this.itemsToPoll[en];er()}this.itemsToPoll=this.itemsToPoll.slice(er+1)}async addItemToPoll(er,en){this.itemsToPoll.push({isDoneFn:er,resolveFn:en}),this.itemsToPoll.length>1||await (0,ec.repeatedTry)(()=>(this.pollItems(),0===this.itemsToPoll.length))}}},6496:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.ExecutionPlan=void 0;let eo=ei(1315);class ea{constructor(er,en){this.op=er,this.node=en}}en.ExecutionPlan=class{constructor(er,en,ei){this.graph=er,this.profiler=ei,this.initialize(en)}initialize(er){this.profiler.event("session","ExecutionPlan.initialize",()=>{let en=this.graph.getNodes();if(en.length!==er.length)throw Error("The size of nodes and OPs do not match.");this._ops=er.map((er,ei)=>new ea(er,en[ei])),this.reset(),this._starter=[],this._ops.forEach((er,en)=>{let ei=!0;for(let en of er.node.inputs)if(!this._values[en]&&-1===this.graph.getInputIndices().indexOf(en)){ei=!1;break}ei&&this._starter.push(en)})})}reset(){this._values=this.graph.getValues().map(er=>er.tensor)}async execute(er,en){return this.profiler.event("session","ExecutionPlan.execute",async()=>{this.reset();let ei=er.createInferenceHandler(),ea=this.graph.getInputIndices();if(en.length!==ea.length)throw Error(`number of input tensors don't match the number of inputs to the model: actual: ${en.length} expected: ${ea.length}`);en.forEach((er,en)=>{let ei=ea[en];this._values[ei]=er});let es=this._starter.slice(0),eu=this.graph.getValues(),el=this.graph.getNodes(),ec=0;for(;ec<es.length;){let er=es[ec++],en=this._ops[er],ea=en.node.inputs.map(er=>this._values[er]);if(-1!==ea.indexOf(void 0))throw Error(`unresolved input detected: op: ${en.node}`);let ep=ea;eo.Logger.verbose("ExecPlan",`Runing op:${en.node.name} (${ep.map((er,ei)=>`'${en.node.inputs[ei]}': ${er.type}[${er.dims.join(",")}]`).join(", ")})`);let ed=await this.profiler.event("node",en.node.name,async()=>en.op.impl(ei,ep,en.op.context));if(ed.length!==en.node.outputs.length)throw Error("the size of output does not match model definition.");ed.forEach((er,ei)=>{let eo=en.node.outputs[ei];if(this._values[eo])throw Error(`output [${eo}] already has value: op:${en.node.name}`);this._values[eo]=er});let ef=new Set;ed.forEach((er,ei)=>{let eo=en.node.outputs[ei];for(let er of eu[eo].to){let en=el[er],ei=!0;for(let er of en.inputs)if(!this._values[er]){ei=!1;break}ei&&ef.add(er)}}),es.push(...ef)}let ep=[];for(let er=0;er<this.graph.getOutputIndices().length;er++){let en=this.graph.getOutputIndices()[er],ei=this._values[en];if(void 0===ei)throw Error(`required output [${en}] does not have value`);0===en?await ei.getData():ei.data,ep.push(ei)}return eo.Logger.verbose("ExecPlan","disposing of inferenceHandler"),ei.dispose(),ep})}}},4662:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.Graph=void 0;let eo=ei(1446),ea=ei(6874),es=ei(1287),eu=ei(9240),el=ei(7273);var ec=es.onnxruntime.experimental.fbs;en.Graph={from:(er,en)=>new ef(er,en)};class ep{constructor(er){this._from=void 0,this._to=[],this.tensor=void 0,this.type=void 0,er&&(this.type=el.ProtoUtil.tensorValueTypeFromProto(er.type.tensorType))}get from(){return this._from}get to(){return this._to}}class ed{constructor(er,en){er instanceof eo.onnx.NodeProto?(this.name=er.name,this.opType=er.opType,this.attributes=new ea.Attribute(er.attribute)):er instanceof ec.Node&&(this.name=null!=en?en:er.name(),this.opType=er.opType(),this.attributes=new ea.Attribute(el.ProtoUtil.tensorAttributesFromORTFormat(er))),this.inputs=[],this.outputs=[],this.executeNode=!0}}class ef{constructor(er,en){if(!er)throw TypeError("graph is empty");this.buildGraph(er),this.transformGraph(en),this.checkIsAcyclic()}getInputIndices(){return this._allInputIndices}getInputNames(){return this._allInputNames}getOutputIndices(){return this._allOutputIndices}getOutputNames(){return this._allOutputNames}getValues(){return this._allData}getNodes(){return this._nodes}buildGraph(er){if(er instanceof eo.onnx.GraphProto)this.buildGraphFromOnnxFormat(er);else{if(!(er instanceof ec.Graph))throw TypeError("Graph type is not supported.");this.buildGraphFromOrtFormat(er)}}buildGraphFromOnnxFormat(er){let en=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];let ei=new Map;if(!er.input)throw Error("missing information in graph: input");let eo=[];for(let ei of er.input){if(en.has(ei.name))throw Error(`duplicated input name: ${ei.name}`);let er=this._allData.push(new ep(ei))-1;en.set(ei.name,er),eo.push(ei.name)}if(!er.initializer)throw Error("missing information in graph: initializer");for(let ei of er.initializer){let er=en.get(ei.name);if(void 0===er){let eo=new ep;eo.type={shape:{dims:el.ProtoUtil.tensorDimsFromProto(ei.dims)},tensorType:el.ProtoUtil.tensorDataTypeFromProto(ei.dataType)},er=this._allData.push(eo)-1,en.set(ei.name,er)}this._allData[er]._from=-1,this._allData[er].tensor=eu.Tensor.fromProto(ei)}for(let er=0;er<this._allData.length;er++)this._allData[er].tensor||(this._allInputIndices.push(er),this._allInputNames.push(eo[er]));if(!er.output)throw Error("missing information in graph: output");for(let ei of er.output){if(en.has(ei.name))throw Error(`duplicated output name: ${ei.name}`);let er=this._allData.push(new ep(ei))-1;en.set(ei.name,er),this._allOutputIndices.push(er),this._allOutputNames.push(ei.name)}if(!er.node)throw Error("missing information in graph: node");for(let en of er.node){if(!en.name)for(let er=0;;er++){let eo=`unnamed_${en.opType}_${er}`;if(!ei.has(eo)){en.name=eo;break}}if(ei.has(en.name))throw Error(`duplicated node name: ${en.name}`);let er=this._nodes.push(new ed(en))-1;ei.set(en.name,er)}for(let ei=0;ei<this._nodes.length;ei++){let eo=this._nodes[ei],ea=er.node[ei];if(!ea.output)throw Error(`missing output for node: ${ea.name}`);for(let er of ea.output){let es=en.get(er);if(void 0===es&&(es=this._allData.push(new ep)-1,en.set(er,es)),eo.outputs.push(es),void 0!==this._allData[es]._from)throw Error(`multiple nodes output to one data value: ${es}`);if(this._allData[es]._from=ei,"Constant"===ea.opType){if(!ea.attribute||1!==ea.attribute.length||!ea.attribute[0].t)throw Error("missing attributes or missing tensor value in attributes for this Constant operator");if(!ea.output||1!==ea.output.length)throw Error("missing output or incorrect number of outputs for this Constant operator");eo.outputs.pop(),eo.executeNode=!1,this._allData[es]._from=-1,this._allData[es].tensor=eu.Tensor.fromProto(ea.attribute[0].t)}}}for(let ei=0;ei<this._nodes.length;ei++){let eo=this._nodes[ei],ea=er.node[ei];if(!ea.input)throw Error(`missing input for node: ${ea.name}`);for(let er of ea.input){let es=en.get(er);if(void 0===es){if(""===er&&3===ea.input.length&&"Resize"===ea.opType)continue;throw Error(`unrecognized input '${er}' for node: ${ea.name}`)}eo.inputs.push(es),this._allData[es]._to.push(ei)}}return!0}buildGraphFromOrtFormat(er){var en,ei,eo;let ea=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];let es=new Map,ef=[];for(let es=0;es<er.inputsLength();es++){let eu=er.inputs(es);if(ea.has(eu))throw Error(`duplicated input name: ${eu}`);for(let es=0;es<er.nodeArgsLength();es++)if((null===(en=er.nodeArgs(es))||void 0===en?void 0:en.name())===eu){let en=new ep;if((null===(eo=null===(ei=er.nodeArgs(es))||void 0===ei?void 0:ei.type())||void 0===eo?void 0:eo.valueType())!==ec.TypeInfoValue.tensor_type)throw Error("Unexpected value type for the nodeArg.");let ed=er.nodeArgs(es).type().value(new ec.TensorTypeAndShape),eh=el.ProtoUtil.tensorDataTypeFromProto(ed.elemType()),eg=ed.shape(),em=[];for(let er=0;er<eg.dimLength();er++)em.push(el.LongUtil.longToNumber(eg.dim(er).value().dimValue()));en.type={shape:{dims:em},tensorType:eh};let eb=this._allData.push(en)-1;ea.set(eu,eb),ef.push(eu)}}for(let en=0;en<er.initializersLength();en++){let ei=er.initializers(en),eo=ea.get(ei.name());if(void 0===eo){let er=new ep,en=el.ProtoUtil.tensorDimsFromORTFormat(ei),es=el.ProtoUtil.tensorDataTypeFromProto(ei.dataType());er.type={shape:{dims:en},tensorType:es},eo=this._allData.push(er)-1,ea.set(ei.name(),eo)}this._allData[eo]._from=-1,this._allData[eo].tensor=eu.Tensor.fromOrtTensor(ei)}for(let er=0;er<this._allData.length;er++)this._allData[er].tensor||(this._allInputIndices.push(er),this._allInputNames.push(ef[er]));for(let en=0;en<er.outputsLength();en++){let ei=er.outputs(en);if(ea.has(ei))throw Error(`duplicated output name: ${ei}`);let eo=this._allData.push(new ep)-1;ea.set(ei,eo),this._allOutputIndices.push(eo),this._allOutputNames.push(ei)}if(!er.nodes)throw Error("missing information in graph: node");for(let en=0;en<er.nodesLength();en++){let ei=er.nodes(en),eo=ei.name();if(!eo)for(let er=0;eo=`unnamed_${ei.opType()}_${er}`,es.has(eo);er++);if(es.has(eo))throw Error(`duplicated node name: ${eo}`);let ea=this._nodes.push(new ed(ei,eo))-1;es.set(eo,ea)}for(let en=0;en<this._nodes.length;en++){let ei=this._nodes[en],eo=er.nodes(en);if(null==eo)throw Error(`No node exists at index ${en}`);if(0===(null==eo?void 0:eo.outputsLength()))throw Error(`missing output for node: ${eo.name}`);for(let er=0;er<(null==eo?void 0:eo.outputsLength());er++){let es=null==eo?void 0:eo.outputs(er),el=ea.get(es);if(void 0===el&&(el=this._allData.push(new ep)-1,ea.set(es,el)),ei.outputs.push(el),void 0!==this._allData[el]._from)throw Error(`multiple nodes output to one data value: ${el}`);if(this._allData[el]._from=en,"Constant"===eo.opType()){if(1!==eo.attributesLength()||!eo.attributes(0).t())throw Error("missing attributes or missing tensor value in attributes for this Constant operator");if(1!==eo.outputsLength())throw Error("missing output or incorrect number of outputs for this Constant operator");ei.outputs.pop(),ei.executeNode=!1,this._allData[el]._from=-1,this._allData[el].tensor=eu.Tensor.fromOrtTensor(eo.attributes(0).t())}}}for(let en=0;en<this._nodes.length;en++){let ei=this._nodes[en],eo=er.nodes(en);if(0===eo.inputsLength())throw Error(`missing input for node: ${eo.name}`);for(let er=0;er<eo.inputsLength();er++){let es=eo.inputs(er),eu=ea.get(es);if(void 0===eu)throw Error(`unrecognized input '${es}' for node: ${eo.name()}`);ei.inputs.push(eu),this._allData[eu]._to.push(en)}}}checkIsAcyclic(){let er=new Set;this._allInputIndices.forEach(en=>{this._allData[en]._to.forEach(en=>{er.add(en)})});let en=Array.from(er),ei=Array(this._nodes.length).fill("white");for(;en.length>0;){let er=en.pop();"gray"===ei[er]?ei[er]="black":(en.push(er),ei[er]="gray",this._nodes[er].outputs.forEach(eo=>{let ea=this._allData[eo];if(void 0!==ea.tensor)throw Error("node outputs should not be initialized");if(ea._from!==er)throw Error("from property of the Value object doesn't match index of Node being processed");ea._to.forEach(er=>{if("gray"===ei[er])throw Error("model graph is cyclic");"white"===ei[er]&&en.push(er)})}))}}transformGraph(er){this.removeAllIdentityNodes(),this.removeAllDropoutNodes(),this.fuseConvActivationNodes(),er&&er.transformGraph(this),this.finalizeGraph()}finalizeGraph(){let er=0,en=[this._nodes.length,0],ei=0;for(let er=0;er<this._nodes.length;er++)en[er]=ei,this._nodes[er].executeNode?(ei!==er&&(this._nodes[ei]=this._nodes[er]),ei++):this._nodes[er].outputs.forEach(er=>{this._allData[er]._from=-2});this._nodes.splice(ei,this._nodes.length-ei);for(let er=0;er<this._allData.length;er++){let ei=this._allData[er];void 0!==ei._from&&-1!==ei._from&&-2!==ei._from&&(ei._from=en[ei._from]);for(let er=0;er<ei._to.length;er++){if(!(ei._to[er]>=0))throw Error("Trying to update a removed node");ei._to[er]=en[ei._to[er]]}}er=0;for(let en=0;en<this._allData.length;en++)if(-2!==this._allData[en].from||-1!==this._allOutputIndices.indexOf(en+er)){if(er>0){let ei=-1;void 0!==this._allData[en].from&&-1!==this._allData[en].from?-1!==(ei=this._nodes[this._allData[en].from].outputs.indexOf(en+er))&&(this._nodes[this._allData[en].from].outputs[ei]=en):-1!==(ei=this._allInputIndices.indexOf(en+er))&&(this._allInputIndices[ei]=en),this._allData[en].to.forEach(eo=>{-1!==(ei=this._nodes[eo].inputs.indexOf(en+er))&&(this._nodes[eo].inputs[ei]=en)}),0===this._allData[en].to.length&&-1!==(ei=this._allOutputIndices.indexOf(en+er))&&(this._allOutputIndices[ei]=en)}}else er++,this._allData.splice(en,1),en--}deleteNode(er){let en=this._nodes[er];if(en.outputs.length>1){for(let er=1;er<en.outputs.length;er++)if(this._allData[en.outputs[er]].to.length>0)throw Error("Node deletion with more than one output connected to other nodes is not supported. ")}en.executeNode=!1;let ei=en.inputs[0],eo=en.outputs[0],ea=this._allData[eo].to;for(let ei=0;ei<en.inputs.length;ei++){let eo=this._allData[en.inputs[ei]].to.indexOf(er);if(-1===eo)throw Error("The Value object doesn't have the current Node in it's 'to' property ");this._allData[en.inputs[ei]].to.splice(eo,1)}this._allData[eo]._to=[];let es=this._allOutputIndices.indexOf(eo);if(-1!==es&&(this._allOutputIndices[es]=ei),ea&&ea.length>0)for(let er of ea){let en=this._nodes[er].inputs.indexOf(eo);if(-1===en)throw Error("The Node object doesn't have the output Value in it's 'inputs' property ");this._nodes[er].inputs[en]=ei,this._allData[ei].to.push(er)}}removeAllDropoutNodes(){let er=0;for(let en of this._nodes){if("Dropout"===en.opType){if(1!==en.inputs.length)throw Error("Dropout nodes should only contain one input. ");if(1!==en.outputs.length&&2!==en.outputs.length)throw Error("Dropout nodes should contain either 1 or 2 output(s)");if(2===en.outputs.length&&0!==this._allData[en.outputs[1]]._to.length)throw Error("Dropout nodes's second output should not be referenced by other nodes");this.deleteNode(er)}er++}}removeAllIdentityNodes(){let er=0;for(let en of this._nodes)"Identity"===en.opType&&this.deleteNode(er),er++}isActivation(er){switch(er.opType){case"Relu":case"Sigmoid":case"Clip":return!0;default:return!1}}fuseConvActivationNodes(){for(let er of this._nodes)if("Conv"===er.opType){let en=this._allData[er.outputs[0]]._to;if(1===en.length&&this.isActivation(this._nodes[en[0]])){let ei=this._nodes[en[0]];if("Clip"===ei.opType){if(1===ei.inputs.length)try{er.attributes.set("activation_params","floats",[ei.attributes.getFloat("min"),ei.attributes.getFloat("max")])}catch(en){er.attributes.set("activation_params","floats",[el.MIN_CLIP,el.MAX_CLIP])}else{if(!(ei.inputs.length>=3&&void 0!==this._allData[ei.inputs[1]].tensor&&void 0!==this._allData[ei.inputs[2]].tensor))continue;er.attributes.set("activation_params","floats",[this._allData[ei.inputs[1]].tensor.floatData[0],this._allData[ei.inputs[2]].tensor.floatData[0]])}}er.attributes.set("activation","string",ei.opType),this.deleteNode(en[0])}}}}},1315:(er,en)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.now=en.Profiler=en.Logger=void 0;let ei={verbose:1e3,info:2e3,warning:4e3,error:5e3,fatal:6e3},eo={none:new class{log(er,en,ei){}},console:new class{log(er,en,ei){console.log(`${this.color(er)} ${ei?"\x1b[35m"+ei+"\x1b[0m ":""}${en}`)}color(er){switch(er){case"verbose":return"\x1b[34;40mv\x1b[0m";case"info":return"\x1b[32mi\x1b[0m";case"warning":return"\x1b[30;43mw\x1b[0m";case"error":return"\x1b[31;40me\x1b[0m";case"fatal":return"\x1b[101mf\x1b[0m";default:throw Error(`unsupported severity: ${er}`)}}}},ea={provider:"console",minimalSeverity:"warning",logDateTime:!0,logSourceLocation:!1},es={"":ea};function eu(er,en,ei,eo){var ea;if(void 0===en)return ea=er,{verbose:eu.verbose.bind(null,ea),info:eu.info.bind(null,ea),warning:eu.warning.bind(null,ea),error:eu.error.bind(null,ea),fatal:eu.fatal.bind(null,ea)};if(void 0===ei)el(er,en);else if("number"==typeof ei&&void 0===eo)el(er,en);else if("string"==typeof ei&&void 0===eo)el(er,ei,0,en);else{if("string"!=typeof ei||"number"!=typeof eo)throw TypeError("input is valid");el(er,ei,0,en)}}function el(er,en,ea,eu){let el=es[eu||""]||es[""];ei[er]<ei[el.minimalSeverity]||(el.logDateTime&&(en=`${(new Date).toISOString()}|${en}`),el.logSourceLocation,eo[el.provider].log(er,en,eu))}!function(er){function en(er){es={},ei("",er||{})}function ei(er,ei){if("*"===er)en(ei);else{let en=es[er]||ea;es[er]={provider:ei.provider||en.provider,minimalSeverity:ei.minimalSeverity||en.minimalSeverity,logDateTime:void 0===ei.logDateTime?en.logDateTime:ei.logDateTime,logSourceLocation:void 0===ei.logSourceLocation?en.logSourceLocation:ei.logSourceLocation}}}er.verbose=function(en,ei){er("verbose",en,ei)},er.info=function(en,ei){er("info",en,ei)},er.warning=function(en,ei){er("warning",en,ei)},er.error=function(en,ei){er("error",en,ei)},er.fatal=function(en,ei){er("fatal",en,ei)},er.reset=en,er.set=ei,er.setWithEnv=function(er){let en={};er.logLevel&&(en.minimalSeverity=er.logLevel),ei("",en)}}(eu||(eu={})),en.Logger=eu;class ec{constructor(er,en,ei,eo,ea,es){this.category=er,this.name=en,this.startTime=ei,this.endCallback=eo,this.timer=ea,this.ctx=es}async end(){return this.endCallback(this)}async checkTimer(){if(void 0===this.ctx||void 0===this.timer)throw Error("No webgl timer found");return this.ctx.endTimer(),this.ctx.waitForQueryAndGetTime(this.timer)}}class ep{constructor(er,en,ei,eo){this.category=er,this.name=en,this.startTime=ei,this.endTime=eo}}en.Profiler=class{static create(er){return void 0===er?new this:new this(er.maxNumberEvents,er.flushBatchSize,er.flushIntervalInMilliseconds)}constructor(er,en,ei){this._started=!1,this._flushPointer=0,this._started=!1,this._maxNumberEvents=void 0===er?1e4:er,this._flushBatchSize=void 0===en?10:en,this._flushIntervalInMilliseconds=void 0===ei?5e3:ei}start(){this._started=!0,this._timingEvents=[],this._flushTime=(0,en.now)(),this._flushPointer=0}stop(){for(this._started=!1;this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer])}event(er,en,ei,eo){let ea=this._started?this.begin(er,en,eo):void 0,es=!1,eu=ei();if(eu&&"function"==typeof eu.then)return es=!0,new Promise((er,en)=>{eu.then(async en=>{ea&&await ea.end(),er(en)},async er=>{ea&&await ea.end(),en(er)})});if(!es&&ea){let er=ea.end();if(er&&"function"==typeof er.then)return new Promise((en,ei)=>{er.then(()=>{en(eu)},er=>{ei(er)})})}return eu}begin(er,ei,eo){if(!this._started)throw Error("profiler is not started yet");if(void 0===eo){let eo=(0,en.now)();return this.flush(eo),new ec(er,ei,eo,er=>this.endSync(er))}{let en=eo.beginTimer();return new ec(er,ei,0,async er=>this.end(er),en,eo)}}async end(er){let en=await er.checkTimer();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new ep(er.category,er.name,er.startTime,en)),this.flush(en))}endSync(er){let ei=(0,en.now)();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new ep(er.category,er.name,er.startTime,ei)),this.flush(ei))}logOneEvent(er){en.Logger.verbose(`Profiler.${er.category}`,`${(er.endTime-er.startTime).toFixed(2)}ms on event '${er.name}' at ${er.endTime.toFixed(2)}`)}flush(er){if(this._timingEvents.length-this._flushPointer>=this._flushBatchSize||er-this._flushTime>=this._flushIntervalInMilliseconds){for(let er=this._flushPointer;this._flushPointer<er+this._flushBatchSize&&this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer]);this._flushTime=(0,en.now)()}}get started(){return this._started}},en.now="undefined"!=typeof performance&&performance.now?()=>performance.now():Date.now},1745:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.Model=void 0;let eo=ei(5686),ea=ei(1446),es=ei(4662),eu=ei(1287),el=ei(7273);var ec=eu.onnxruntime.experimental.fbs;en.Model=class{constructor(){}load(er,en,ei){if(!ei)try{return void this.loadFromOnnxFormat(er,en)}catch(er){if(void 0!==ei)throw er}this.loadFromOrtFormat(er,en)}loadFromOnnxFormat(er,en){let ei=ea.onnx.ModelProto.decode(er);if(3>el.LongUtil.longToNumber(ei.irVersion))throw Error("only support ONNX model with IR_VERSION>=3");this._opsets=ei.opsetImport.map(er=>({domain:er.domain,version:el.LongUtil.longToNumber(er.version)})),this._graph=es.Graph.from(ei.graph,en)}loadFromOrtFormat(er,en){let ei=new eo.flatbuffers.ByteBuffer(er),ea=ec.InferenceSession.getRootAsInferenceSession(ei).model();if(3>el.LongUtil.longToNumber(ea.irVersion()))throw Error("only support ONNX model with IR_VERSION>=3");this._opsets=[];for(let er=0;er<ea.opsetImportLength();er++){let en=ea.opsetImport(er);this._opsets.push({domain:null==en?void 0:en.domain(),version:el.LongUtil.longToNumber(en.version())})}this._graph=es.Graph.from(ea.graph(),en)}get graph(){return this._graph}get opsets(){return this._opsets}}},6145:(er,en)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.FLOAT_TYPES=en.INT_TYPES=en.NUMBER_TYPES=void 0,en.NUMBER_TYPES=["float32","float64","int32","int16","int8","uint16","uint32","uint8"],en.INT_TYPES=["int32","int16","int8","uint16","uint32","uint8"],en.FLOAT_TYPES=["float32","float64"]},5881:(er,en)=>{"use strict";function ei(er,en){if(en.endsWith("+")){let ei=Number.parseInt(en.substring(0,en.length-1),10);return!isNaN(ei)&&ei<=er}if(2===en.split("-").length){let ei=en.split("-"),eo=Number.parseInt(ei[0],10),ea=Number.parseInt(ei[1],10);return!isNaN(eo)&&!isNaN(ea)&&eo<=er&&er<=ea}return Number.parseInt(en,10)===er}Object.defineProperty(en,"__esModule",{value:!0}),en.resolveOperator=void 0,en.resolveOperator=function(er,en,eo){for(let ea of eo){let eo=ea[0],es=ea[1],eu=ea[2],el=ea[3],ec=ea[4];if(er.opType===eo){for(let er of en)if((er.domain===es||"ai.onnx"===er.domain&&""===es)&&ei(er.version,eu))return{opImpl:el,opInit:ec}}}throw TypeError(`cannot resolve operator '${er.opType}' with opsets: ${en.map(er=>`${er.domain||"ai.onnx"} v${er.version}`).join(", ")}`)}},1287:(er,en,ei)=>{"use strict";var eo,ea;Object.defineProperty(en,"__esModule",{value:!0}),en.onnxruntime=void 0;let es=ei(5686);(function(er){let en;!function(er){er[er.UNDEFINED=0]="UNDEFINED",er[er.FLOAT=1]="FLOAT",er[er.INT=2]="INT",er[er.STRING=3]="STRING",er[er.TENSOR=4]="TENSOR",er[er.GRAPH=5]="GRAPH",er[er.FLOATS=6]="FLOATS",er[er.INTS=7]="INTS",er[er.STRINGS=8]="STRINGS",er[er.TENSORS=9]="TENSORS",er[er.GRAPHS=10]="GRAPHS",er[er.SPARSE_TENSOR=11]="SPARSE_TENSOR",er[er.SPARSE_TENSORS=12]="SPARSE_TENSORS"}(en=er.AttributeType||(er.AttributeType={}))})((ea=(eo=en.onnxruntime||(en.onnxruntime={})).experimental||(eo.experimental={})).fbs||(ea.fbs={})),function(er){!function(er){!function(er){let en;!function(er){er[er.UNKNOWN=0]="UNKNOWN",er[er.VALUE=1]="VALUE",er[er.PARAM=2]="PARAM"}(en=er.DimensionValueType||(er.DimensionValueType={}))}(er.fbs||(er.fbs={}))}(er.experimental||(er.experimental={}))}(en.onnxruntime||(en.onnxruntime={})),function(er){!function(er){!function(er){let en;!function(er){er[er.UNDEFINED=0]="UNDEFINED",er[er.FLOAT=1]="FLOAT",er[er.UINT8=2]="UINT8",er[er.INT8=3]="INT8",er[er.UINT16=4]="UINT16",er[er.INT16=5]="INT16",er[er.INT32=6]="INT32",er[er.INT64=7]="INT64",er[er.STRING=8]="STRING",er[er.BOOL=9]="BOOL",er[er.FLOAT16=10]="FLOAT16",er[er.DOUBLE=11]="DOUBLE",er[er.UINT32=12]="UINT32",er[er.UINT64=13]="UINT64",er[er.COMPLEX64=14]="COMPLEX64",er[er.COMPLEX128=15]="COMPLEX128",er[er.BFLOAT16=16]="BFLOAT16"}(en=er.TensorDataType||(er.TensorDataType={}))}(er.fbs||(er.fbs={}))}(er.experimental||(er.experimental={}))}(en.onnxruntime||(en.onnxruntime={})),function(er){!function(er){!function(er){let en;!function(er){er[er.Primitive=0]="Primitive",er[er.Fused=1]="Fused"}(en=er.NodeType||(er.NodeType={}))}(er.fbs||(er.fbs={}))}(er.experimental||(er.experimental={}))}(en.onnxruntime||(en.onnxruntime={})),function(er){!function(er){!function(er){let en;!function(er){er[er.NONE=0]="NONE",er[er.tensor_type=1]="tensor_type",er[er.sequence_type=2]="sequence_type",er[er.map_type=3]="map_type"}(en=er.TypeInfoValue||(er.TypeInfoValue={}))}(er.fbs||(er.fbs={}))}(er.experimental||(er.experimental={}))}(en.onnxruntime||(en.onnxruntime={})),function(er){!function(en){!function(en){class ei{constructor(){this.bb=null,this.bb_pos=0}__init(er,en){return this.bb_pos=er,this.bb=en,this}static getRootAsShape(er,en){return(en||new ei).__init(er.readInt32(er.position())+er.position(),er)}static getSizePrefixedRootAsShape(er,en){return er.setPosition(er.position()+es.flatbuffers.SIZE_PREFIX_LENGTH),(en||new ei).__init(er.readInt32(er.position())+er.position(),er)}dim(en,ei){let eo=this.bb.__offset(this.bb_pos,4);return eo?(ei||new er.experimental.fbs.Dimension).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+eo)+4*en),this.bb):null}dimLength(){let er=this.bb.__offset(this.bb_pos,4);return er?this.bb.__vector_len(this.bb_pos+er):0}static startShape(er){er.startObject(1)}static addDim(er,en){er.addFieldOffset(0,en,0)}static createDimVector(er,en){er.startVector(4,en.length,4);for(let ei=en.length-1;ei>=0;ei--)er.addOffset(en[ei]);return er.endVector()}static startDimVector(er,en){er.startVector(4,en,4)}static endShape(er){return er.endObject()}static createShape(er,en){return ei.startShape(er),ei.addDim(er,en),ei.endShape(er)}}en.Shape=ei}(en.fbs||(en.fbs={}))}(er.experimental||(er.experimental={}))}(en.onnxruntime||(en.onnxruntime={})),function(er){!function(en){!function(en){class ei{constructor(){this.bb=null,this.bb_pos=0}__init(er,en){return this.bb_pos=er,this.bb=en,this}static getRootAsDimension(er,en){return(en||new ei).__init(er.readInt32(er.position())+er.position(),er)}static getSizePrefixedRootAsDimension(er,en){return er.setPosition(er.position()+es.flatbuffers.SIZE_PREFIX_LENGTH),(en||new ei).__init(er.readInt32(er.position())+er.position(),er)}value(en){let ei=this.bb.__offset(this.bb_pos,4);return ei?(en||new er.experimental.fbs.DimensionValue).__init(this.bb.__indirect(this.bb_pos+ei),this.bb):null}denotation(er){let en=this.bb.__offset(this.bb_pos,6);return en?this.bb.__string(this.bb_pos+en,er):null}static startDimension(er){er.startObject(2)}static addValue(er,en){er.addFieldOffset(0,en,0)}static addDenotation(er,en){er.addFieldOffset(1,en,0)}static endDimension(er){return er.endObject()}static createDimension(er,en,eo){return ei.startDimension(er),ei.addValue(er,en),ei.addDenotation(er,eo),ei.endDimension(er)}}en.Dimension=ei}(en.fbs||(en.fbs={}))}(er.experimental||(er.experimental={}))}(en.onnxruntime||(en.onnxruntime={})),function(er){!function(en){!function(en){class ei{constructor(){this.bb=null,this.bb_pos=0}__init(er,en){return this.bb_pos=er,this.bb=en,this}static getRootAsDimensionValue(er,en){return(en||new ei).__init(er.readInt32(er.position())+er.position(),er)}static getSizePrefixedRootAsDimensionValue(er,en){return er.setPosition(er.position()+es.flatbuffers.SIZE_PREFIX_LENGTH),(en||new ei).__init(er.readInt32(er.position())+er.position(),er)}dimType(){let en=this.bb.__offset(this.bb_pos,4);return en?this.bb.readInt8(this.bb_pos+en):er.experimental.fbs.DimensionValueType.UNKNOWN}dimValue(){let er=this.bb.__offset(this.bb_pos,6);return er?this.bb.readInt64(this.bb_pos+er):this.bb.createLong(0,0)}dimParam(er){let en=this.bb.__offset(this.bb_pos,8);return en?this.bb.__string(this.bb_pos+en,er):null}static startDimensionValue(er){er.startObject(3)}static addDimType(en,ei){en.addFieldInt8(0,ei,er.experimental.fbs.DimensionValueType.UNKNOWN)}static addDimValue(er,en){er.addFieldInt64(1,en,er.createLong(0,0))}static addDimParam(er,en){er.addFieldOffset(2,en,0)}static endDimensionValue(er){return er.endObject()}static createDimensionValue(er,en,eo,ea){return ei.startDimensionValue(er),ei.addDimType(er,en),ei.addDimValue(er,eo),ei.addDimParam(er,ea),ei.endDimensionValue(er)}}en.DimensionValue=ei}(en.fbs||(en.fbs={}))}(er.experimental||(er.experimental={}))}(en.onnxruntime||(en.onnxruntime={})),function(er){!function(en){!function(en){class ei{constructor(){this.bb=null,this.bb_pos=0}__init(er,en){return this.bb_pos=er,this.bb=en,this}static getRootAsTensorTypeAndShape(er,en){return(en||new ei).__init(er.readInt32(er.position())+er.position(),er)}static getSizePrefixedRootAsTensorTypeAndShape(er,en){return er.setPosition(er.position()+es.flatbuffers.SIZE_PREFIX_LENGTH),(en||new ei).__init(er.readInt32(er.position())+er.position(),er)}elemType(){let en=this.bb.__offset(this.bb_pos,4);return en?this.bb.readInt32(this.bb_pos+en):er.experimental.fbs.TensorDataType.UNDEFINED}shape(en){let ei=this.bb.__offset(this.bb_pos,6);return ei?(en||new er.experimental.fbs.Shape).__init(this.bb.__indirect(this.bb_pos+ei),this.bb):null}static startTensorTypeAndShape(er){er.startObject(2)}static addElemType(en,ei){en.addFieldInt32(0,ei,er.experimental.fbs.TensorDataType.UNDEFINED)}static addShape(er,en){er.addFieldOffset(1,en,0)}static endTensorTypeAndShape(er){return er.endObject()}static createTensorTypeAndShape(er,en,eo){return ei.startTensorTypeAndShape(er),ei.addElemType(er,en),ei.addShape(er,eo),ei.endTensorTypeAndShape(er)}}en.TensorTypeAndShape=ei}(en.fbs||(en.fbs={}))}(er.experimental||(er.experimental={}))}(en.onnxruntime||(en.onnxruntime={})),function(er){!function(en){!function(en){class ei{constructor(){this.bb=null,this.bb_pos=0}__init(er,en){return this.bb_pos=er,this.bb=en,this}static getRootAsMapType(er,en){return(en||new ei).__init(er.readInt32(er.position())+er.position(),er)}static getSizePrefixedRootAsMapType(er,en){return er.setPosition(er.position()+es.flatbuffers.SIZE_PREFIX_LENGTH),(en||new ei).__init(er.readInt32(er.position())+er.position(),er)}keyType(){let en=this.bb.__offset(this.bb_pos,4);return en?this.bb.readInt32(this.bb_pos+en):er.experimental.fbs.TensorDataType.UNDEFINED}valueType(en){let ei=this.bb.__offset(this.bb_pos,6);return ei?(en||new er.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+ei),this.bb):null}static startMapType(er){er.startObject(2)}static addKeyType(en,ei){en.addFieldInt32(0,ei,er.experimental.fbs.TensorDataType.UNDEFINED)}static addValueType(er,en){er.addFieldOffset(1,en,0)}static endMapType(er){return er.endObject()}static createMapType(er,en,eo){return ei.startMapType(er),ei.addKeyType(er,en),ei.addValueType(er,eo),ei.endMapType(er)}}en.MapType=ei}(en.fbs||(en.fbs={}))}(er.experimental||(er.experimental={}))}(en.onnxruntime||(en.onnxruntime={})),function(er){!function(en){!function(en){class ei{constructor(){this.bb=null,this.bb_pos=0}__init(er,en){return this.bb_pos=er,this.bb=en,this}static getRootAsSequenceType(er,en){return(en||new ei).__init(er.readInt32(er.position())+er.position(),er)}static getSizePrefixedRootAsSequenceType(er,en){return er.setPosition(er.position()+es.flatbuffers.SIZE_PREFIX_LENGTH),(en||new ei).__init(er.readInt32(er.position())+er.position(),er)}elemType(en){let ei=this.bb.__offset(this.bb_pos,4);return ei?(en||new er.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+ei),this.bb):null}static startSequenceType(er){er.startObject(1)}static addElemType(er,en){er.addFieldOffset(0,en,0)}static endSequenceType(er){return er.endObject()}static createSequenceType(er,en){return ei.startSequenceType(er),ei.addElemType(er,en),ei.endSequenceType(er)}}en.SequenceType=ei}(en.fbs||(en.fbs={}))}(er.experimental||(er.experimental={}))}(en.onnxruntime||(en.onnxruntime={})),function(er){!function(er){(er.fbs||(er.fbs={})).EdgeEnd=class{constructor(){this.bb=null,this.bb_pos=0}__init(er,en){return this.bb_pos=er,this.bb=en,this}nodeIndex(){return this.bb.readUint32(this.bb_pos)}srcArgIndex(){return this.bb.readInt32(this.bb_pos+4)}dstArgIndex(){return this.bb.readInt32(this.bb_pos+8)}static createEdgeEnd(er,en,ei,eo){return er.prep(4,12),er.writeInt32(eo),er.writeInt32(ei),er.writeInt32(en),er.offset()}}}(er.experimental||(er.experimental={}))}(en.onnxruntime||(en.onnxruntime={})),function(er){!function(en){!function(en){class ei{constructor(){this.bb=null,this.bb_pos=0}__init(er,en){return this.bb_pos=er,this.bb=en,this}static getRootAsNodeEdge(er,en){return(en||new ei).__init(er.readInt32(er.position())+er.position(),er)}static getSizePrefixedRootAsNodeEdge(er,en){return er.setPosition(er.position()+es.flatbuffers.SIZE_PREFIX_LENGTH),(en||new ei).__init(er.readInt32(er.position())+er.position(),er)}nodeIndex(){let er=this.bb.__offset(this.bb_pos,4);return er?this.bb.readUint32(this.bb_pos+er):0}inputEdges(en,ei){let eo=this.bb.__offset(this.bb_pos,6);return eo?(ei||new er.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+eo)+12*en,this.bb):null}inputEdgesLength(){let er=this.bb.__offset(this.bb_pos,6);return er?this.bb.__vector_len(this.bb_pos+er):0}outputEdges(en,ei){let eo=this.bb.__offset(this.bb_pos,8);return eo?(ei||new er.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+eo)+12*en,this.bb):null}outputEdgesLength(){let er=this.bb.__offset(this.bb_pos,8);return er?this.bb.__vector_len(this.bb_pos+er):0}static startNodeEdge(er){er.startObject(3)}static addNodeIndex(er,en){er.addFieldInt32(0,en,0)}static addInputEdges(er,en){er.addFieldOffset(1,en,0)}static startInputEdgesVector(er,en){er.startVector(12,en,4)}static addOutputEdges(er,en){er.addFieldOffset(2,en,0)}static startOutputEdgesVector(er,en){er.startVector(12,en,4)}static endNodeEdge(er){return er.endObject()}static createNodeEdge(er,en,eo,ea){return ei.startNodeEdge(er),ei.addNodeIndex(er,en),ei.addInputEdges(er,eo),ei.addOutputEdges(er,ea),ei.endNodeEdge(er)}}en.NodeEdge=ei}(en.fbs||(en.fbs={}))}(er.experimental||(er.experimental={}))}(en.onnxruntime||(en.onnxruntime={})),function(er){!function(en){!function(en){class ei{constructor(){this.bb=null,this.bb_pos=0}__init(er,en){return this.bb_pos=er,this.bb=en,this}static getRootAsNode(er,en){return(en||new ei).__init(er.readInt32(er.position())+er.position(),er)}static getSizePrefixedRootAsNode(er,en){return er.setPosition(er.position()+es.flatbuffers.SIZE_PREFIX_LENGTH),(en||new ei).__init(er.readInt32(er.position())+er.position(),er)}name(er){let en=this.bb.__offset(this.bb_pos,4);return en?this.bb.__string(this.bb_pos+en,er):null}docString(er){let en=this.bb.__offset(this.bb_pos,6);return en?this.bb.__string(this.bb_pos+en,er):null}domain(er){let en=this.bb.__offset(this.bb_pos,8);return en?this.bb.__string(this.bb_pos+en,er):null}sinceVersion(){let er=this.bb.__offset(this.bb_pos,10);return er?this.bb.readInt32(this.bb_pos+er):0}index(){let er=this.bb.__offset(this.bb_pos,12);return er?this.bb.readUint32(this.bb_pos+er):0}opType(er){let en=this.bb.__offset(this.bb_pos,14);return en?this.bb.__string(this.bb_pos+en,er):null}type(){let en=this.bb.__offset(this.bb_pos,16);return en?this.bb.readInt32(this.bb_pos+en):er.experimental.fbs.NodeType.Primitive}executionProviderType(er){let en=this.bb.__offset(this.bb_pos,18);return en?this.bb.__string(this.bb_pos+en,er):null}inputs(er,en){let ei=this.bb.__offset(this.bb_pos,20);return ei?this.bb.__string(this.bb.__vector(this.bb_pos+ei)+4*er,en):null}inputsLength(){let er=this.bb.__offset(this.bb_pos,20);return er?this.bb.__vector_len(this.bb_pos+er):0}outputs(er,en){let ei=this.bb.__offset(this.bb_pos,22);return ei?this.bb.__string(this.bb.__vector(this.bb_pos+ei)+4*er,en):null}outputsLength(){let er=this.bb.__offset(this.bb_pos,22);return er?this.bb.__vector_len(this.bb_pos+er):0}attributes(en,ei){let eo=this.bb.__offset(this.bb_pos,24);return eo?(ei||new er.experimental.fbs.Attribute).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+eo)+4*en),this.bb):null}attributesLength(){let er=this.bb.__offset(this.bb_pos,24);return er?this.bb.__vector_len(this.bb_pos+er):0}inputArgCounts(er){let en=this.bb.__offset(this.bb_pos,26);return en?this.bb.readInt32(this.bb.__vector(this.bb_pos+en)+4*er):0}inputArgCountsLength(){let er=this.bb.__offset(this.bb_pos,26);return er?this.bb.__vector_len(this.bb_pos+er):0}inputArgCountsArray(){let er=this.bb.__offset(this.bb_pos,26);return er?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+er),this.bb.__vector_len(this.bb_pos+er)):null}implicitInputs(er,en){let ei=this.bb.__offset(this.bb_pos,28);return ei?this.bb.__string(this.bb.__vector(this.bb_pos+ei)+4*er,en):null}implicitInputsLength(){let er=this.bb.__offset(this.bb_pos,28);return er?this.bb.__vector_len(this.bb_pos+er):0}static startNode(er){er.startObject(13)}static addName(er,en){er.addFieldOffset(0,en,0)}static addDocString(er,en){er.addFieldOffset(1,en,0)}static addDomain(er,en){er.addFieldOffset(2,en,0)}static addSinceVersion(er,en){er.addFieldInt32(3,en,0)}static addIndex(er,en){er.addFieldInt32(4,en,0)}static addOpType(er,en){er.addFieldOffset(5,en,0)}static addType(en,ei){en.addFieldInt32(6,ei,er.experimental.fbs.NodeType.Primitive)}static addExecutionProviderType(er,en){er.addFieldOffset(7,en,0)}static addInputs(er,en){er.addFieldOffset(8,en,0)}static createInputsVector(er,en){er.startVector(4,en.length,4);for(let ei=en.length-1;ei>=0;ei--)er.addOffset(en[ei]);return er.endVector()}static startInputsVector(er,en){er.startVector(4,en,4)}static addOutputs(er,en){er.addFieldOffset(9,en,0)}static createOutputsVector(er,en){er.startVector(4,en.length,4);for(let ei=en.length-1;ei>=0;ei--)er.addOffset(en[ei]);return er.endVector()}static startOutputsVector(er,en){er.startVector(4,en,4)}static addAttributes(er,en){er.addFieldOffset(10,en,0)}static createAttributesVector(er,en){er.startVector(4,en.length,4);for(let ei=en.length-1;ei>=0;ei--)er.addOffset(en[ei]);return er.endVector()}static startAttributesVector(er,en){er.startVector(4,en,4)}static addInputArgCounts(er,en){er.addFieldOffset(11,en,0)}static createInputArgCountsVector(er,en){er.startVector(4,en.length,4);for(let ei=en.length-1;ei>=0;ei--)er.addInt32(en[ei]);return er.endVector()}static startInputArgCountsVector(er,en){er.startVector(4,en,4)}static addImplicitInputs(er,en){er.addFieldOffset(12,en,0)}static createImplicitInputsVector(er,en){er.startVector(4,en.length,4);for(let ei=en.length-1;ei>=0;ei--)er.addOffset(en[ei]);return er.endVector()}static startImplicitInputsVector(er,en){er.startVector(4,en,4)}static endNode(er){return er.endObject()}static createNode(er,en,eo,ea,es,eu,el,ec,ep,ed,ef,eh,eg,em){return ei.startNode(er),ei.addName(er,en),ei.addDocString(er,eo),ei.addDomain(er,ea),ei.addSinceVersion(er,es),ei.addIndex(er,eu),ei.addOpType(er,el),ei.addType(er,ec),ei.addExecutionProviderType(er,ep),ei.addInputs(er,ed),ei.addOutputs(er,ef),ei.addAttributes(er,eh),ei.addInputArgCounts(er,eg),ei.addImplicitInputs(er,em),ei.endNode(er)}}en.Node=ei}(en.fbs||(en.fbs={}))}(er.experimental||(er.experimental={}))}(en.onnxruntime||(en.onnxruntime={})),function(er){!function(en){!function(en){class ei{constructor(){this.bb=null,this.bb_pos=0}__init(er,en){return this.bb_pos=er,this.bb=en,this}static getRootAsValueInfo(er,en){return(en||new ei).__init(er.readInt32(er.position())+er.position(),er)}static getSizePrefixedRootAsValueInfo(er,en){return er.setPosition(er.position()+es.flatbuffers.SIZE_PREFIX_LENGTH),(en||new ei).__init(er.readInt32(er.position())+er.position(),er)}name(er){let en=this.bb.__offset(this.bb_pos,4);return en?this.bb.__string(this.bb_pos+en,er):null}docString(er){let en=this.bb.__offset(this.bb_pos,6);return en?this.bb.__string(this.bb_pos+en,er):null}type(en){let ei=this.bb.__offset(this.bb_pos,8);return ei?(en||new er.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+ei),this.bb):null}static startValueInfo(er){er.startObject(3)}static addName(er,en){er.addFieldOffset(0,en,0)}static addDocString(er,en){er.addFieldOffset(1,en,0)}static addType(er,en){er.addFieldOffset(2,en,0)}static endValueInfo(er){return er.endObject()}static createValueInfo(er,en,eo,ea){return ei.startValueInfo(er),ei.addName(er,en),ei.addDocString(er,eo),ei.addType(er,ea),ei.endValueInfo(er)}}en.ValueInfo=ei}(en.fbs||(en.fbs={}))}(er.experimental||(er.experimental={}))}(en.onnxruntime||(en.onnxruntime={})),function(er){!function(en){!function(en){class ei{constructor(){this.bb=null,this.bb_pos=0}__init(er,en){return this.bb_pos=er,this.bb=en,this}static getRootAsTypeInfo(er,en){return(en||new ei).__init(er.readInt32(er.position())+er.position(),er)}static getSizePrefixedRootAsTypeInfo(er,en){return er.setPosition(er.position()+es.flatbuffers.SIZE_PREFIX_LENGTH),(en||new ei).__init(er.readInt32(er.position())+er.position(),er)}denotation(er){let en=this.bb.__offset(this.bb_pos,4);return en?this.bb.__string(this.bb_pos+en,er):null}valueType(){let en=this.bb.__offset(this.bb_pos,6);return en?this.bb.readUint8(this.bb_pos+en):er.experimental.fbs.TypeInfoValue.NONE}value(er){let en=this.bb.__offset(this.bb_pos,8);return en?this.bb.__union(er,this.bb_pos+en):null}static startTypeInfo(er){er.startObject(3)}static addDenotation(er,en){er.addFieldOffset(0,en,0)}static addValueType(en,ei){en.addFieldInt8(1,ei,er.experimental.fbs.TypeInfoValue.NONE)}static addValue(er,en){er.addFieldOffset(2,en,0)}static endTypeInfo(er){return er.endObject()}static createTypeInfo(er,en,eo,ea){return ei.startTypeInfo(er),ei.addDenotation(er,en),ei.addValueType(er,eo),ei.addValue(er,ea),ei.endTypeInfo(er)}}en.TypeInfo=ei}(en.fbs||(en.fbs={}))}(er.experimental||(er.experimental={}))}(en.onnxruntime||(en.onnxruntime={})),function(er){!function(er){!function(er){class en{constructor(){this.bb=null,this.bb_pos=0}__init(er,en){return this.bb_pos=er,this.bb=en,this}static getRootAsOperatorSetId(er,ei){return(ei||new en).__init(er.readInt32(er.position())+er.position(),er)}static getSizePrefixedRootAsOperatorSetId(er,ei){return er.setPosition(er.position()+es.flatbuffers.SIZE_PREFIX_LENGTH),(ei||new en).__init(er.readInt32(er.position())+er.position(),er)}domain(er){let en=this.bb.__offset(this.bb_pos,4);return en?this.bb.__string(this.bb_pos+en,er):null}version(){let er=this.bb.__offset(this.bb_pos,6);return er?this.bb.readInt64(this.bb_pos+er):this.bb.createLong(0,0)}static startOperatorSetId(er){er.startObject(2)}static addDomain(er,en){er.addFieldOffset(0,en,0)}static addVersion(er,en){er.addFieldInt64(1,en,er.createLong(0,0))}static endOperatorSetId(er){return er.endObject()}static createOperatorSetId(er,ei,eo){return en.startOperatorSetId(er),en.addDomain(er,ei),en.addVersion(er,eo),en.endOperatorSetId(er)}}er.OperatorSetId=en}(er.fbs||(er.fbs={}))}(er.experimental||(er.experimental={}))}(en.onnxruntime||(en.onnxruntime={})),function(er){!function(en){!function(en){class ei{constructor(){this.bb=null,this.bb_pos=0}__init(er,en){return this.bb_pos=er,this.bb=en,this}static getRootAsTensor(er,en){return(en||new ei).__init(er.readInt32(er.position())+er.position(),er)}static getSizePrefixedRootAsTensor(er,en){return er.setPosition(er.position()+es.flatbuffers.SIZE_PREFIX_LENGTH),(en||new ei).__init(er.readInt32(er.position())+er.position(),er)}name(er){let en=this.bb.__offset(this.bb_pos,4);return en?this.bb.__string(this.bb_pos+en,er):null}docString(er){let en=this.bb.__offset(this.bb_pos,6);return en?this.bb.__string(this.bb_pos+en,er):null}dims(er){let en=this.bb.__offset(this.bb_pos,8);return en?this.bb.readInt64(this.bb.__vector(this.bb_pos+en)+8*er):this.bb.createLong(0,0)}dimsLength(){let er=this.bb.__offset(this.bb_pos,8);return er?this.bb.__vector_len(this.bb_pos+er):0}dataType(){let en=this.bb.__offset(this.bb_pos,10);return en?this.bb.readInt32(this.bb_pos+en):er.experimental.fbs.TensorDataType.UNDEFINED}rawData(er){let en=this.bb.__offset(this.bb_pos,12);return en?this.bb.readUint8(this.bb.__vector(this.bb_pos+en)+er):0}rawDataLength(){let er=this.bb.__offset(this.bb_pos,12);return er?this.bb.__vector_len(this.bb_pos+er):0}rawDataArray(){let er=this.bb.__offset(this.bb_pos,12);return er?new Uint8Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+er),this.bb.__vector_len(this.bb_pos+er)):null}stringData(er,en){let ei=this.bb.__offset(this.bb_pos,14);return ei?this.bb.__string(this.bb.__vector(this.bb_pos+ei)+4*er,en):null}stringDataLength(){let er=this.bb.__offset(this.bb_pos,14);return er?this.bb.__vector_len(this.bb_pos+er):0}static startTensor(er){er.startObject(6)}static addName(er,en){er.addFieldOffset(0,en,0)}static addDocString(er,en){er.addFieldOffset(1,en,0)}static addDims(er,en){er.addFieldOffset(2,en,0)}static createDimsVector(er,en){er.startVector(8,en.length,8);for(let ei=en.length-1;ei>=0;ei--)er.addInt64(en[ei]);return er.endVector()}static startDimsVector(er,en){er.startVector(8,en,8)}static addDataType(en,ei){en.addFieldInt32(3,ei,er.experimental.fbs.TensorDataType.UNDEFINED)}static addRawData(er,en){er.addFieldOffset(4,en,0)}static createRawDataVector(er,en){er.startVector(1,en.length,1);for(let ei=en.length-1;ei>=0;ei--)er.addInt8(en[ei]);return er.endVector()}static startRawDataVector(er,en){er.startVector(1,en,1)}static addStringData(er,en){er.addFieldOffset(5,en,0)}static createStringDataVector(er,en){er.startVector(4,en.length,4);for(let ei=en.length-1;ei>=0;ei--)er.addOffset(en[ei]);return er.endVector()}static startStringDataVector(er,en){er.startVector(4,en,4)}static endTensor(er){return er.endObject()}static createTensor(er,en,eo,ea,es,eu,el){return ei.startTensor(er),ei.addName(er,en),ei.addDocString(er,eo),ei.addDims(er,ea),ei.addDataType(er,es),ei.addRawData(er,eu),ei.addStringData(er,el),ei.endTensor(er)}}en.Tensor=ei}(en.fbs||(en.fbs={}))}(er.experimental||(er.experimental={}))}(en.onnxruntime||(en.onnxruntime={})),function(er){!function(en){!function(en){class ei{constructor(){this.bb=null,this.bb_pos=0}__init(er,en){return this.bb_pos=er,this.bb=en,this}static getRootAsSparseTensor(er,en){return(en||new ei).__init(er.readInt32(er.position())+er.position(),er)}static getSizePrefixedRootAsSparseTensor(er,en){return er.setPosition(er.position()+es.flatbuffers.SIZE_PREFIX_LENGTH),(en||new ei).__init(er.readInt32(er.position())+er.position(),er)}values(en){let ei=this.bb.__offset(this.bb_pos,4);return ei?(en||new er.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+ei),this.bb):null}indices(en){let ei=this.bb.__offset(this.bb_pos,6);return ei?(en||new er.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+ei),this.bb):null}dims(er){let en=this.bb.__offset(this.bb_pos,8);return en?this.bb.readInt64(this.bb.__vector(this.bb_pos+en)+8*er):this.bb.createLong(0,0)}dimsLength(){let er=this.bb.__offset(this.bb_pos,8);return er?this.bb.__vector_len(this.bb_pos+er):0}static startSparseTensor(er){er.startObject(3)}static addValues(er,en){er.addFieldOffset(0,en,0)}static addIndices(er,en){er.addFieldOffset(1,en,0)}static addDims(er,en){er.addFieldOffset(2,en,0)}static createDimsVector(er,en){er.startVector(8,en.length,8);for(let ei=en.length-1;ei>=0;ei--)er.addInt64(en[ei]);return er.endVector()}static startDimsVector(er,en){er.startVector(8,en,8)}static endSparseTensor(er){return er.endObject()}static createSparseTensor(er,en,eo,ea){return ei.startSparseTensor(er),ei.addValues(er,en),ei.addIndices(er,eo),ei.addDims(er,ea),ei.endSparseTensor(er)}}en.SparseTensor=ei}(en.fbs||(en.fbs={}))}(er.experimental||(er.experimental={}))}(en.onnxruntime||(en.onnxruntime={})),function(er){!function(en){!function(en){class ei{constructor(){this.bb=null,this.bb_pos=0}__init(er,en){return this.bb_pos=er,this.bb=en,this}static getRootAsAttribute(er,en){return(en||new ei).__init(er.readInt32(er.position())+er.position(),er)}static getSizePrefixedRootAsAttribute(er,en){return er.setPosition(er.position()+es.flatbuffers.SIZE_PREFIX_LENGTH),(en||new ei).__init(er.readInt32(er.position())+er.position(),er)}name(er){let en=this.bb.__offset(this.bb_pos,4);return en?this.bb.__string(this.bb_pos+en,er):null}docString(er){let en=this.bb.__offset(this.bb_pos,6);return en?this.bb.__string(this.bb_pos+en,er):null}type(){let en=this.bb.__offset(this.bb_pos,8);return en?this.bb.readInt32(this.bb_pos+en):er.experimental.fbs.AttributeType.UNDEFINED}f(){let er=this.bb.__offset(this.bb_pos,10);return er?this.bb.readFloat32(this.bb_pos+er):0}i(){let er=this.bb.__offset(this.bb_pos,12);return er?this.bb.readInt64(this.bb_pos+er):this.bb.createLong(0,0)}s(er){let en=this.bb.__offset(this.bb_pos,14);return en?this.bb.__string(this.bb_pos+en,er):null}t(en){let ei=this.bb.__offset(this.bb_pos,16);return ei?(en||new er.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+ei),this.bb):null}g(en){let ei=this.bb.__offset(this.bb_pos,18);return ei?(en||new er.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+ei),this.bb):null}floats(er){let en=this.bb.__offset(this.bb_pos,20);return en?this.bb.readFloat32(this.bb.__vector(this.bb_pos+en)+4*er):0}floatsLength(){let er=this.bb.__offset(this.bb_pos,20);return er?this.bb.__vector_len(this.bb_pos+er):0}floatsArray(){let er=this.bb.__offset(this.bb_pos,20);return er?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+er),this.bb.__vector_len(this.bb_pos+er)):null}ints(er){let en=this.bb.__offset(this.bb_pos,22);return en?this.bb.readInt64(this.bb.__vector(this.bb_pos+en)+8*er):this.bb.createLong(0,0)}intsLength(){let er=this.bb.__offset(this.bb_pos,22);return er?this.bb.__vector_len(this.bb_pos+er):0}strings(er,en){let ei=this.bb.__offset(this.bb_pos,24);return ei?this.bb.__string(this.bb.__vector(this.bb_pos+ei)+4*er,en):null}stringsLength(){let er=this.bb.__offset(this.bb_pos,24);return er?this.bb.__vector_len(this.bb_pos+er):0}tensors(en,ei){let eo=this.bb.__offset(this.bb_pos,26);return eo?(ei||new er.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+eo)+4*en),this.bb):null}tensorsLength(){let er=this.bb.__offset(this.bb_pos,26);return er?this.bb.__vector_len(this.bb_pos+er):0}graphs(en,ei){let eo=this.bb.__offset(this.bb_pos,28);return eo?(ei||new er.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+eo)+4*en),this.bb):null}graphsLength(){let er=this.bb.__offset(this.bb_pos,28);return er?this.bb.__vector_len(this.bb_pos+er):0}static startAttribute(er){er.startObject(13)}static addName(er,en){er.addFieldOffset(0,en,0)}static addDocString(er,en){er.addFieldOffset(1,en,0)}static addType(en,ei){en.addFieldInt32(2,ei,er.experimental.fbs.AttributeType.UNDEFINED)}static addF(er,en){er.addFieldFloat32(3,en,0)}static addI(er,en){er.addFieldInt64(4,en,er.createLong(0,0))}static addS(er,en){er.addFieldOffset(5,en,0)}static addT(er,en){er.addFieldOffset(6,en,0)}static addG(er,en){er.addFieldOffset(7,en,0)}static addFloats(er,en){er.addFieldOffset(8,en,0)}static createFloatsVector(er,en){er.startVector(4,en.length,4);for(let ei=en.length-1;ei>=0;ei--)er.addFloat32(en[ei]);return er.endVector()}static startFloatsVector(er,en){er.startVector(4,en,4)}static addInts(er,en){er.addFieldOffset(9,en,0)}static createIntsVector(er,en){er.startVector(8,en.length,8);for(let ei=en.length-1;ei>=0;ei--)er.addInt64(en[ei]);return er.endVector()}static startIntsVector(er,en){er.startVector(8,en,8)}static addStrings(er,en){er.addFieldOffset(10,en,0)}static createStringsVector(er,en){er.startVector(4,en.length,4);for(let ei=en.length-1;ei>=0;ei--)er.addOffset(en[ei]);return er.endVector()}static startStringsVector(er,en){er.startVector(4,en,4)}static addTensors(er,en){er.addFieldOffset(11,en,0)}static createTensorsVector(er,en){er.startVector(4,en.length,4);for(let ei=en.length-1;ei>=0;ei--)er.addOffset(en[ei]);return er.endVector()}static startTensorsVector(er,en){er.startVector(4,en,4)}static addGraphs(er,en){er.addFieldOffset(12,en,0)}static createGraphsVector(er,en){er.startVector(4,en.length,4);for(let ei=en.length-1;ei>=0;ei--)er.addOffset(en[ei]);return er.endVector()}static startGraphsVector(er,en){er.startVector(4,en,4)}static endAttribute(er){return er.endObject()}static createAttribute(er,en,eo,ea,es,eu,el,ec,ep,ed,ef,eh,eg,em){return ei.startAttribute(er),ei.addName(er,en),ei.addDocString(er,eo),ei.addType(er,ea),ei.addF(er,es),ei.addI(er,eu),ei.addS(er,el),ei.addT(er,ec),ei.addG(er,ep),ei.addFloats(er,ed),ei.addInts(er,ef),ei.addStrings(er,eh),ei.addTensors(er,eg),ei.addGraphs(er,em),ei.endAttribute(er)}}en.Attribute=ei}(en.fbs||(en.fbs={}))}(er.experimental||(er.experimental={}))}(en.onnxruntime||(en.onnxruntime={})),function(er){!function(en){!function(en){class ei{constructor(){this.bb=null,this.bb_pos=0}__init(er,en){return this.bb_pos=er,this.bb=en,this}static getRootAsGraph(er,en){return(en||new ei).__init(er.readInt32(er.position())+er.position(),er)}static getSizePrefixedRootAsGraph(er,en){return er.setPosition(er.position()+es.flatbuffers.SIZE_PREFIX_LENGTH),(en||new ei).__init(er.readInt32(er.position())+er.position(),er)}initializers(en,ei){let eo=this.bb.__offset(this.bb_pos,4);return eo?(ei||new er.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+eo)+4*en),this.bb):null}initializersLength(){let er=this.bb.__offset(this.bb_pos,4);return er?this.bb.__vector_len(this.bb_pos+er):0}nodeArgs(en,ei){let eo=this.bb.__offset(this.bb_pos,6);return eo?(ei||new er.experimental.fbs.ValueInfo).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+eo)+4*en),this.bb):null}nodeArgsLength(){let er=this.bb.__offset(this.bb_pos,6);return er?this.bb.__vector_len(this.bb_pos+er):0}nodes(en,ei){let eo=this.bb.__offset(this.bb_pos,8);return eo?(ei||new er.experimental.fbs.Node).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+eo)+4*en),this.bb):null}nodesLength(){let er=this.bb.__offset(this.bb_pos,8);return er?this.bb.__vector_len(this.bb_pos+er):0}maxNodeIndex(){let er=this.bb.__offset(this.bb_pos,10);return er?this.bb.readUint32(this.bb_pos+er):0}nodeEdges(en,ei){let eo=this.bb.__offset(this.bb_pos,12);return eo?(ei||new er.experimental.fbs.NodeEdge).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+eo)+4*en),this.bb):null}nodeEdgesLength(){let er=this.bb.__offset(this.bb_pos,12);return er?this.bb.__vector_len(this.bb_pos+er):0}inputs(er,en){let ei=this.bb.__offset(this.bb_pos,14);return ei?this.bb.__string(this.bb.__vector(this.bb_pos+ei)+4*er,en):null}inputsLength(){let er=this.bb.__offset(this.bb_pos,14);return er?this.bb.__vector_len(this.bb_pos+er):0}outputs(er,en){let ei=this.bb.__offset(this.bb_pos,16);return ei?this.bb.__string(this.bb.__vector(this.bb_pos+ei)+4*er,en):null}outputsLength(){let er=this.bb.__offset(this.bb_pos,16);return er?this.bb.__vector_len(this.bb_pos+er):0}sparseInitializers(en,ei){let eo=this.bb.__offset(this.bb_pos,18);return eo?(ei||new er.experimental.fbs.SparseTensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+eo)+4*en),this.bb):null}sparseInitializersLength(){let er=this.bb.__offset(this.bb_pos,18);return er?this.bb.__vector_len(this.bb_pos+er):0}static startGraph(er){er.startObject(8)}static addInitializers(er,en){er.addFieldOffset(0,en,0)}static createInitializersVector(er,en){er.startVector(4,en.length,4);for(let ei=en.length-1;ei>=0;ei--)er.addOffset(en[ei]);return er.endVector()}static startInitializersVector(er,en){er.startVector(4,en,4)}static addNodeArgs(er,en){er.addFieldOffset(1,en,0)}static createNodeArgsVector(er,en){er.startVector(4,en.length,4);for(let ei=en.length-1;ei>=0;ei--)er.addOffset(en[ei]);return er.endVector()}static startNodeArgsVector(er,en){er.startVector(4,en,4)}static addNodes(er,en){er.addFieldOffset(2,en,0)}static createNodesVector(er,en){er.startVector(4,en.length,4);for(let ei=en.length-1;ei>=0;ei--)er.addOffset(en[ei]);return er.endVector()}static startNodesVector(er,en){er.startVector(4,en,4)}static addMaxNodeIndex(er,en){er.addFieldInt32(3,en,0)}static addNodeEdges(er,en){er.addFieldOffset(4,en,0)}static createNodeEdgesVector(er,en){er.startVector(4,en.length,4);for(let ei=en.length-1;ei>=0;ei--)er.addOffset(en[ei]);return er.endVector()}static startNodeEdgesVector(er,en){er.startVector(4,en,4)}static addInputs(er,en){er.addFieldOffset(5,en,0)}static createInputsVector(er,en){er.startVector(4,en.length,4);for(let ei=en.length-1;ei>=0;ei--)er.addOffset(en[ei]);return er.endVector()}static startInputsVector(er,en){er.startVector(4,en,4)}static addOutputs(er,en){er.addFieldOffset(6,en,0)}static createOutputsVector(er,en){er.startVector(4,en.length,4);for(let ei=en.length-1;ei>=0;ei--)er.addOffset(en[ei]);return er.endVector()}static startOutputsVector(er,en){er.startVector(4,en,4)}static addSparseInitializers(er,en){er.addFieldOffset(7,en,0)}static createSparseInitializersVector(er,en){er.startVector(4,en.length,4);for(let ei=en.length-1;ei>=0;ei--)er.addOffset(en[ei]);return er.endVector()}static startSparseInitializersVector(er,en){er.startVector(4,en,4)}static endGraph(er){return er.endObject()}static createGraph(er,en,eo,ea,es,eu,el,ec,ep){return ei.startGraph(er),ei.addInitializers(er,en),ei.addNodeArgs(er,eo),ei.addNodes(er,ea),ei.addMaxNodeIndex(er,es),ei.addNodeEdges(er,eu),ei.addInputs(er,el),ei.addOutputs(er,ec),ei.addSparseInitializers(er,ep),ei.endGraph(er)}}en.Graph=ei}(en.fbs||(en.fbs={}))}(er.experimental||(er.experimental={}))}(en.onnxruntime||(en.onnxruntime={})),function(er){!function(en){!function(en){class ei{constructor(){this.bb=null,this.bb_pos=0}__init(er,en){return this.bb_pos=er,this.bb=en,this}static getRootAsModel(er,en){return(en||new ei).__init(er.readInt32(er.position())+er.position(),er)}static getSizePrefixedRootAsModel(er,en){return er.setPosition(er.position()+es.flatbuffers.SIZE_PREFIX_LENGTH),(en||new ei).__init(er.readInt32(er.position())+er.position(),er)}irVersion(){let er=this.bb.__offset(this.bb_pos,4);return er?this.bb.readInt64(this.bb_pos+er):this.bb.createLong(0,0)}opsetImport(en,ei){let eo=this.bb.__offset(this.bb_pos,6);return eo?(ei||new er.experimental.fbs.OperatorSetId).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+eo)+4*en),this.bb):null}opsetImportLength(){let er=this.bb.__offset(this.bb_pos,6);return er?this.bb.__vector_len(this.bb_pos+er):0}producerName(er){let en=this.bb.__offset(this.bb_pos,8);return en?this.bb.__string(this.bb_pos+en,er):null}producerVersion(er){let en=this.bb.__offset(this.bb_pos,10);return en?this.bb.__string(this.bb_pos+en,er):null}domain(er){let en=this.bb.__offset(this.bb_pos,12);return en?this.bb.__string(this.bb_pos+en,er):null}modelVersion(){let er=this.bb.__offset(this.bb_pos,14);return er?this.bb.readInt64(this.bb_pos+er):this.bb.createLong(0,0)}docString(er){let en=this.bb.__offset(this.bb_pos,16);return en?this.bb.__string(this.bb_pos+en,er):null}graph(en){let ei=this.bb.__offset(this.bb_pos,18);return ei?(en||new er.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+ei),this.bb):null}graphDocString(er){let en=this.bb.__offset(this.bb_pos,20);return en?this.bb.__string(this.bb_pos+en,er):null}static startModel(er){er.startObject(9)}static addIrVersion(er,en){er.addFieldInt64(0,en,er.createLong(0,0))}static addOpsetImport(er,en){er.addFieldOffset(1,en,0)}static createOpsetImportVector(er,en){er.startVector(4,en.length,4);for(let ei=en.length-1;ei>=0;ei--)er.addOffset(en[ei]);return er.endVector()}static startOpsetImportVector(er,en){er.startVector(4,en,4)}static addProducerName(er,en){er.addFieldOffset(2,en,0)}static addProducerVersion(er,en){er.addFieldOffset(3,en,0)}static addDomain(er,en){er.addFieldOffset(4,en,0)}static addModelVersion(er,en){er.addFieldInt64(5,en,er.createLong(0,0))}static addDocString(er,en){er.addFieldOffset(6,en,0)}static addGraph(er,en){er.addFieldOffset(7,en,0)}static addGraphDocString(er,en){er.addFieldOffset(8,en,0)}static endModel(er){return er.endObject()}static createModel(er,en,eo,ea,es,eu,el,ec,ep,ed){return ei.startModel(er),ei.addIrVersion(er,en),ei.addOpsetImport(er,eo),ei.addProducerName(er,ea),ei.addProducerVersion(er,es),ei.addDomain(er,eu),ei.addModelVersion(er,el),ei.addDocString(er,ec),ei.addGraph(er,ep),ei.addGraphDocString(er,ed),ei.endModel(er)}}en.Model=ei}(en.fbs||(en.fbs={}))}(er.experimental||(er.experimental={}))}(en.onnxruntime||(en.onnxruntime={})),function(er){!function(er){!function(er){class en{constructor(){this.bb=null,this.bb_pos=0}__init(er,en){return this.bb_pos=er,this.bb=en,this}static getRootAsKernelCreateInfos(er,ei){return(ei||new en).__init(er.readInt32(er.position())+er.position(),er)}static getSizePrefixedRootAsKernelCreateInfos(er,ei){return er.setPosition(er.position()+es.flatbuffers.SIZE_PREFIX_LENGTH),(ei||new en).__init(er.readInt32(er.position())+er.position(),er)}nodeIndices(er){let en=this.bb.__offset(this.bb_pos,4);return en?this.bb.readUint32(this.bb.__vector(this.bb_pos+en)+4*er):0}nodeIndicesLength(){let er=this.bb.__offset(this.bb_pos,4);return er?this.bb.__vector_len(this.bb_pos+er):0}nodeIndicesArray(){let er=this.bb.__offset(this.bb_pos,4);return er?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+er),this.bb.__vector_len(this.bb_pos+er)):null}kernelDefHashes(er){let en=this.bb.__offset(this.bb_pos,6);return en?this.bb.readUint64(this.bb.__vector(this.bb_pos+en)+8*er):this.bb.createLong(0,0)}kernelDefHashesLength(){let er=this.bb.__offset(this.bb_pos,6);return er?this.bb.__vector_len(this.bb_pos+er):0}static startKernelCreateInfos(er){er.startObject(2)}static addNodeIndices(er,en){er.addFieldOffset(0,en,0)}static createNodeIndicesVector(er,en){er.startVector(4,en.length,4);for(let ei=en.length-1;ei>=0;ei--)er.addInt32(en[ei]);return er.endVector()}static startNodeIndicesVector(er,en){er.startVector(4,en,4)}static addKernelDefHashes(er,en){er.addFieldOffset(1,en,0)}static createKernelDefHashesVector(er,en){er.startVector(8,en.length,8);for(let ei=en.length-1;ei>=0;ei--)er.addInt64(en[ei]);return er.endVector()}static startKernelDefHashesVector(er,en){er.startVector(8,en,8)}static endKernelCreateInfos(er){return er.endObject()}static createKernelCreateInfos(er,ei,eo){return en.startKernelCreateInfos(er),en.addNodeIndices(er,ei),en.addKernelDefHashes(er,eo),en.endKernelCreateInfos(er)}}er.KernelCreateInfos=en}(er.fbs||(er.fbs={}))}(er.experimental||(er.experimental={}))}(en.onnxruntime||(en.onnxruntime={})),function(er){!function(en){!function(en){class ei{constructor(){this.bb=null,this.bb_pos=0}__init(er,en){return this.bb_pos=er,this.bb=en,this}static getRootAsSubGraphSessionState(er,en){return(en||new ei).__init(er.readInt32(er.position())+er.position(),er)}static getSizePrefixedRootAsSubGraphSessionState(er,en){return er.setPosition(er.position()+es.flatbuffers.SIZE_PREFIX_LENGTH),(en||new ei).__init(er.readInt32(er.position())+er.position(),er)}graphId(er){let en=this.bb.__offset(this.bb_pos,4);return en?this.bb.__string(this.bb_pos+en,er):null}sessionState(en){let ei=this.bb.__offset(this.bb_pos,6);return ei?(en||new er.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+ei),this.bb):null}static startSubGraphSessionState(er){er.startObject(2)}static addGraphId(er,en){er.addFieldOffset(0,en,0)}static addSessionState(er,en){er.addFieldOffset(1,en,0)}static endSubGraphSessionState(er){let en=er.endObject();return er.requiredField(en,4),en}static createSubGraphSessionState(er,en,eo){return ei.startSubGraphSessionState(er),ei.addGraphId(er,en),ei.addSessionState(er,eo),ei.endSubGraphSessionState(er)}}en.SubGraphSessionState=ei}(en.fbs||(en.fbs={}))}(er.experimental||(er.experimental={}))}(en.onnxruntime||(en.onnxruntime={})),function(er){!function(en){!function(en){class ei{constructor(){this.bb=null,this.bb_pos=0}__init(er,en){return this.bb_pos=er,this.bb=en,this}static getRootAsSessionState(er,en){return(en||new ei).__init(er.readInt32(er.position())+er.position(),er)}static getSizePrefixedRootAsSessionState(er,en){return er.setPosition(er.position()+es.flatbuffers.SIZE_PREFIX_LENGTH),(en||new ei).__init(er.readInt32(er.position())+er.position(),er)}kernels(en){let ei=this.bb.__offset(this.bb_pos,4);return ei?(en||new er.experimental.fbs.KernelCreateInfos).__init(this.bb.__indirect(this.bb_pos+ei),this.bb):null}subGraphSessionStates(en,ei){let eo=this.bb.__offset(this.bb_pos,6);return eo?(ei||new er.experimental.fbs.SubGraphSessionState).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+eo)+4*en),this.bb):null}subGraphSessionStatesLength(){let er=this.bb.__offset(this.bb_pos,6);return er?this.bb.__vector_len(this.bb_pos+er):0}static startSessionState(er){er.startObject(2)}static addKernels(er,en){er.addFieldOffset(0,en,0)}static addSubGraphSessionStates(er,en){er.addFieldOffset(1,en,0)}static createSubGraphSessionStatesVector(er,en){er.startVector(4,en.length,4);for(let ei=en.length-1;ei>=0;ei--)er.addOffset(en[ei]);return er.endVector()}static startSubGraphSessionStatesVector(er,en){er.startVector(4,en,4)}static endSessionState(er){return er.endObject()}static createSessionState(er,en,eo){return ei.startSessionState(er),ei.addKernels(er,en),ei.addSubGraphSessionStates(er,eo),ei.endSessionState(er)}}en.SessionState=ei}(en.fbs||(en.fbs={}))}(er.experimental||(er.experimental={}))}(en.onnxruntime||(en.onnxruntime={})),function(er){!function(en){!function(en){class ei{constructor(){this.bb=null,this.bb_pos=0}__init(er,en){return this.bb_pos=er,this.bb=en,this}static getRootAsInferenceSession(er,en){return(en||new ei).__init(er.readInt32(er.position())+er.position(),er)}static getSizePrefixedRootAsInferenceSession(er,en){return er.setPosition(er.position()+es.flatbuffers.SIZE_PREFIX_LENGTH),(en||new ei).__init(er.readInt32(er.position())+er.position(),er)}static bufferHasIdentifier(er){return er.__has_identifier("ORTM")}ortVersion(er){let en=this.bb.__offset(this.bb_pos,4);return en?this.bb.__string(this.bb_pos+en,er):null}model(en){let ei=this.bb.__offset(this.bb_pos,6);return ei?(en||new er.experimental.fbs.Model).__init(this.bb.__indirect(this.bb_pos+ei),this.bb):null}sessionState(en){let ei=this.bb.__offset(this.bb_pos,8);return ei?(en||new er.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+ei),this.bb):null}static startInferenceSession(er){er.startObject(3)}static addOrtVersion(er,en){er.addFieldOffset(0,en,0)}static addModel(er,en){er.addFieldOffset(1,en,0)}static addSessionState(er,en){er.addFieldOffset(2,en,0)}static endInferenceSession(er){return er.endObject()}static finishInferenceSessionBuffer(er,en){er.finish(en,"ORTM")}static finishSizePrefixedInferenceSessionBuffer(er,en){er.finish(en,"ORTM",!0)}static createInferenceSession(er,en,eo,ea){return ei.startInferenceSession(er),ei.addOrtVersion(er,en),ei.addModel(er,eo),ei.addSessionState(er,ea),ei.endInferenceSession(er)}}en.InferenceSession=ei}(en.fbs||(en.fbs={}))}(er.experimental||(er.experimental={}))}(en.onnxruntime||(en.onnxruntime={}))},1723:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.OnnxjsSessionHandler=void 0;let eo=ei(8453),ea=ei(9240);en.OnnxjsSessionHandler=class{constructor(er){this.session=er,this.inputNames=this.session.inputNames,this.outputNames=this.session.outputNames}async dispose(){}async run(er,en,ei){let es=new Map;for(let en in er)if(Object.hasOwnProperty.call(er,en)){let ei=er[en];es.set(en,new ea.Tensor(ei.dims,ei.type,void 0,void 0,ei.data))}let eu=await this.session.run(es),el={};return eu.forEach((er,en)=>{el[en]=new eo.Tensor(er.type,er.data,er.dims)}),el}startProfiling(){this.session.startProfiling()}endProfiling(){this.session.endProfiling()}}},6027:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.Session=void 0;let eo=ei(7067),ea=ei(1296),es=ei(1975),eu=ei(6496),el=ei(1315),ec=ei(1745);en.Session=class{constructor(er={}){this._initialized=!1,this.backendHint=er.backendHint,this.profiler=el.Profiler.create(er.profiler),this.context={profiler:this.profiler,graphInputTypes:[],graphInputDims:[]}}get inputNames(){return this._model.graph.getInputNames()}get outputNames(){return this._model.graph.getOutputNames()}startProfiling(){this.profiler.start()}endProfiling(){this.profiler.stop()}async loadModel(er,en,ei){await this.profiler.event("session","Session.loadModel",async()=>{let eu=await (0,es.resolveBackend)(this.backendHint);if(this.sessionHandler=eu.createSessionHandler(this.context),this._model=new ec.Model,"string"==typeof er){let en=er.endsWith(".ort");if("undefined"==typeof fetch){let ei=await (0,ea.promisify)(eo.readFile)(er);this.initialize(ei,en)}else{let ei=await fetch(er),eo=await ei.arrayBuffer();this.initialize(new Uint8Array(eo),en)}}else if(ArrayBuffer.isView(er))this.initialize(er);else{let eo=new Uint8Array(er,en||0,ei||er.byteLength);this.initialize(eo)}})}initialize(er,en){if(this._initialized)throw Error("already initialized");this.profiler.event("session","Session.initialize",()=>{let ei=this.sessionHandler.transformGraph?this.sessionHandler:void 0;this._model.load(er,ei,en),this.sessionHandler.onGraphInitialized&&this.sessionHandler.onGraphInitialized(this._model.graph),this.initializeOps(this._model.graph),this._executionPlan=new eu.ExecutionPlan(this._model.graph,this._ops,this.profiler)}),this._initialized=!0}async run(er){if(!this._initialized)throw Error("session not initialized yet");return this.profiler.event("session","Session.run",async()=>{let en=this.normalizeAndValidateInputs(er),ei=await this._executionPlan.execute(this.sessionHandler,en);return this.createOutput(ei)})}normalizeAndValidateInputs(er){let en=this._model.graph.getInputNames();if(Array.isArray(er)){if(er.length!==en.length)throw Error(`incorrect input array length: expected ${en.length} but got ${er.length}`)}else{if(er.size!==en.length)throw Error(`incorrect input map size: expected ${en.length} but got ${er.size}`);let ei=Array(er.size),eo=0;for(let ea=0;ea<en.length;++ea){let es=er.get(en[ea]);if(!es)throw Error(`missing input tensor for: '${name}'`);ei[eo++]=es}er=ei}if(this.context.graphInputTypes&&0!==this.context.graphInputTypes.length&&this.context.graphInputDims&&0!==this.context.graphInputDims.length)this.validateInputTensorDims(this.context.graphInputDims,er,!1);else{let en=this._model.graph.getInputIndices(),ei=this._model.graph.getValues(),eo=Array(en.length);for(let ea=0;ea<en.length;++ea){let es=ei[en[ea]];eo[ea]=es.type.shape.dims,this.context.graphInputTypes.push(es.type.tensorType),this.context.graphInputDims.push(er[ea].dims)}this.validateInputTensorDims(eo,er,!0)}return this.validateInputTensorTypes(this.context.graphInputTypes,er),er}validateInputTensorTypes(er,en){for(let ei=0;ei<en.length;ei++){let eo=er[ei],ea=en[ei].type;if(eo!==ea)throw Error(`input tensor[${ei}] check failed: expected type '${eo}' but got ${ea}`)}}validateInputTensorDims(er,en,ei){for(let eo=0;eo<en.length;eo++){let ea=er[eo],es=en[eo].dims;if(!this.compareTensorDims(ea,es,ei))throw Error(`input tensor[${eo}] check failed: expected shape '[${ea.join(",")}]' but got [${es.join(",")}]`)}}compareTensorDims(er,en,ei){if(er.length!==en.length)return!1;for(let eo=0;eo<er.length;++eo)if(er[eo]!==en[eo]&&(!ei||0!==er[eo]))return!1;return!0}createOutput(er){let en=this._model.graph.getOutputNames();if(er.length!==en.length)throw Error("expected number of outputs do not match number of generated outputs");let ei=new Map;for(let eo=0;eo<en.length;++eo)ei.set(en[eo],er[eo]);return ei}initializeOps(er){let en=er.getNodes();this._ops=Array(en.length);for(let ei=0;ei<en.length;ei++)this._ops[ei]=this.sessionHandler.resolve(en[ei],this._model.opsets,er)}}},9240:function(er,en,ei){"use strict";var eo=this&&this.__importDefault||function(er){return er&&er.__esModule?er:{default:er}};Object.defineProperty(en,"__esModule",{value:!0}),en.Tensor=void 0;let ea=ei(3442),es=eo(ei(3720)),eu=ei(1446),el=ei(1287),ec=ei(7273);var ep=el.onnxruntime.experimental.fbs;class ed{get data(){if(void 0===this.cache){let er=this.dataProvider(this.dataId);if(er.length!==this.size)throw Error("Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.");this.cache=er}return this.cache}get stringData(){if("string"!==this.type)throw TypeError("data type is not string");return this.data}get integerData(){switch(this.type){case"uint8":case"int8":case"uint16":case"int16":case"int32":case"uint32":case"bool":return this.data;default:throw TypeError("data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)")}}get floatData(){switch(this.type){case"float32":case"float64":return this.data;default:throw TypeError("data type is not float (float32, float64)")}}get numberData(){if("string"!==this.type)return this.data;throw TypeError("type cannot be non-number (string)")}get(er){return this.data[ec.ShapeUtil.indicesToOffset(er,this.strides)]}set(er,en){this.data[ec.ShapeUtil.indicesToOffset(er,this.strides)]=en}async getData(){return void 0===this.cache&&(this.cache=await this.asyncDataProvider(this.dataId)),this.cache}get strides(){return this._strides||(this._strides=ec.ShapeUtil.computeStrides(this.dims)),this._strides}constructor(er,en,ei,eo,es,eu=ea.Guid.create()){this.dims=er,this.type=en,this.dataProvider=ei,this.asyncDataProvider=eo,this.cache=es,this.dataId=eu,this.size=ec.ShapeUtil.validateDimsAndCalcSize(er);let el=this.size,ep=void 0===ei&&void 0===eo&&void 0===es;if(void 0!==es&&es.length!==el)throw RangeError("Input dims doesn't match data length.");if("string"===en){if(!(void 0===es||Array.isArray(es)&&es.every(er=>"string"==typeof er)))throw TypeError("cache should be a string array");ep&&(this.cache=Array(el))}else{if(void 0!==es){let er=eh(en);if(!(es instanceof er))throw TypeError(`cache should be type ${er.name}`)}if(ep){let er=new ArrayBuffer(el*function(er){switch(er){case"bool":case"int8":case"uint8":return 1;case"int16":case"uint16":return 2;case"int32":case"uint32":case"float32":return 4;case"float64":return 8;default:throw Error(`cannot calculate sizeof() on type ${er}`)}}(en));this.cache=function(er,en){return new(eh(en))(er)}(er,en)}}}static fromProto(er){if(!er)throw Error("cannot construct Value from an empty tensor");let en=ec.ProtoUtil.tensorDataTypeFromProto(er.dataType),ei=ec.ProtoUtil.tensorDimsFromProto(er.dims),eo=new ed(ei,en);if("string"===en)er.stringData.forEach((er,en)=>{eo.data[en]=(0,ec.decodeUtf8String)(er)});else if(er.rawData&&"number"==typeof er.rawData.byteLength&&er.rawData.byteLength>0){let en=eo.data,ei=new DataView(er.rawData.buffer,er.rawData.byteOffset,er.rawData.byteLength),ea=ef(er.dataType),es=er.rawData.byteLength/ea;if(er.rawData.byteLength%ea!=0)throw Error("invalid buffer length");if(en.length!==es)throw Error("buffer length mismatch");for(let eo=0;eo<es;eo++){let es=em(ei,er.dataType,eo*ea);en[eo]=es}}else{let en;switch(er.dataType){case eu.onnx.TensorProto.DataType.FLOAT:en=er.floatData;break;case eu.onnx.TensorProto.DataType.INT32:case eu.onnx.TensorProto.DataType.INT16:case eu.onnx.TensorProto.DataType.UINT16:case eu.onnx.TensorProto.DataType.INT8:case eu.onnx.TensorProto.DataType.UINT8:case eu.onnx.TensorProto.DataType.BOOL:en=er.int32Data;break;case eu.onnx.TensorProto.DataType.INT64:en=er.int64Data;break;case eu.onnx.TensorProto.DataType.DOUBLE:en=er.doubleData;break;case eu.onnx.TensorProto.DataType.UINT32:case eu.onnx.TensorProto.DataType.UINT64:en=er.uint64Data;break;default:throw Error("unspecific error")}if(null==en)throw Error("failed to populate data from a tensorproto value");let ei=eo.data;if(ei.length!==en.length)throw Error("array length mismatch");for(let eo=0;eo<en.length;eo++){let ea=en[eo];es.default.isLong(ea)?ei[eo]=eg(ea,er.dataType):ei[eo]=ea}}return eo}static fromData(er,en,ei){return new ed(en,ei,void 0,void 0,er)}static fromOrtTensor(er){if(!er)throw Error("cannot construct Value from an empty tensor");let en=ec.ProtoUtil.tensorDimsFromORTFormat(er),ei=ec.ProtoUtil.tensorDataTypeFromProto(er.dataType()),eo=new ed(en,ei);if("string"===ei)for(let en=0;en<er.stringDataLength();en++)eo.data[en]=er.stringData(en);else if(er.rawDataArray()&&"number"==typeof er.rawDataLength()&&er.rawDataLength()>0){let en=eo.data,ei=new DataView(er.rawDataArray().buffer,er.rawDataArray().byteOffset,er.rawDataLength()),ea=ef(er.dataType()),es=er.rawDataLength()/ea;if(er.rawDataLength()%ea!=0)throw Error("invalid buffer length");if(en.length!==es)throw Error("buffer length mismatch");for(let eo=0;eo<es;eo++){let es=em(ei,er.dataType(),eo*ea);en[eo]=es}}return eo}}function ef(er){switch(er){case eu.onnx.TensorProto.DataType.UINT8:case eu.onnx.TensorProto.DataType.INT8:case eu.onnx.TensorProto.DataType.BOOL:return 1;case eu.onnx.TensorProto.DataType.UINT16:case eu.onnx.TensorProto.DataType.INT16:return 2;case eu.onnx.TensorProto.DataType.FLOAT:case eu.onnx.TensorProto.DataType.INT32:case eu.onnx.TensorProto.DataType.UINT32:return 4;case eu.onnx.TensorProto.DataType.INT64:case eu.onnx.TensorProto.DataType.DOUBLE:case eu.onnx.TensorProto.DataType.UINT64:return 8;default:throw Error(`cannot calculate sizeof() on type ${eu.onnx.TensorProto.DataType[er]}`)}}function eh(er){switch(er){case"bool":case"uint8":return Uint8Array;case"int8":return Int8Array;case"int16":return Int16Array;case"uint16":return Uint16Array;case"int32":return Int32Array;case"uint32":return Uint32Array;case"float32":return Float32Array;case"float64":return Float64Array;default:throw Error("unspecified error")}}function eg(er,en){if(en===eu.onnx.TensorProto.DataType.INT64||en===ep.TensorDataType.INT64){if(er.greaterThanOrEqual(2147483648)||er.lessThan(-2147483648))throw TypeError("int64 is not supported")}else{if(en!==eu.onnx.TensorProto.DataType.UINT32&&en!==ep.TensorDataType.UINT32&&en!==eu.onnx.TensorProto.DataType.UINT64&&en!==ep.TensorDataType.UINT64)throw TypeError(`not a LONG type: ${eu.onnx.TensorProto.DataType[en]}`);if(er.greaterThanOrEqual(4294967296)||er.lessThan(0))throw TypeError("uint64 is not supported")}return er.toNumber()}function em(er,en,ei){switch(en){case eu.onnx.TensorProto.DataType.BOOL:case eu.onnx.TensorProto.DataType.UINT8:return er.getUint8(ei);case eu.onnx.TensorProto.DataType.INT8:return er.getInt8(ei);case eu.onnx.TensorProto.DataType.UINT16:return er.getUint16(ei,!0);case eu.onnx.TensorProto.DataType.INT16:return er.getInt16(ei,!0);case eu.onnx.TensorProto.DataType.FLOAT:return er.getFloat32(ei,!0);case eu.onnx.TensorProto.DataType.INT32:return er.getInt32(ei,!0);case eu.onnx.TensorProto.DataType.UINT32:return er.getUint32(ei,!0);case eu.onnx.TensorProto.DataType.INT64:return eg(es.default.fromBits(er.getUint32(ei,!0),er.getUint32(ei+4,!0),!1),en);case eu.onnx.TensorProto.DataType.DOUBLE:return er.getFloat64(ei,!0);case eu.onnx.TensorProto.DataType.UINT64:return eg(es.default.fromBits(er.getUint32(ei,!0),er.getUint32(ei+4,!0),!0),en);default:throw Error(`cannot read from DataView for type ${eu.onnx.TensorProto.DataType[en]}`)}}en.Tensor=ed},7273:function(er,en,ei){"use strict";var eo=this&&this.__importDefault||function(er){return er&&er.__esModule?er:{default:er}};Object.defineProperty(en,"__esModule",{value:!0}),en.decodeUtf8String=en.MAX_CLIP=en.MIN_CLIP=en.PoolConvUtil=en.ReduceUtil=en.SplitUtil=en.MathUtil=en.ShapeUtil=en.LongUtil=en.ProtoUtil=en.GemmUtil=en.arrayCopyHelper=en.BroadcastUtil=en.MatMulUtil=en.ArrayUtil=en.assert=en.checkInputsShape=void 0;let ea=ei(5686),es=eo(ei(3720)),eu=ei(1446),el=ei(9240);en.checkInputsShape=function(er,...en){if(!er||er.length!==en.length)return!1;for(let ei=0;ei<er.length;ei++)if(!er[ei].dims||er[ei].dims.length!==en[ei])return!1;return!0},en.assert=function(er,en){if(!er)throw Error("string"==typeof en?en:en())},en.ArrayUtil=class{static arraysEqual(er,en){if(er.length!==en.length)return!1;for(let ei=0;ei<er.length;ei++)if(er[ei]!==en[ei])return!1;return!0}};class ec{static preprocessInputShapes(er,en){return[1===er.length?[1,er[0]]:er,1===en.length?[en[0],1]:en]}static postprocessOutputShape(er,en,ei){1===en&&er.splice(er.length-2,1),1===ei&&er.pop()}static calcMatMulShape(er,en){return er[1]!==en[0]?void 0:[er[0],en[1]]}}en.MatMulUtil=ec;class ep{static calcShape(er,en,ei=!1){let eo=er.length,ea=en.length;if(0===eo)return en;if(0===ea)return er;let es=Math.max(er.length,en.length),eu=Array(es);if(ei){if(eo<2||ea<2)return;let ei=ec.calcMatMulShape([er[eo-2],er[eo-1]],[en[ea-2],en[ea-1]]);if(void 0===ei)return;[eu[es-2],eu[es-1]]=ei}for(let el=ei?3:1;el<=es;el++){let ei=eo-el<0?1:er[eo-el],ec=ea-el<0?1:en[ea-el];if(ei!==ec&&ei>1&&ec>1)return;eu[es-el]=Math.max(ei,ec)}return eu}static index(er,en){let ei=Array(en.length);return ep.fillIndex(er,en,ei),ei}static fillIndex(er,en,ei){let eo=er.length-en.length;for(let ea=0;ea<en.length;ea++)ei[ea]=er[eo+ea]%en[ea]}static calc(er,en,ei,eo,ea){let es=ep.calcShape(er.dims,en.dims);if(es){if(eo&&!eh.areEqual(es,er.dims))return;let eu=eh.size(es),ec=eo?er:new el.Tensor(es,ea||er.type);if(0===es.length)ec.set([],ei(er.get([]),en.get([])));else{let eo=Array(es.length),ea=Array(er.dims.length),el=Array(en.dims.length),ed,ef=0,eh=0,eg=!1,em=!1;0===er.dims.length&&(ef=er.get([]),eg=!0),0===en.dims.length&&(eh=en.get([]),em=!0);for(let eb=0;eb<eu;eb++){ed=eb;for(let er=es.length-1;er>=0;er--)eo[er]=ed%es[er],ed=Math.floor(ed/es[er]);eg||(ep.fillIndex(eo,er.dims,ea),ef=er.get(ea)),em||(ep.fillIndex(eo,en.dims,el),eh=en.get(el)),ec.set(eo,ei(ef,eh))}}return ec}}static isValidBroadcast(er,en){let ei=er.length,eo=en.length;if(ei>eo)return!1;for(let ea=1;ea<=ei;ea++)if(1!==er[ei-ea]&&er[ei-ea]!==en[eo-ea])return!1;return!0}static getBroadcastDims(er,en){let ei=er.length,eo=[];for(let ea=0;ea<ei;ea++){let es=ei-1-ea,eu=er[es]||1;(en[en.length-1-ea]||1)>1&&1===eu&&eo.unshift(es)}return eo}}en.BroadcastUtil=ep,en.arrayCopyHelper=function(er,en,ei,eo,ea){if(eo<0||eo>=en.length)throw Error("sourceIndex out of bounds");if(ei<0||ei>=er.length)throw Error("targetIndex out of bounds");if(eo+ea>en.length)throw Error("source indices to be copied are outside bounds");if(ei+ea>er.length)throw Error("target array is too small to hold result");for(let es=0;es<ea;es++)er[ei+es]=en[eo+es]},en.GemmUtil=class{static getShapeOfGemmResult(er,en,ei,eo,ea){let es,eu,el;if(2!==er.length||2!==ei.length)throw Error("shape need to be of size 2");en?(es=er[1],eu=er[0]):(es=er[0],eu=er[1]);let ec=-1;if(eo?(el=ei[0],ec=1):(el=ei[1],ec=0),ei[ec]!==eu)throw Error("dimension mismatch");if(es<=0||el<=0||eu<=0)throw Error("invalid shape specified");if(ea&&!ep.isValidBroadcast(ea,[es,el]))throw Error("gemm: invalid bias shape for broadcast");return[es,el,eu]}};class ed{static tensorDataTypeFromProto(er){switch(er){case eu.onnx.TensorProto.DataType.INT8:return"int8";case eu.onnx.TensorProto.DataType.UINT8:return"uint8";case eu.onnx.TensorProto.DataType.BOOL:return"bool";case eu.onnx.TensorProto.DataType.INT16:return"int16";case eu.onnx.TensorProto.DataType.UINT16:return"uint16";case eu.onnx.TensorProto.DataType.INT32:return"int32";case eu.onnx.TensorProto.DataType.UINT32:return"uint32";case eu.onnx.TensorProto.DataType.FLOAT:return"float32";case eu.onnx.TensorProto.DataType.DOUBLE:return"float64";case eu.onnx.TensorProto.DataType.STRING:return"string";case eu.onnx.TensorProto.DataType.INT64:return"int32";case eu.onnx.TensorProto.DataType.UINT64:return"uint32";default:throw Error(`unsupported data type: ${eu.onnx.TensorProto.DataType[er]}`)}}static tensorDataTypeStringToEnum(er){switch(er){case"int8":return eu.onnx.TensorProto.DataType.INT8;case"uint8":return eu.onnx.TensorProto.DataType.UINT8;case"bool":return eu.onnx.TensorProto.DataType.BOOL;case"int16":return eu.onnx.TensorProto.DataType.INT16;case"uint16":return eu.onnx.TensorProto.DataType.UINT16;case"int32":return eu.onnx.TensorProto.DataType.INT32;case"uint32":return eu.onnx.TensorProto.DataType.UINT32;case"float32":return eu.onnx.TensorProto.DataType.FLOAT;case"float64":return eu.onnx.TensorProto.DataType.DOUBLE;case"string":return eu.onnx.TensorProto.DataType.STRING;case"int64":return eu.onnx.TensorProto.DataType.INT64;case"uint64":return eu.onnx.TensorProto.DataType.UINT64;default:throw Error(`unsupported data type: ${er}`)}}static tensorDimsFromProto(er){return er.map(er=>es.default.isLong(er)?er.toNumber():er)}static tensorValueTypeFromProto(er){return{tensorType:ed.tensorDataTypeFromProto(er.elemType),shape:{dims:ed.tensorDimsFromProto(er.shape.dim.map(er=>er.dimValue))}}}static tensorDimsFromORTFormat(er){let en=[];for(let ei=0;ei<er.dimsLength();ei++)en.push(ef.longToNumber(er.dims(ei)));return en}static tensorAttributesFromORTFormat(er){let en=[];for(let ei=0;ei<er.attributesLength();ei++)en.push(er.attributes(ei));return en}}en.ProtoUtil=ed;class ef{static longToNumber(er,en){return es.default.isLong(er)?er.toNumber():er instanceof ea.flatbuffers.Long?es.default.fromValue({low:er.low,high:er.high,unsigned:null!=en&&en}).toNumber():er}static isLong(er){return es.default.isLong(er)||er instanceof ea.flatbuffers.Long}}en.LongUtil=ef;class eh{static size(er){return eh.getSizeFromDimensionRange(er,0,er.length)}static sizeFromDimension(er,en){if(en<0||en>er.length)throw Error(`invalid dimension of ${en} for sizeFromDimension as Tensor has ${er.length} dimensions.`);return eh.getSizeFromDimensionRange(er,en,er.length)}static sizeToDimension(er,en){if(en<0||en>er.length)throw Error(`invalid dimension of ${en} for sizeToDimension as Tensor has ${er.length} dimensions.`);return eh.getSizeFromDimensionRange(er,0,en)}static getSizeFromDimensionRange(er,en,ei){let eo=1;for(let ea=en;ea<ei;ea++){if(er[ea]<=0)throw Error("cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.");eo*=er[ea]}return eo}static computeStrides(er){let en=er.length;if(0===en)return[];if(1===en)return[1];let ei=Array(en);ei[en-1]=1,ei[en-2]=er[en-1];for(let eo=en-3;eo>=0;--eo)ei[eo]=ei[eo+1]*er[eo+1];return ei}static transpose(er){return er.slice().reverse()}static indicesToOffset(er,en,ei){void 0===ei&&(ei=er.length);let eo=0;for(let ea=0;ea<ei;++ea)eo+=en[ea]*er[ea];return eo}static offsetToIndices(er,en){let ei=en.length;if(0===ei)return[];if(1===ei)return[er*en[0]];let eo=Array(en.length);for(let ei=0;ei<eo.length-1;++ei)eo[ei]=Math.floor(er/en[ei]),er-=eo[ei]*en[ei];return eo[eo.length-1]=er,eo}static normalizeAxis(er,en){if(er<-en&&er>=en)throw Error("unsupported axis for this operation.");return er<0?er+en:er}static normalizeAxes(er,en){return er.map(er=>this.normalizeAxis(er,en))}static incrementIndex(er,en,ei){if(0===en.length||0===er.length)throw Error("Index incrementing unsupported for scalar Tensor");if(void 0===ei)ei=en.length;else if(ei<=0||ei>en.length)throw Error("Incorrect axis to increment on");for(let eo=ei-1;eo>=0&&(er[eo]++,!(er[eo]<en[eo]));--eo)er[eo]=0}static calculateReshapedDims(er,en){if(0===en.length){if(0===er.length||1===eh.size(er))return[];throw Error("cannot reshape to a scalar Tensor")}let ei=en.length,eo=Array(ei),ea=-1,es=1;for(let eu=0;eu<ei;eu++){if(en[eu]<-1)throw Error("a dimension in shape hints cannot be less than -1");if(-1===en[eu]){if(-1!==ea)throw Error("at most one dimension in shape hints can be -1");ea=eu}else{if(0===en[eu]){if(eu>=er.length)throw Error("the dimension with value zero exceeds the dimension size of the input tensor");eo[eu]=er[eu]}else eo[eu]=en[eu];es*=eo[eu]}}let eu=eh.size(er);if(-1!==ea){if(eu%es!=0)throw Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${er}] Output shape: [${en}]`);eo[ea]=eu/es}else if(es!==eu)throw Error("reshapedDims and originalDims don't have matching sizes");return eo}static sortBasedOnPerm(er,en){return en?en.map(en=>er[en]):er.slice().reverse()}static padShape(er,en){let ei=er.length;return er.map((er,eo)=>er+en[eo]+en[eo+ei])}static areEqual(er,en){return er.length===en.length&&er.every((er,ei)=>er===en[ei])}static validateDimsAndCalcSize(er){if(er.length>6)throw TypeError("Only rank 0 to 6 is supported for tensor shape.");let en=1;for(let ei of er){if(!Number.isInteger(ei))throw TypeError(`Invalid shape: ${ei} is not an integer`);if(ei<0||ei>2147483647)throw TypeError(`Invalid shape: length ${ei} is not allowed`);en*=ei}return en}static flattenShape(er,en){en<0&&(en+=er.length);let ei=er.reduce((er,en)=>er*en,1),eo=er.slice(en).reduce((er,en)=>er*en,1);return[ei/eo,eo]}static squeezeShape(er,en){let ei=[];en=eh.normalizeAxes(en,er.length);for(let eo=0;eo<er.length;eo++){let ea=en.indexOf(eo)>=0;if(ea&&1!==er[eo])throw Error("squeeze an axis of size different than 1");(0===en.length&&er[eo]>1||en.length>0&&!ea)&&ei.push(er[eo])}return ei}static unsqueezeShape(er,en){let ei=Array(er.length+en.length);ei.fill(0);for(let er=0;er<en.length;er++){let eo=eh.normalizeAxis(en[er],ei.length);if(eo>=ei.length)throw Error("'axes' has an out of range axis");if(0!==ei[eo])throw Error("'axes' has a duplicate axis");ei[eo]=1}let eo=0;for(let en=0;en<ei.length;en++)0===ei[en]&&(ei[en]=er[eo++]);if(eo!==er.length)throw Error("the unsqueezed dimension could not be established");return ei}}en.ShapeUtil=eh,en.MathUtil=class{static sqr(er,en,ei,eo,ea){if(eo<0||eo>=en.length)throw Error("sourceIndex out of bounds");if(ei<0||ei>=er.length)throw Error("targetIndex out of bounds");if(eo+ea>en.length)throw Error("source indices to be copied are outside bounds");if(ei+ea>er.length)throw Error("target array is too small to hold result");for(let es=0;es<ea;es++)er[ei+es]+=Math.pow(en[eo+es],2)}static axpy(er,en,ei,eo,ea,es){if(eo<0||eo>=en.length)throw Error("sourceIndex out of bounds");if(ei<0||ei>=er.length)throw Error("targetIndex out of bounds");if(eo+ea>en.length)throw Error("source indices to be copied are outside bounds");if(ei+ea>er.length)throw Error("target array is too small to hold result");for(let eu=0;eu<ea;eu++)er[ei+eu]+=es*en[eo+eu]}static powx(er,en,ei,eo,ea,es){if(eo<0||eo>=en.length)throw Error("sourceIndex out of bounds");if(ei<0||ei>=er.length)throw Error("targetIndex out of bounds");if(eo+ea>en.length)throw Error("source indices to be copied are outside bounds");if(ei+ea>er.length)throw Error("target array is too small to hold result");for(let eu=0;eu<ea;eu++)er[ei+eu]=Math.pow(en[eo+eu],es)}static mul(er,en,ei,eo,ea){if(eo<0||eo>=en.length)throw Error("sourceIndex out of bounds");if(ei<0||ei>=er.length)throw Error("targetIndex out of bounds");if(eo+ea>en.length)throw Error("source indices to be copied are outside bounds");if(ei+ea>er.length)throw Error("target array is too small to hold result");for(let es=0;es<ea;es++)er[ei+es]=en[eo+es]*er[ei+es]}};class eg{static splitShape(er,en,ei,eo){if(0===ei.length){if(!eo)throw Error("need to know number of outputs when the 'split' attribute is not specified");eg.determineSplit(er[en],eo,ei)}let ea=[],es=[0];for(let eo=0;eo<ei.length;++eo){0!==eo&&es.push(es[eo-1]+ei[eo-1]);let eu=er.slice();eu[en]=ei[eo],ea.push(eu)}return[ea,es]}static determineSplit(er,en,ei){if(er%en!=0)throw Error("cannot split tensor to equal sized parts");for(let eo=0;eo<en;++eo)ei.push(er/en)}}en.SplitUtil=eg;class em{static calcReduce(er,en,ei,eo,ea){let es=er.dims.slice(0);0===en.length&&es.forEach((er,ei)=>en.push(ei));let eu=em.calcReduceShape(es,en,!0),ec=eh.size(eu),ed=new el.Tensor(eu,er.type),ef=eh.computeStrides(eu),eg=eh.computeStrides(es),eb=Array(es.length);for(let ei=0;ei<ec;ei++){let eu=eh.offsetToIndices(ei,ef);ep.fillIndex(eu,es,eb),ed.set(eu,em.calcReduceByAxis(er.numberData,en,es,0,eh.indicesToOffset(eb,eg),eo,ea))}return ei?ed:new el.Tensor(em.calcReduceShape(es,en,ei),ed.type,void 0,void 0,ed.data,ed.dataId)}static calcReduceByAxis(er,en,ei,eo,ea,es,eu){let el=0;if(eo>=en.length)return es(er[ea]);let ec=en[eo],ep=ec>=ei.length?1:eh.size(ei.slice(ec+1));for(let ed=0;ed<ei[ec];ed++)el=0===ed?em.calcReduceByAxis(er,en,ei,eo+1,ea,es,eu):eu(el,em.calcReduceByAxis(er,en,ei,eo+1,ea,es,eu)),ea+=ep;return el}static calcReduceShape(er,en,ei){let eo=er.slice();for(let er=0;er<en.length;er++)eo[en[er]]=ei?1:0;return eo.filter(er=>0!==er)}}en.ReduceUtil=em;class eb{static adjustPoolAttributes(er,en,ei,eo,ea,es){if(!er&&ei.length!==en.length-2)throw Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(er)for(let er=0;er<en.length-2;er++)er>=ei.length?ei.push(en[er+2]):ei[er]=en[er+2];for(let er=0;er<ei.length;er++)if(er<eo.length){if(eo[er]<0)throw Error("strides should be greater than or equal to 1")}else eo.push(1);for(let er=0;er<ei.length;er++)if(er<ea.length){if(ea[er]<0)throw Error("dilations should be greater than or equal to 1")}else ea.push(1);for(let er=0;er<2*ei.length;er++)if(er<es.length){if(es[er]<0)throw Error("pad should be greater than or equal to 1")}else es.push(0);for(let er=0;er<ei.length;er++){if(ei[er]<=0)throw Error("kernel shapes need to be greater than 0");if(es[er]>=ei[er]||es[er+ei.length]>=ei[er])throw Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(er,en,ei,eo,ea,es){if(es){if(ea.length!==2*(er.length-2))throw Error("length of pads should be twice the length of data dimensions");if(en.length!==er.length-2)throw Error("length of strides should be the length of data dimensions");if(eo.length!==er.length-2)throw Error("length of kernel shapes should be the length of data dimensions");for(let eu=0;eu<er.length-2;eu++)eb.adjustPadAndReturnShape(er[eu+2],en[eu],ei[eu],eo[eu],ea,eu,eu+er.length-2,es)}}static computePoolOutputShape(er,en,ei,eo,ea,es,eu){if(en.length<=0)throw Error("input shape must be of size greater than 0");let el=[en[0],en[1]];return eb.computeShapeHelper(er,en,el,ei,eo,ea,es,eu),el}static computeConvOutputShape(er,en,ei,eo,ea,es,eu){if(er.length<=0||en.length<=0)throw Error("invalid input tensor dims or invalid filter tensor dims");let el=[er[0],en[0]];return eb.computeShapeHelper(!1,er,el,ei,eo,ea,es,eu),el}static computeShapeHelper(er,en,ei,eo,ea,es,eu,el){if(er)for(let er=0;er<en.length-2;er++)ei.push(1);else for(let er=0;er<en.length-2;er++)ei.push(eb.adjustPadAndReturnShape(en[er+2],eo[er],ea[er],es[er],eu,er,er+en.length-2,el))}static adjustPadAndReturnShape(er,en,ei,eo,ea,es,eu,el){let ec=ei*(eo-1)+1;if(!el||"NOTSET"===el)return Math.floor((er+ea[es]+ea[eu]-ec)/en+1);switch(el){case"VALID":return ea[es]=0,ea[eu]=0,Math.floor((er-ec)/en+1);case"SAME_LOWER":case"SAME_UPPER":if(1!==ei)throw Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let ei=((er+en-1)/en-1)*en+eo-er;return ea[es]="SAME_LOWER"===el?Math.floor((ei+1)/2):Math.floor(ei/2),ea[eu]=ei-ea[es],Math.floor((er+ei-eo)/en+1)}default:throw Error("Unsupported AutoPad type")}}}en.PoolConvUtil=eb,en.MIN_CLIP=-34028234663852886e22,en.MAX_CLIP=34028234663852886e22,en.decodeUtf8String=function(er){return(new TextDecoder).decode(er)}},3838:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.WebGpuBackend=void 0;let eo=ei(8453),ea=ei(4955),es=ei(7771),eu=ei(8510),el=ei(8305);en.WebGpuBackend=class{constructor(){this.currentKernelId=null,this.commandEncoder=null,this.computePassEncoder=null,this.pendingDispatchNumber=0,this.profilingEnabled=!1}get currentKernelCustomData(){if(null===this.currentKernelId)throw Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let er=this.kernelCustomData.get(this.currentKernelId);return er||(er={},this.kernelCustomData.set(this.currentKernelId,er)),er}async initialize(){if(!navigator.gpu)throw Error("WebGpuBackend: WebGPU is not available.");let er=await navigator.gpu.requestAdapter();if(!er)throw Error("WebGpuBackend: Failed to get GPU adapter.");let en={requiredLimits:{maxComputeWorkgroupStorageSize:er.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:er.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:er.limits.maxStorageBufferBindingSize}};er.features.has("timestamp-query-inside-passes")&&"default"===eo.env.webgpu.profilingMode&&(this.profilingEnabled=!0,en.requiredFeatures=["timestamp-query-inside-passes"]),this.device=await er.requestDevice(en),this.gpuDataManager=(0,es.createGpuDataManager)(this),this.programManager=new el.ProgramManager(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,this.device.onuncapturederror=er=>{er.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${er.error.message}`)},this.profilingEnabled&&(this.profilingQuerySet=this.device.createQuerySet({type:"timestamp",count:2}))}dispose(){}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){return this.computePassEncoder||(this.computePassEncoder=this.getCommandEncoder().beginComputePass()),this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){this.endComputePass(),this.device.queue.submit([this.getCommandEncoder().finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0}run(er,en,ei,eo,es){if(en.length!==er.inputTypes.length)throw Error(`Input size must be equal to ${er.inputTypes.length}.`);let eu=[];for(let er=0;er<en.length;++er){let ei=this.gpuDataManager.get(en[er].data);if(!ei)throw Error(`no GPU data for input: ${en[er].data}`);eu[er]=ei}let el=((er,en,ei)=>{let eo=en.map(er=>`${er.join(",")}`).join("_"),ea=ei.join("_"),es=er.name;return er.cacheHint&&(es+="["+er.cacheHint+"]"),es+=":"+eo+";"+ea})(er,en.map(er=>er.dims),eu.map(er=>er.type)),ec=this.programManager.getArtifact(el),ep=ec?ec.programInfo:"function"==typeof er.get?er.get():er,ed=0===ei.length?ep.outputs.map((er,en)=>en):ei;if(ed.length!==ep.outputs.length)throw Error(`Output size ${ed.length} must be equal to ${ep.outputs.length}.`);let ef=[],eh=[];for(let er=0;er<ep.outputs.length;++er){if(!Number.isInteger(ed[er])||ed[er]<-2||ed[er]>=ep.outputs.length)throw Error(`Invalid output index: ${ed[er]}`);let en=-1===ed[er],ei=-2===ed[er],ea=en||ei?es(ep.outputs[er].dataType,ep.outputs[er].dims):eo(ed[er],ep.outputs[er].dataType,ep.outputs[er].dims),eu=this.gpuDataManager.get(ea.data);if(!eu)throw Error(`no GPU data for output: ${ea.data}`);if(en&&this.temporaryData.push(eu),ei){let er=this.kernelPersistentData.get(this.currentKernelId);er||(er=[],this.kernelPersistentData.set(this.currentKernelId,er)),er.push(eu)}ef.push(ea),eh.push(eu)}let eg=this.programManager.normalizeDispatchGroupSize(ep.dispatchGroup(en));return ec||(ec=this.programManager.build(ep,eg),this.programManager.setArtifact(el,ec)),(0,ea.LOG_DEBUG)("info",()=>`[ProgramManager] run "${ep.name}" (key=${el}) with ${eg[0]}x${eg[1]}x${eg[2]}`),this.programManager.run(ec,eu,eh,eg),ef}upload(er,en){this.gpuDataManager.upload(er,en)}memcpy(er,en){this.gpuDataManager.memcpy(er,en)}async download(er,en){let ei=await this.gpuDataManager.download(er);en().set(new Uint8Array(ei))}alloc(er){return this.gpuDataManager.create(er).id}free(er){return this.gpuDataManager.release(er)}createKernel(er,en,ei){let eo=eu.WEBGPU_OP_RESOLVE_RULES.get(er);if(!eo)throw Error(`kernel not implemented: ${er}`);this.kernels.set(en,[er,eo[0],[eo[1],ei]])}releaseKernel(er){let en=this.kernelPersistentData.get(er);if(en){for(let er of en)this.gpuDataManager.release(er.id);this.kernelPersistentData.delete(er)}this.kernelCustomData.delete(er),this.kernels.delete(er)}computeKernel(er,en){let ei=this.kernels.get(er);if(!ei)throw Error(`kernel not created: ${er}`);let[eo,es,eu]=ei;if(null!==this.currentKernelId)throw Error(`kernel "${eo}" is not allowed to be called recursively`);this.currentKernelId=er,eu[0]&&(eu[1]=eu[0](eu[1]),eu[0]=void 0),(0,ea.LOG_DEBUG)("info",()=>`[WebGPU] Start to run kernel "${eo}"...`),this.temporaryData=[];try{return es(en,eu[1]),0}catch(er){return(0,ea.LOG_DEBUG)("warning",`[WebGPU] Kernel "${eo}" failed. Error: ${er}`),1}finally{for(let er of this.temporaryData)this.gpuDataManager.release(er.id);this.temporaryData=[],this.currentKernelId=null}}}},7675:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.init=void 0;let eo=ei(7917),ea=ei(3838),es=ei(4955),eu=ei(6952);class el{constructor(er,en,ei,eo){this.module=er,this.dataType=en,this.data=ei,this.dims=eo}getFloat32Array(){return new Float32Array(this.module.HEAP8.buffer,this.data,eu.ShapeUtil.size(this.dims))}reshape(er){if(eu.ShapeUtil.size(er)!==eu.ShapeUtil.size(this.dims))throw Error("Invalid new shape");return new el(this.module,this.dataType,this.data,er)}}class ec{get customData(){return this.backend.currentKernelCustomData}constructor(er,en,ei){this.module=er,this.backend=en;let eo=er.HEAPU32,ea=ei>>2;this.opKernelContext=eo[ea++];let es=eo[ea++],eu=[];for(let en=0;en<es;en++){let en=eo[ea++],ei=eo[ea++],es=eo[ea++],ec=[];for(let er=0;er<es;er++)ec.push(eo[ea++]);eu.push(new el(er,en,ei,ec))}this.inputs=eu}compute(er,en){var ei,ea,es;let ec=null!==(ea=null===(ei=null==en?void 0:en.inputs)||void 0===ei?void 0:ei.map(er=>"number"==typeof er?this.inputs[er]:er))&&void 0!==ea?ea:this.inputs,ep=null!==(es=null==en?void 0:en.outputs)&&void 0!==es?es:[];return this.backend.run(er,ec,ep,(er,en,ei)=>new el(this.module,en,this.output(er,ei),ei),(er,en)=>{let ei=(0,eo.getTensorElementSize)(er);if(!ei)throw Error(`Unsupported data type: ${er}`);let ea=ei*eu.ShapeUtil.size(en);return new el(this.module,er,this.backend.gpuDataManager.create(ea).id,en)})}output(er,en){let ei=this.module.stackSave();try{let ei=this.module.stackAlloc(4*(1+en.length)),eo=ei>>2;this.module.HEAPU32[eo++]=en.length;for(let er=0;er<en.length;er++)this.module.HEAPU32[eo++]=en[er];return this.module._JsepOutput(this.opKernelContext,er,ei)}finally{this.module.stackRestore(ei)}}}en.init=async er=>{let en=er.jsepInit;if(en&&navigator.gpu){let ei=new ea.WebGpuBackend;await ei.initialize(),en({backend:ei},er=>ei.alloc(er),er=>ei.free(er),(en,eo,ea,eu=!1)=>{if(eu)(0,es.LOG_DEBUG)("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${en}, dst=${eo}, size=${ea}`),ei.memcpy(en,eo);else{(0,es.LOG_DEBUG)("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${en}, gpuDataId=${eo}, size=${ea}`);let eu=er.HEAPU8.subarray(en,en+ea);ei.upload(eo,eu)}},async(en,eo,ea)=>{(0,es.LOG_DEBUG)("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${en}, dataOffset=${eo}, size=${ea}`),await ei.download(en,()=>er.HEAPU8.subarray(eo,eo+ea))},(er,en,eo)=>ei.createKernel(er,en,eo),er=>ei.releaseKernel(er),(en,eo)=>{(0,es.LOG_DEBUG)("verbose",()=>`[WebGPU] jsepRun: kernel=${en}, contextDataOffset=${eo}`);let ea=new ec(er,ei,eo);return ei.computeKernel(en,ea)})}}},4955:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.LOG_DEBUG=en.LOG=void 0;let eo=ei(8453),ea=ei(7917),es=["V","I","W","E","F"];en.LOG=(er,en)=>{let ei=(0,ea.logLevelStringToEnum)(er);ei>=(0,ea.logLevelStringToEnum)(eo.env.logLevel)&&console.log(`[${es[ei]},${(new Date).toISOString()}]${"function"==typeof en?en():en}`)},en.LOG_DEBUG=(...er)=>{eo.env.debug&&(0,en.LOG)(...er)}},6952:(er,en)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.MAX_CLIP=en.MIN_CLIP=en.GemmUtil=en.PoolConvUtil=en.ShapeUtil=en.BroadcastUtil=en.MatMulUtil=void 0;class ei{static calcMatMulShape(er,en){return er[1]!==en[0]?void 0:[er[0],en[1]]}}en.MatMulUtil=ei;class eo{static calcShape(er,en,eo=!1){let ea=er.length,es=en.length;if(0===ea)return en;if(0===es)return er;let eu=Math.max(er.length,en.length),el=Array(eu);if(eo){if(ea<2||es<2)return;let eo=ei.calcMatMulShape([er[ea-2],er[ea-1]],[en[es-2],en[es-1]]);if(void 0===eo)return;[el[eu-2],el[eu-1]]=eo}for(let ei=eo?3:1;ei<=eu;ei++){let eo=ea-ei<0?1:er[ea-ei],ec=es-ei<0?1:en[es-ei];if(eo!==ec&&eo>1&&ec>1)return;el[eu-ei]=Math.max(eo,ec)}return el}static isValidBroadcast(er,en){let ei=er.length,eo=en.length;if(ei>eo)return!1;for(let ea=1;ea<=ei;ea++)if(1!==er[ei-ea]&&er[ei-ea]!==en[eo-ea])return!1;return!0}}en.BroadcastUtil=eo;class ea{static size(er){return ea.getSizeFromDimensionRange(er,0,er.length)}static sizeFromDimension(er,en){if(en<0||en>er.length)throw Error(`invalid dimension of ${en} for sizeFromDimension as Tensor has ${er.length} dimensions.`);return ea.getSizeFromDimensionRange(er,en,er.length)}static sizeToDimension(er,en){if(en<0||en>er.length)throw Error(`invalid dimension of ${en} for sizeToDimension as Tensor has ${er.length} dimensions.`);return ea.getSizeFromDimensionRange(er,0,en)}static getSizeFromDimensionRange(er,en,ei){let eo=1;for(let ea=en;ea<ei;ea++){if(er[ea]<=0)throw Error("cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.");eo*=er[ea]}return eo}static computeStrides(er){let en=er.length;if(0===en)return[];if(1===en)return[1];let ei=Array(en);ei[en-1]=1,ei[en-2]=er[en-1];for(let eo=en-3;eo>=0;--eo)ei[eo]=ei[eo+1]*er[eo+1];return ei}static normalizeAxis(er,en){if(er<-en&&er>=en)throw Error("unsupported axis for this operation.");return er<0?er+en:er}static normalizeAxes(er,en){return er.map(ei=>this.normalizeAxis(ei,null!=en?en:er.length))}static sortBasedOnPerm(er,en){return en?en.map(en=>er[en]):er.slice().reverse()}static padShape(er,en){let ei=er.length;return er.map((er,eo)=>er+en[eo]+en[eo+ei])}static areEqual(er,en){return er.length===en.length&&er.every((er,ei)=>er===en[ei])}}en.ShapeUtil=ea;class es{static adjustPoolAttributes(er,en,ei,eo,ea,es){if(!er&&ei.length!==en.length-2)throw Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(er)for(let er=0;er<en.length-2;er++)er>=ei.length?ei.push(en[er+2]):ei[er]=en[er+2];for(let er=0;er<ei.length;er++)if(er<eo.length){if(eo[er]<0)throw Error("strides should be greater than or equal to 1")}else eo.push(1);for(let er=0;er<ei.length;er++)if(er<ea.length){if(ea[er]<0)throw Error("dilations should be greater than or equal to 1")}else ea.push(1);for(let er=0;er<2*ei.length;er++)if(er<es.length){if(es[er]<0)throw Error("pad should be greater than or equal to 1")}else es.push(0);for(let er=0;er<ei.length;er++){if(ei[er]<=0)throw Error("kernel shapes need to be greater than 0");if(es[er]>=ei[er]||es[er+ei.length]>=ei[er])throw Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(er,en,ei,eo,ea,eu,el){if(el){if(ea.length!==2*(er.length-2))throw Error("length of pads should be twice the length of data dimensions");if(en.length!==er.length-2)throw Error("length of strides should be the length of data dimensions");if(eo.length!==er.length-2)throw Error("length of kernel shapes should be the length of data dimensions");for(let ec=0;ec<er.length-2;ec++)es.adjustPadAndReturnShape(er[ec+(eu?1:2)],en[ec],ei[ec],eo[ec],ea,ec,ec+er.length-2,el)}}static computePoolOutputShape(er,en,ei,eo,ea,eu,el){if(en.length<=0)throw Error("input shape must be of size greater than 0");let ec=[en[0],en[1]];return es.computeShapeHelper(er,en,ec,ei,eo,ea,eu,el),ec}static computeConvOutputShape(er,en,ei,eo,ea,eu,el){if(er.length<=0||en.length<=0)throw Error("invalid input tensor dims or invalid filter tensor dims");let ec=[er[0],en[0]];return es.computeShapeHelper(!1,er,ec,ei,eo,ea,eu,el),ec}static computeShapeHelper(er,en,ei,eo,ea,eu,el,ec){if(er)for(let er=0;er<en.length-2;er++)ei.push(1);else for(let er=0;er<en.length-2;er++)ei.push(es.adjustPadAndReturnShape(en[er+2],eo[er],ea[er],eu[er],el,er,er+en.length-2,ec))}static adjustPadAndReturnShape(er,en,ei,eo,ea,es,eu,el){let ec=ei*(eo-1)+1;if(!el||"NOTSET"===el)return Math.floor((er+ea[es]+ea[eu]-ec)/en+1);switch(el){case"VALID":return ea[es]=0,ea[eu]=0,Math.floor((er-ec)/en+1);case"SAME_LOWER":case"SAME_UPPER":if(1!==ei)throw Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let ei=((er+en-1)/en-1)*en+eo-er;return ea[es]="SAME_LOWER"===el?Math.floor((ei+1)/2):Math.floor(ei/2),ea[eu]=ei-ea[es],Math.floor((er+ei-eo)/en+1)}default:throw Error("Unsupported AutoPad type")}}}en.PoolConvUtil=es,en.GemmUtil=class{static getShapeOfGemmResult(er,en,ei,ea,es){let eu,el,ec;if(2!==er.length||2!==ei.length)throw Error("shape need to be of size 2");en?(eu=er[1],el=er[0]):(eu=er[0],el=er[1]);let ep=-1;if(ea?(ec=ei[0],ep=1):(ec=ei[1],ep=0),ei[ep]!==el)throw Error("dimension mismatch");if(eu<=0||ec<=0||el<=0)throw Error("invalid shape specified");if(es&&!eo.isValidBroadcast(es,[eu,ec]))throw Error("gemm: invalid bias shape for broadcast");return[eu,ec,el]}},en.MIN_CLIP=-34028234663852886e22,en.MAX_CLIP=34028234663852886e22},387:(er,en)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.createAttributeWithCacheKey=void 0;class ei{constructor(er){Object.assign(this,er)}get cacheKey(){return this._cacheKey||(this._cacheKey=Object.getOwnPropertyNames(this).sort().map(er=>`${this[er]}`).join(";")),this._cacheKey}}en.createAttributeWithCacheKey=er=>new ei(er)},7771:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.createGpuDataManager=void 0;let eo=ei(4955),ea=ei(1163),es=er=>16*Math.ceil(er/16),eu=0;class el{constructor(er){this.backend=er,this.storageCache=new Map,this.downloadCache=new Map,this.buffersForUploadingPending=[],this.buffersPending=[]}upload(er,en){let ei=en.buffer,ea=en.byteOffset,eu=en.byteLength,el=es(eu),ec=this.storageCache.get(er);if(!ec)throw Error("gpu data for uploading does not exist");if(ec.originalSize!==eu)throw Error(`inconsistent data size. gpu data size=${ec.originalSize}, data size=${eu}`);let ep=this.backend.device.createBuffer({mappedAtCreation:!0,size:el,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),ed=ep.getMappedRange();new Uint8Array(ed).set(new Uint8Array(ei,ea,eu)),ep.unmap();let ef=this.backend.getCommandEncoder();this.backend.endComputePass(),ef.copyBufferToBuffer(ep,0,ec.gpuData.buffer,0,el),(0,eo.LOG_DEBUG)("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${er})`),this.buffersForUploadingPending.push(ep)}memcpy(er,en){let ei=this.storageCache.get(er);if(!ei)throw Error("source gpu data for memcpy does not exist");let eo=this.storageCache.get(en);if(!eo)throw Error("destination gpu data for memcpy does not exist");if(ei.originalSize!==eo.originalSize)throw Error("inconsistent source and destination gpu data size");let ea=es(ei.originalSize);this.backend.getCommandEncoder().copyBufferToBuffer(ei.gpuData.buffer,0,eo.gpuData.buffer,0,ea)}create(er,en=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let ei=es(er),el=this.backend.device.createBuffer({size:ei,usage:en}),ec={id:eu++,type:ea.GpuDataType.default,buffer:el};return this.storageCache.set(ec.id,{gpuData:ec,originalSize:er}),(0,eo.LOG_DEBUG)("verbose",()=>`[WebGPU] GpuDataManager.create(size=${er}) => id=${ec.id}`),ec}get(er){var en;return null===(en=this.storageCache.get(er))||void 0===en?void 0:en.gpuData}release(er){let en=this.storageCache.get(er);if(!en)throw Error("releasing data does not exist");return(0,eo.LOG_DEBUG)("verbose",()=>`[WebGPU] GpuDataManager.release(id=${er}), gpuDataId=${en.gpuData.id}`),this.storageCache.delete(er),this.buffersPending.push(en.gpuData.buffer),this.downloadCache.get(er)&&this.downloadCache.delete(er),en.originalSize}async download(er){let en=this.downloadCache.get(er);if(en)return en.data;let ei=this.storageCache.get(er);if(!ei)throw Error("data does not exist");let eo=this.backend.getCommandEncoder();this.backend.endComputePass();let ea=this.backend.device.createBuffer({size:ei.originalSize,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});eo.copyBufferToBuffer(ei.gpuData.buffer,0,ea,0,ei.originalSize),this.backend.flush();let es=new Promise(er=>{ea.mapAsync(GPUMapMode.READ).then(()=>{let en=ea.getMappedRange().slice(0);ea.destroy(),er(en)})});return this.downloadCache.set(er,{data:es}),es}refreshPendingBuffers(){for(let er of this.buffersForUploadingPending)er.destroy();for(let er of this.buffersPending)er.destroy()}}en.createGpuDataManager=(...er)=>new el(...er)},8510:function(er,en,ei){"use strict";var eo=this&&this.__createBinding||(Object.create?function(er,en,ei,eo){void 0===eo&&(eo=ei);var ea=Object.getOwnPropertyDescriptor(en,ei);ea&&!("get"in ea?!en.__esModule:ea.writable||ea.configurable)||(ea={enumerable:!0,get:function(){return en[ei]}}),Object.defineProperty(er,eo,ea)}:function(er,en,ei,eo){void 0===eo&&(eo=ei),er[eo]=en[ei]}),ea=this&&this.__setModuleDefault||(Object.create?function(er,en){Object.defineProperty(er,"default",{enumerable:!0,value:en})}:function(er,en){er.default=en}),es=this&&this.__importStar||function(er){if(er&&er.__esModule)return er;var en={};if(null!=er)for(var ei in er)"default"!==ei&&Object.prototype.hasOwnProperty.call(er,ei)&&eo(en,er,ei);return ea(en,er),en};Object.defineProperty(en,"__esModule",{value:!0}),en.WEBGPU_OP_RESOLVE_RULES=void 0;let eu=es(ei(504)),el=ei(9770),ec=ei(4271),ep=ei(1522),ed=es(ei(5262)),ef=ei(2625),eh=es(ei(9302));en.WEBGPU_OP_RESOLVE_RULES=new Map([["Abs",[eh.abs]],["Acos",[eh.acos]],["Acosh",[eh.acosh]],["Add",[eu.add]],["Asin",[eh.asin]],["Asinh",[eh.asinh]],["Atan",[eh.atan]],["Atanh",[eh.atanh]],["AveragePool",[ed.averagePool,ed.parseAveragePoolAttributes]],["Ceil",[eh.ceil]],["ClipV10",[eh.clipV10]],["Clip",[eh.clip]],["Conv",[el.conv,el.parseConvAttributes]],["Cos",[eh.cos]],["Cosh",[eh.cosh]],["Div",[eu.div]],["Elu",[eh.elu,eh.parseAlphaAttributes]],["Erf",[eh.erf]],["Exp",[eh.exp]],["Floor",[eh.floor]],["Gemm",[ec.gemm,ec.parseGemmAttributes]],["GlobalAveragePool",[ed.globalAveragePool,ed.parseGlobalAveragePoolAttributes]],["GlobalMaxPool",[ed.globalMaxPool,ed.parseGlobalMaxPoolAttributes]],["LeakyRelu",[eh.leakyRelu,eh.parseAlphaAttributes]],["MatMul",[ep.matMul]],["MaxPool",[ed.maxPool,ed.parseMaxPoolAttributes]],["Mul",[eu.mul]],["Neg",[eh.neg]],["Pow",[eu.pow]],["Reciprocal",[eh.reciprocal]],["Relu",[eh.relu]],["Sigmoid",[eh.sigmoid]],["Sin",[eh.sin]],["Sinh",[eh.sinh]],["Sqrt",[eh.sqrt]],["Sub",[eu.sub]],["Tan",[eh.tan]],["Tanh",[eh.tanh]],["ThresholdedRelu",[eh.thresholdedRelu,eh.parseAlphaAttributes]],["Transpose",[ef.transpose,ef.parseTransposeAttributes]]])},1427:(er,en)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.biasActivationSnippet=en.activationFnSnippet=en.typeSnippet=void 0,en.typeSnippet=er=>{switch(er){case 1:return"f32";case 2:return"vec2<f32>";case 3:return"vec3<f32>";case 4:return"vec4<f32>";default:throw Error(`${er}-component is not supported.`)}},en.activationFnSnippet=(er,en=!1,ei=!1,eo=3)=>"",en.biasActivationSnippet=(er,en)=>`
      ${er?"value = value + getBiasByOutputCoords(coords);":""}
      ${en?"value = activation(value, coords);":""}
      `},9456:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.createConv2DMatMulProgramInfo=void 0;let eo=ei(4955),ea=ei(6952),es=ei(1163),eu=ei(1427),el=ei(4085),ec=ei(158);en.createConv2DMatMulProgramInfo=(er,en,ei,ep,ed,ef,eh,eg,em)=>{let eb="NHWC"===ei.format,ey=eb?er[0].dims[3]:er[0].dims[1],ev=ep[0],e_=eb?ep[2]:ep[3],ex=eb?ep[1]:ep[2],ew=eb?ep[3]:ep[1],eT=((ey%4==0||ey%3==0)&&eb||e_%4==0&&!eb)&&ew%4==0,eS=eb?ew:e_*ex,eO=eb?e_*ex:ew,eA=eT?[8,8,1]:[eS<=4?4:16,eS>4&&eO<=4?4:16,1],eE=eT?[4,4,1]:[eS<=4?1:2,eS>4&&eO<=4?1:2,1],eI=[Math.ceil(eS/eA[0]/eE[0]),Math.ceil(eO/eA[1]/eE[1]),Math.ceil(ev/eA[2]/eE[1])];(0,eo.LOG_DEBUG)("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${eI}`);let e$=eT?eb&&ey%4!=0?3:4:eE[0],eP=eA[1]*eE[1],eD=eA[0]*eE[0],ek=Math.max(eA[0]*e$,eA[1]),eC=ed%eP==0,eR=ef%eD==0,eM=eh%ek==0,eN=eT?[e$,4,4]:[1,1,1],eF=[`@group(0) @binding(0) var<storage, read> x: array<${eT&&4===e$?"vec4<f32>":"f32"}>;`,`@group(0) @binding(1) var<storage, read> w: array<${eT?"vec4<f32>":"f32"}>;`],eL=`
      fn setOutputAtIndex(flatIndex : i32, value : ${eT?"vec4<f32>":"f32"}) {
        result[flatIndex] = ${eT?"vec4<f32>":"f32"}(value);
      }
      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${eT?"vec4<f32>":"f32"}) {
        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));
        setOutputAtIndex(flatIndex ${eT?"/ 4":""}, value);
      }`;return eg&&(eF.push(`@group(0) @binding(2) var<storage, read> bias: array<${eT?"vec4<f32>":"f32"}>;`),eL+=`
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${eT?"vec4<f32>":"f32"} {
          return bias[coords.${eb?"w":"y"}${eT?"/ 4":""}];
        }`),Object.assign(Object.assign({},en),{outputs:[{dims:ep,dataType:er[0].dataType,gpuDataType:es.GpuDataType.default}],dispatchGroup:()=>({x:eI[0],y:eI[1],z:eI[2]}),getShaderSource:()=>`
        ${el.utilFunctions}
        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,
        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,
        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };
        ${eF.join("")}
        @group(0) @binding(${eF.length}) var<storage, read_write> result: array<${eT?"vec4<f32>":"f32"}>;
        //@group(0) @binding(${eF.length+1}) var<uniform> uniforms: Uniforms;

        const xShape : vec4<i32> = vec4<i32>(${er[0].dims.join(",")});
        const wShape : vec4<i32> = vec4<i32>(${er[1].dims.join(",")});
        const outShape : vec4<i32> = vec4<i32>(${ep.join(",")});
        const outShapeStrides : vec3<i32> = vec3<i32>(${ea.ShapeUtil.computeStrides(ep).slice(0,3).join(",")});
        const filterDims : vec2<i32> = vec2<i32>(${ei.kernelShape[0]}, ${ei.kernelShape[1]});
        const pad : vec2<i32> = vec2<i32>(${ei.pads[0]}, ${ei.pads[1]});
        const stride : vec2<i32> = vec2<i32>(${ei.strides[0]}, ${ei.strides[1]});
        const dilation : vec2<i32> = vec2<i32>(${ei.dilations[0]}, ${ei.dilations[1]});
        const dimAOuter : i32 = ${ed};
        const dimBOuter : i32 = ${ef};
        const dimInner : i32 = ${eh};
        ${eL}
        ${((er,en,ei,eo,ea=!1,es,el=!1,ec=4,ep=4,ed=4)=>{let ef=er?"\n    let coord = vec4<i32>(batch, xRow, xCol, xCh);\n    ":"\n    let coord = vec4<i32>(batch, xCh, xRow, xCol);\n    ",eh=er?"\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    ":"\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    ",eg=er?"xShape[1]":"xShape[2]",em=er?"xShape[2]":"xShape[3]",eb=er?"row":"col",ey=er?"col":"row",ev=`
    let inChannels = wShape[2];
    let outWidth = ${er?"outShape[2]":"outShape[3]"};
    let outRow = ${eb} / outWidth;
    let outCol = ${eb} % outWidth;

    let WRow = ${ey} / (filterDims[1] * inChannels);
    let WCol = ${ey} / inChannels % filterDims[1];
    let xRow = outRow * stride[0] + dilation[0] * WRow - pad[0];
    let xCol = outCol * stride[1] + dilation[1] * WCol - pad[1];
    let xCh = ${ey} % inChannels;
    var resData = ${(0,eu.typeSnippet)(ec)}(0.0);
    // The bounds checking is always needed since we use it to pad zero for
    // the 'same' padding type.
    if (xRow >= 0 && xRow < ${eg} && xCol >= 0 && xCol < ${em}) {
      ${ef}
      let xIndex = getIndexFromCoords4D(coord, xShape);
      ${(er=>{switch(er){case 1:return"resData = x[xIndex];";case 3:return"resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";case 4:return"resData = x[xIndex / 4];";default:throw Error(`innerElementSize ${er} is not supported.`)}})(ec)}
    }
    return resData;`,e_=er?en&&eo?`
    let col = colIn * ${ec};
    ${ev}`:`
    let col = colIn * ${ec};
    if (row < dimAOuter && col < dimInner) {
      ${ev}
    }
    return ${(0,eu.typeSnippet)(ec)}(0.0);`:eo&&ei?`
    let col = colIn * ${ec};
    ${ev}`:`
    let col = colIn * ${ec};
    if (row < dimInner && col < dimBOuter) {
      ${ev}
    }
    return ${(0,eu.typeSnippet)(ec)}(0.0);`,ex=`${(er=>{switch(er){case 1:return"return w[row * wShape[3] + colIn];";case 4:return"return w[row * wShape[3] / 4 + colIn];";default:throw Error(`innerElementSize ${er} is not supported.`)}})(ep)}`,ew=(0,eu.typeSnippet)(ed),eT=er?(0,eu.typeSnippet)(ec):(0,eu.typeSnippet)(ep),eS=er?(0,eu.typeSnippet)(ep):(0,eu.typeSnippet)(ec);return`
    ${(0,eu.activationFnSnippet)(es,el,4===ed,4)}
    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${eT} {
      ${er?e_:ex}
    }

    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${eS} {
      ${er?ex:e_}
    }

    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${ew}) {
      let col = colIn * ${ed};
      if (row < dimAOuter && col < dimBOuter)
      {
      var value = valueIn;
      let outWidth = ${er?"outShape[2]":"outShape[3]"};
      ${eh}
      ${(0,eu.biasActivationSnippet)(ea,es)}
      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
      }
    }`})(eb,eC,eR,eM,eg,void 0,!1,eN[0],eN[1],eN[2])}
            ${eT?(0,ec.makeMatMulPackedVec4Source)(eE,eA,!eb,ek):(0,ec.makeMatMulPackedSource)(eE,eA,!eb,ek,!1,void 0,em)}`})}},4085:(er,en)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.utilFunctions=void 0,en.utilFunctions="\nfn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\n}\nfn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n    outShapeStrides.x, outShapeStrides.y, outShapeStrides.z, 1));\n}\n"},158:(er,en)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.makeMatMulPackedSource=en.makeMatMulPackedVec4Source=void 0,en.makeMatMulPackedVec4Source=(er,en,ei=!1,eo=32,ea=!1,es=32,eu=!1)=>{var el,ec;let ep=en[1]*er[1],ed=en[0]*er[0],ef=ei?ep:eo,eh=ei?eo:ep,eg=ef/en[0],em=eo/en[1];if((!ei||4!==eg||4!==er[1])&&(ei||3!==eg&&4!==eg)||ef%en[0]!=0||eo%en[1]!=0||4!==er[0])throw Error(`If transposeA ${ei} is true, innerElementSize ${eg} and workPerThread[1] ${er[1]} must be 4.
      Otherwise, innerElementSize ${eg} must be 3 or 4.
  tileAWidth ${ef} must be divisible by workgroupSize[0]${en[0]}. tileInner ${eo} must be divisible by workgroupSize[1] ${en[1]}. colPerThread ${er[0]} must be 4.`);return`
var<workgroup> mm_Asub : array<array<vec${eg}<f32>, ${ef/eg}>, ${eh}>;
var<workgroup> mm_Bsub : array<array<vec4<f32>, ${ed/er[0]}>, ${eo}>;

const rowPerThread = ${er[1]};
const colPerThread = ${er[0]};
const innerElementSize = ${eg};
const tileInner = ${eo};

@compute @workgroup_size(${en[0]}, ${en[1]}, ${en[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
  let localRow = i32(localId.y);
  let tileRow = ${eu?"0":"localRow * rowPerThread"};
  let tileCol = i32(localId.x);

  let globalRow = ${eu?"0":"i32(globalId.y) * rowPerThread"};
  let globalCol = i32(globalId.x);
  let batch = ${ea?"0":"i32(globalId.z)"};
  let globalRowStart = i32(workgroupId.y) * ${ep};

  let numTiles = ${ea?`${Math.ceil(es/eo)}`:"(dimInner - 1) / tileInner + 1"};
  var kStart = ${ea?`i32(globalId.z) * ${es}`:"0"};

  var acc: array<vec4<f32>, rowPerThread>;

  // Loop over shared dimension.
  let tileRowB = localRow * ${em};
  for (var t = 0; t < numTiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let inputRow = tileRow + innerRow;
          let inputCol = tileCol;
          ${ei?"\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          kStart + inputRow,\n          globalRowStart / innerElementSize + inputCol);\n        ":"\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          globalRow + innerRow,\n          kStart / innerElementSize + inputCol);\n        "}
      }

      // Load one tile of B into local memory.
      for (var innerRow = 0; innerRow < ${em}; innerRow = innerRow + 1) {
          let inputRow = tileRowB + innerRow;
          let inputCol = tileCol;
          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol);
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {
          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];
          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];
          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];
          ${3===eg?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}

          ${el=ei,ec=eg,el?`
        let ACached0 = mm_Asub[k * innerElementSize][localRow];
        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];
        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];
        ${3===ec?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}
        for (var i = 0; i < rowPerThread; i = i + 1) {
          acc[i] = BCached0 * ACached0[i] + acc[i];
          acc[i] = BCached1 * ACached1[i] + acc[i];
          acc[i] = BCached2 * ACached2[i] + acc[i];
          ${3===ec?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}
        }`:`
        for (var i = 0; i < rowPerThread; i = i + 1) {
          let ACached = mm_Asub[tileRow + i][k];
          acc[i] = BCached0 * ACached.x + acc[i];
          acc[i] = BCached1 * ACached.y + acc[i];
          acc[i] = BCached2 * ACached.z + acc[i];
          ${3===ec?"":"acc[i] = BCached3 * ACached.w + acc[i];"}
        }`}
      }

      workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
  }
}`};let ei=er=>er?"\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              kStart + inputRow,\n              globalRowStart + inputCol);\n            ":"\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              globalRowStart + inputRow,\n              kStart + inputCol);\n            ";en.makeMatMulPackedSource=(er,en,eo=!1,ea=32,es=!1,eu=32,el=!1)=>{let ec=er[1]*en[1],ep=er[0]*en[0],ed=eo?ec:ea,ef=eo?ea:ec;if(ef%en[1]!=0||ed%en[0]!=0||ea%en[1]!=0)throw Error(`tileAHight ${ef} must be divisible by workgroupSize[1]${en[1]}, tileAWidth ${ed} must be divisible by workgroupSize[0]${en[0]}, tileInner ${ea} must be divisible by workgroupSize[1]${en[1]}`);let eh=ef/en[1],eg=ed/en[0],em=ea/en[1],eb=el?`
    let localRow = i32(localId.y);
    let localCol = i32(localId.x);
    let globalRowStart = i32(workgroupId.y) * ${ec};
    let globalColStart = i32(workgroupId.x) * ${ep};

    // Loop over shared dimension.
    for (var t = 0; t < numTiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var inputRow = localRow; inputRow < ${ef}; inputRow = inputRow + ${en[1]}) {
        for (var inputCol = localCol; inputCol < ${ed}; inputCol = inputCol + ${en[0]}) {
          ${ei(eo)}
        }
      }
      // Load one tile of B into local memory.
      for (var inputRow = localRow; inputRow < ${ea}; inputRow = inputRow + ${en[1]}) {
            for (var inputCol = localCol; inputCol < ${ep}; inputCol = inputCol + ${en[0]}) {
          mm_Bsub[inputRow][inputCol] = mm_readB(batch,
            kStart + inputRow,
            globalColStart + inputCol);
        }
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      var BCached : array<f32, colPerThread>;
      for (var k = 0; k < tileInner; k = k + 1) {
        for (var inner = 0; inner < colPerThread; inner = inner + 1) {
          BCached[inner] = mm_Bsub[k][localCol + inner * ${en[0]}];
        }
        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let ACached = ${eo?`mm_Asub[k][localRow + innerRow * ${en[1]}];`:`mm_Asub[localRow + innerRow * ${en[1]}][k];`}
          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
            acc[innerRow][innerCol] = acc[innerRow][innerCol] +
                ACached * BCached[innerCol];
          }
        }
      }
      workgroupBarrier();
    }
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      let gRow = globalRowStart + localRow + innerRow * ${en[1]};
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        let gCol = globalColStart + localCol + innerCol * ${en[0]};
        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
      }
    }
    `:`
let tileRow = i32(localId.y) * rowPerThread;
let tileCol = i32(localId.x) * colPerThread;

let globalRow = i32(globalId.y) * rowPerThread;
let globalCol = i32(globalId.x) * colPerThread;
let globalRowStart = i32(workgroupId.y) * ${ec};

let tileRowA = i32(localId.y) * ${eh};
let tileColA = i32(localId.x) * ${eg};
let tileRowB = i32(localId.y) * ${em};
// Loop over shared dimension.
for (var t = 0; t < numTiles; t = t + 1) {
  // Load one tile of A into local memory.
  for (var innerRow = 0; innerRow < ${eh}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < ${eg}; innerCol = innerCol + 1) {
      let inputRow = tileRowA + innerRow;
      let inputCol = tileColA + innerCol;
      ${ei(eo)}
    }
  }

  // Load one tile of B into local memory.
  for (var innerRow = 0; innerRow < ${em}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
      let inputRow = tileRowB + innerRow;
      let inputCol = tileCol + innerCol;
      mm_Bsub[inputRow][inputCol] = mm_readB(batch,
        kStart + inputRow,
        globalCol + innerCol);
    }
  }
  kStart = kStart + tileInner;
  workgroupBarrier();

  // Compute acc values for a single thread.
  var BCached : array<f32, colPerThread>;
  for (var k = 0; k < tileInner; k = k + 1) {
    for (var inner = 0; inner < colPerThread; inner = inner + 1) {
      BCached[inner] = mm_Bsub[k][tileCol + inner];
    }

    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      ${eo?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];"}
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
      }
    }
  }

  workgroupBarrier();
}

for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
    mm_write(batch, globalRow + innerRow, globalCol + innerCol,
        acc[innerRow][innerCol]);
  }
}
`;return`
  var<workgroup> mm_Asub : array<array<f32, ${ed}>, ${ef}>;
  var<workgroup> mm_Bsub : array<array<f32, ${ep}>, ${ea}>;
  const rowPerThread = ${er[1]};
  const colPerThread = ${er[0]};
  const tileInner = ${ea};

@compute @workgroup_size(${en[0]}, ${en[1]}, ${en[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
    let batch = ${es?"0":"i32(globalId.z)"};
    let numTiles = ${es?`${Math.ceil(eu/ea)}`:"(dimInner - 1) / tileInner + 1"};
    var kStart = ${es?`i32(globalId.z) * ${eu}`:"0"};

    var acc : array<array<f32, colPerThread>, rowPerThread>;

    // Without this initialization strange values show up in acc.
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = 0.0;
      }
    }
    ${eb}
  }
`}},504:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.sub=en.pow=en.mul=en.div=en.add=void 0;let eo=ei(6952),ea=ei(1163),es=ei(2075),eu=(er,en,ei,eu,el)=>{let ec={name:en,inputTypes:[ea.GpuDataType.default,ea.GpuDataType.default],cacheHint:el};return Object.assign(Object.assign({},ec),{get:()=>((er,en,ei,eu,el,ec=en.dataType)=>{var ep,ed;let ef=!eo.ShapeUtil.areEqual(en.dims,ei.dims),eh=en.dims,eg=eo.ShapeUtil.size(en.dims),em=!1;if(ef){let er=eo.BroadcastUtil.calcShape(en.dims,ei.dims,!1);if(!er)throw Error("Can't perform binary op on the given tensors");eh=er,eg=eo.ShapeUtil.size(eh);let ea=1;for(let er=0;er<eh.length;er++){let eo=null!==(ep=en.dims[en.dims.length-er])&&void 0!==ep?ep:1;if(eo!==(null!==(ed=ei.dims[ei.dims.length-er])&&void 0!==ed?ed:1))break;ea*=eo}ea%4==0&&(em=!0)}else em=!0;return Object.assign(Object.assign({},er),{getShaderSource:er=>((er,en,ei,ea,eu,el,ec,ep,ed="f32",ef="f32",eh="f32")=>{let eg,em,eb;let ey=eo.ShapeUtil.size(ea),ev=Math.ceil(ey/4);"string"==typeof ec?eg=em=(er,en)=>`${ec}((${er}),(${en}))`:"function"==typeof ec?eg=em=ec:(eg=ec.scalar,em=ec.vector);let e_="",ex=(0,es.createIndicesHelper)("output",ea);if(el){let er=er=>{let en=eo.ShapeUtil.computeStrides(er),ei=[];for(let eo=er.length-1;eo>=0;eo--){let es=0===ea.length?"0u":1===ea.length?"(*outputIndices)":`(*outputIndices)[${eo+ea.length-er.length}]`;ei.push(`${en[eo]}u * (${es} % ${er[eo]}u)`)}return ei.length>0?ei.join("+"):"0u"};e_=`
  ${ex.o2iImpl}

  fn calcOffsetA(outputIndices: ptr<function, ${ex.iType}>) -> u32 {
    return ${er(en)};
  }

  fn calcOffsetB(outputIndices: ptr<function, ${ex.iType}>) -> u32 {
    return ${er(ei)};
  }
  `}if(eu)eb=el?`
      ${ex.indicesVariableDeclaration("outputIndices")}
      ${ex.o2iCall("global_idx * 4u","outputIndices")}
      let offsetA = calcOffsetA(&outputIndices);
      let offsetB = calcOffsetB(&outputIndices);
      outputData[global_idx] = ${em("aData[offsetA / 4u]","bData[offsetB / 4u]")};`:`outputData[global_idx] = ${em("aData[global_idx]","bData[global_idx]")};`;else{if(!el)throw Error("no necessary to use scalar implementation for element-wise binary op implementation.");let er=er=>{let en=`aData[indexA${er}][componentA${er}]`,ei=`bData[indexB${er}][componentB${er}]`;return`
      ${ex.o2iCall(`global_idx * 4u + ${er}u`,"outputIndices")}
      let offsetA${er} = calcOffsetA(&outputIndices);
      let offsetB${er} = calcOffsetB(&outputIndices);
      let indexA${er} = offsetA${er} / 4u;
      let indexB${er} = offsetB${er} / 4u;
      let componentA${er} = offsetA${er} % 4u;
      let componentB${er} = offsetB${er} % 4u;
      outputData[global_idx][${er}] = ${eg(en,ei)};`};eb=`
      ${ex.indicesVariableDeclaration("outputIndices")}
      ${er(0)}
      ${er(1)}
      ${er(2)}
      ${er(3)}`}return`
  @group(0) @binding(0) var<storage, read> aData : array<vec4<${ed}>>;
  @group(0) @binding(1) var<storage, read> bData : array<vec4<${ef}>>;
  @group(0) @binding(2) var<storage, read_write> outputData : array<vec4<${eh}>>;

  ${null!=ep?ep:""}
  ${e_}

  ${er.mainStart()}
    ${er.guardAgainstOutOfBoundsWorkgroupSizes(ev)}
    ${eb}
  }`})(er,en.dims,ei.dims,eh,em,ef,eu,el),outputs:[{dims:eh,dataType:ec,gpuDataType:ea.GpuDataType.default}],dispatchGroup:()=>({x:Math.ceil(eg/64/(em?4:1))})})})(ec,er[0],er[1],ei,eu)})};en.add=er=>{er.compute(eu(er.inputs,"Add",(er,en)=>`${er}+${en}`))},en.div=er=>{er.compute(eu(er.inputs,"Div",(er,en)=>`${er}/${en}`))},en.mul=er=>{er.compute(eu(er.inputs,"Mul",(er,en)=>`${er}*${en}`))},en.pow=er=>{er.compute(eu(er.inputs,"Pow",{scalar:(er,en)=>`pow_f32(${er},${en})`,vector:(er,en)=>`pow_vf32(${er},${en})`},"\n    fn pow_f32(a : f32, b : f32) -> f32 {\n      if (b == 0.0) {\n        return 1.0;\n      } else if (a < 0.0 && b != floor(b)) {\n        return pow(a, b); // NaN\n      }\n      return select(sign(a), 1.0, round(abs(b) % 2.0) != 1.0) * pow(abs(a), b);\n    }\n    fn pow_vf32(a : vec4<f32>, b : vec4<f32>) -> vec4<f32> {\n      // TODO: implement vectorized pow\n      return vec4<f32>(pow_f32(a.x, b.x), pow_f32(a.y, b.y), pow_f32(a.z, b.z), pow_f32(a.w, b.w));\n    }\n      "))},en.sub=er=>{er.compute(eu(er.inputs,"Sub",(er,en)=>`${er}-${en}`))}},2075:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.createShaderHelper=en.createIndicesHelper=en.WORKGROUP_SIZE=void 0;let eo=ei(6952);en.WORKGROUP_SIZE=64,en.createIndicesHelper=(er,en)=>{let ei=en.length<2?"u32":`array<u32, ${en.length}>`,ea=eo.ShapeUtil.computeStrides(en),es="";for(let er=0;er<en.length-1;er++)es+=`
    let dim${er} = current / ${ea[er]}u;
    let rest${er} = current % ${ea[er]}u;
    (*indices)[${er}] = dim${er};
    current = rest${er};
    `;es+=`(*indices)[${en.length-1}] = current;`;let eu=en.length<2?"":`
  fn ih_o2i_${er}(offset: u32, indices: ptr<function, ${ei}>) {
    var current = offset;
    ${es}
  }`,el=[];if(0===en.length)el.push("0u");else if(en.length<2)el.push("(*indices)");else for(let er=en.length-1;er>=0;er--)el.push(`${ea[er]}u * ((*indices)[${er}])`);return{o2iImpl:eu,o2iCall:(ei,eo)=>en.length<2?`${eo}=${ei};`:`ih_o2i_${er}(${ei}, &${eo});`,i2oImpl:en.length<2?"":`
  fn ih_i2o_${er}(indices: ptr<function, ${ei}>) -> u32 {
    return ${el.join("+")};
  }`,i2oExpression:(ei,eo)=>en.length<2?`(${eo?"*":""}${ei})`:`ih_i2o_${er}(${eo?"":"&"}${ei})`,indicesVariableDeclaration:(er,en)=>`var ${er}:${ei}${en?`=${ei}(${en.join(",")})`:""};`,iType:ei}};class ea{constructor(er){this.normalizedDispatchGroup=er}guardAgainstOutOfBoundsWorkgroupSizes(er){return`if (global_idx >= ${"number"==typeof er?`${er}u`:er}) { return; }`}mainStart(er=en.WORKGROUP_SIZE){let ei="number"==typeof er?er:er[0],eo="number"==typeof er?1:er[1],ea="number"==typeof er?1:er[2],es=1===this.normalizedDispatchGroup[1]&&1===this.normalizedDispatchGroup[2];return`@compute @workgroup_size(${ei}, ${eo}, ${ea})
  fn main(${es?"@builtin(global_invocation_id) global_id : vec3<u32>":"@builtin(local_invocation_index) local_index : u32,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>"}) {
    ${es?"let global_idx = global_id.x;":`let global_idx = (workgroup_id.z * ${this.normalizedDispatchGroup[0]*this.normalizedDispatchGroup[1]}u +
          workgroup_id.y * ${this.normalizedDispatchGroup[0]}u + workgroup_id.x) * ${ei*eo*ea}u + local_index;`}
  `}}en.createShaderHelper=er=>new ea(er)},9192:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.createGroupedConvProgramInfoLoader=void 0;let eo=ei(6952),ea=ei(1163),es=ei(2075),eu=ei(9770),el=ei(3997);en.createGroupedConvProgramInfoLoader=(er,en,ei)=>{var ec,ep;let ed=(ec=er.length>2,ep=en.cacheKey,{name:"GroupedConv",inputTypes:ec?[ea.GpuDataType.default,ea.GpuDataType.default,ea.GpuDataType.default]:[ea.GpuDataType.default,ea.GpuDataType.default],cacheHint:ep});return Object.assign(Object.assign({},ed),{get:()=>((er,en,ei,ec)=>{let ep=er.length>2,ed=ep?"value += b[output_channel];":"",ef=er[0].dims,eh=er[1].dims,eg=eh[0]/ei.group,em="f32",{activationFunction:eb,applyActivation:ey}=(0,el.getActicationSnippet)(ei),ev=[`@group(0) @binding(0) var<storage, read> x : array<${em}>;`,`@group(0) @binding(1) var<storage, read> w : array<${em}>;`];ep&&ev.push(`@group(0) @binding(2) var<storage, read> b : array<${em}>;`);let e_="NHWC"===ei.format,ex=(0,eu.calculateOutputShape)(ef,eh,ei.dilations,ei.pads,ei.strides,e_),ew=eo.ShapeUtil.size(ex),eT=(0,es.createIndicesHelper)("output",ex),eS=(0,es.createIndicesHelper)("x",ef),eO=(0,es.createIndicesHelper)("w",eh);return Object.assign(Object.assign({},en),{outputs:[{dims:ec?ec(ex):ex,dataType:er[0].dataType,gpuDataType:ea.GpuDataType.default}],getShaderSource:er=>`
  const strides: vec2<u32> = vec2(${ei.strides[0]}u, ${ei.strides[1]}u);
  const pads: vec2<u32> = vec2(${ei.pads[0]}u, ${ei.pads[1]}u);

  ${ev.join("\n")}
  @group(0) @binding(${ev.length}) var<storage, read_write> output : array<${em}>;

  ${eb}
  ${eT.o2iImpl}
  ${eS.i2oImpl}
  ${eO.i2oImpl}

  ${er.mainStart()}
    ${er.guardAgainstOutOfBoundsWorkgroupSizes(ew)}

    ${eT.indicesVariableDeclaration("outputIndices")}
    ${eT.o2iCall("global_idx","outputIndices")}
    let batch: u32 = outputIndices[0];
    let output_channel: u32 = outputIndices[${e_?3:1}];
    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${e_?1:2}], outputIndices[${e_?2:3}]) * strides - pads;
    let group_id: u32 = output_channel / ${eg}u;

    var value: ${em} = ${em}(0);
    for (var wInChannel: u32 = 0u; wInChannel < ${eh[1]}u; wInChannel++) {
      let input_channel = group_id * ${eh[1]}u + wInChannel;
      for (var wHeight: u32 = 0u; wHeight < ${eh[2]}u; wHeight++) {
        let xHeight = xRCCorner.x + wHeight * ${ei.dilations[0]}u;

        if (xHeight < 0u || xHeight >= ${ef[e_?1:2]}u) {
          continue;
        }

        for (var wWidth: u32 = 0u; wWidth < ${eh[3]}u; wWidth++) {
          let xWidth = xRCCorner.y + wWidth * ${ei.dilations[1]}u;
          if (xWidth < 0u || xWidth >= ${ef[e_?2:3]}u) {
            continue;
          }

          ${eS.indicesVariableDeclaration("xIndices",e_?["batch","xHeight","xWidth","input_channel"]:["batch","input_channel","xHeight","xWidth"])}
          let xVal = x[${eS.i2oExpression("xIndices")}];
          ${eO.indicesVariableDeclaration("wIndices",["output_channel","wInChannel","wHeight","wWidth"])}
          let wVal = w[${eO.i2oExpression("wIndices")}];
          value += xVal*wVal;
        }
      }
    }
    ${ed}
    ${ey}
    output[global_idx] = value;
  }`,dispatchGroup:()=>({x:Math.ceil(ew/64)})})})(er,ed,en,ei)})}},9770:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.conv=en.parseConvAttributes=en.calculateOutputShape=void 0;let eo=ei(6952),ea=ei(387),es=ei(9192),eu=ei(3822),el=ei(3997),ec=ei(2625);en.calculateOutputShape=(er,en,ei,eo,ea,es)=>{let eu=er[0],el=er.slice(es?1:2,es?3:4),ec=el.length,ep=en[0],ed=en.slice(2).map((er,en)=>er+(er-1)*(ei[en]-1)),ef=el.map((er,en)=>er+eo[en]+eo[en+ec]).map((er,en)=>Math.floor((er-ed[en]+ea[en])/ea[en]));return ef.splice(0,0,eu),ef.splice(es?3:1,0,ep),ef};let ep=(0,ea.createAttributeWithCacheKey)({perm:[2,3,1,0]}),ed=(er,en)=>{let ei=er.kernelShape.slice();for(let er=2;er<en[1].dims.length;++er)0===ei[er-2]&&(ei[er-2]=en[1].dims[er]);let ea=er.pads.slice();eo.PoolConvUtil.adjustPadsBasedOnAutoPad(en[0].dims,er.strides,er.dilations,ei,ea,"NHWC"===er.format,er.autoPad);let es=Object.assign({},er);return Object.assign(es,{kernelShape:ei,pads:ea,cacheKey:er.cacheKey}),es};en.parseConvAttributes=er=>{let en=(0,el.parseInternalActivationAttributes)(er),ei=er.format,eo=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][er.auto_pad],es=er.dilations,eu=er.group,ec=er.kernel_shape,ep=er.pads,ed=er.strides,ef=er.w_is_const();return(0,ea.createAttributeWithCacheKey)(Object.assign({autoPad:eo,format:ei,dilations:es,group:eu,kernelShape:ec,pads:ep,strides:ed,wIsConst:ef},en))},en.conv=(er,ei)=>{((er,en)=>{if(!er||2!==er.length&&3!==er.length)throw Error("Conv requires 2 or 3 inputs");if(4!==er[0].dims.length&&3!==er[0].dims.length)throw Error("currently only support conv 1D and 2D");if(er[0].dims.length!==er[1].dims.length)throw Error("filter does not have same dimension as input");if(er[0].dims["NHWC"===en.format?er[0].dims.length-1:1]!==er[1].dims[1]*en.group)throw Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(3===er.length&&(1!==er[2].dims.length||er[1].dims[0]!==er[2].dims[0]))throw Error("invalid bias");let ei=er[0].dims.length-2;if(en.dilations.length!==ei)throw Error(`dilations should be ${ei}D`);if(en.strides.length!==ei)throw Error(`strides should be ${ei}D`);if(en.pads.length!==2*ei)throw Error(`pads should be ${2*ei}D`);if(0!==en.kernelShape.length&&en.kernelShape.length!==er[1].dims.length-2)throw Error("invalid kernel shape");if(1!==er[0].dataType||1!==er[1].dataType)throw Error("Conv input(X,W) should be float tensor");if(3===er.length&&1!==er[2].dataType)throw Error("Conv input(bias) should be float tensor")})(er.inputs,ei),3===er.inputs[0].dims.length?((er,en)=>{let ei="NHWC"===en.format,eo=[er.inputs[0].reshape(ei?[er.inputs[0].dims[0],1,er.inputs[0].dims[1],er.inputs[0].dims[2]]:[er.inputs[0].dims[0],er.inputs[0].dims[1],1,er.inputs[0].dims[2]]),er.inputs[1].reshape([er.inputs[1].dims[0],er.inputs[1].dims[1],1,er.inputs[1].dims[2]])];3===er.inputs.length&&eo.push(er.inputs[2]);let ea=[0,en.pads[0],0,en.pads[1]],eu=[1].concat(en.strides),el=[1].concat(en.dilations),ec=[1].concat(en.kernelShape),ep=ed(Object.assign(Object.assign({},en),{pads:ea,strides:eu,dilations:el,kernelShape:ec}),eo);er.compute((0,es.createGroupedConvProgramInfoLoader)(eo,ep,er=>ei?[er[0],er[2],er[3]]:[]))})(er,ei):((er,ei,eo)=>{var ea;let el=ed(eo,ei),ef=3===ei.length,eh="NHWC"===eo.format,eg=ei[0].dims[eh?1:2],em=ei[0].dims[eh?2:3],eb=ei[0].dims[eh?3:1],ey=ei[1].dims[2],ev=ei[1].dims[3],e_=(0,en.calculateOutputShape)(ei[0].dims,ei[1].dims,eo.dilations,el.pads,eo.strides,eh),ex=e_[eh?1:2],ew=e_[eh?2:3],eT=e_[eh?3:1];if(eh&&ey===eg&&ev===em&&"VALID"===eo.autoPad||1===ey&&1===ev&&1===eo.dilations[0]&&1===eo.dilations[1]&&1===eo.strides[0]&&1===eo.strides[1]&&("SAME_UPPER"===eo.autoPad||"SAME_LOWER"===eo.autoPad||"VALID"===eo.autoPad)||!eh||1!==eo.group)return void er.compute((0,es.createGroupedConvProgramInfoLoader)(ei,el));let eS=eh?ex*ew:eT,eO=eh?eT:ex*ew,eA=ey*ev*eb,eE=null!==(ea=er.customData.wT)&&void 0!==ea?ea:er.compute(Object.assign(Object.assign({},ec.transposeProgramMetadata),{cacheHint:ep.cacheKey,get:()=>(0,ec.createTransposeProgramInfo)(ei[1],ep.perm)}),{inputs:[1],outputs:[eo.wIsConst?-2:-1]})[0];eo.wIsConst&&!er.customData.wT&&(er.customData.wT=eE);let eI=[ei[0],eE];ef&&(eh||1!==ei[2].dims.length?eI.push(ei[2]):eI.push(ei[2].reshape([ei[2].dims[0],1,1]))),er.compute((0,eu.createConv2DMatMulProgramInfoLoader)(eI,el,e_,eS,eO,eA,ef,!0),{inputs:eI})})(er,er.inputs,ei)}},3822:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.createConv2DMatMulProgramInfoLoader=void 0;let eo=ei(1163),ea=ei(9456);en.createConv2DMatMulProgramInfoLoader=(er,en,ei,es,eu,el,ec,ep)=>{var ed,ef;let eh=(ed=ec,ef=en.cacheKey,{name:"Conv2DMatMul",inputTypes:ed?[eo.GpuDataType.default,eo.GpuDataType.default,eo.GpuDataType.default]:[eo.GpuDataType.default,eo.GpuDataType.default],cacheHint:ef});return Object.assign(Object.assign({},eh),{get:()=>(0,ea.createConv2DMatMulProgramInfo)(er,eh,en,ei,es,eu,el,ec,ep)})}},3997:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.parseInternalActivationAttributes=en.getActicationSnippet=void 0;let eo=ei(6952);en.getActicationSnippet=er=>{switch(er.activation){case"Relu":return{activationFunction:"",applyActivation:"value = max(value, 0.0);"};case"Sigmoid":return{activationFunction:"",applyActivation:"value = (1.0 / (1.0 + exp(-value)));"};case"Clip":return{activationFunction:`const clip_min_=f32(${er.clipMin});const clip_max_=f32(${er.clipMax});`,applyActivation:"value = clamp(value, clip_min_, clip_max_);"};default:return{activationFunction:"",applyActivation:""}}},en.parseInternalActivationAttributes=er=>{let en=(null==er?void 0:er.activation)||"";if("Clip"===en){let[ei,ea]=(null==er?void 0:er.activation_params)||[eo.MIN_CLIP,eo.MAX_CLIP];return{activation:en,clipMax:ea,clipMin:ei,activationCacheKey:`${en}:${ei},${ea}`}}return{activation:en,activationCacheKey:en}}},4271:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.parseGemmAttributes=en.gemm=void 0;let eo=ei(6952),ea=ei(387),es=ei(1163);en.gemm=(er,en)=>{(er=>{if(!er)throw Error("Input is missing");if(er.length<2||er.length>3)throw Error("Invaid input number.");if(3===er.length&&er[2].dims.length>2)throw Error("Invalid input shape of C");if(1!==er[0].dataType||1!==er[1].dataType||3===er.length&&1!==er[2].dataType)throw Error("Invalid input type.");if(er[0].dataType!==er[1].dataType||3===er.length&&er[0].dataType!==er[2].dataType)throw Error("Input types are mismatched")})(er.inputs),er.compute(((er,en)=>{let ei={name:"Gemm",inputTypes:3===er.length?[es.GpuDataType.default,es.GpuDataType.default,es.GpuDataType.default]:[es.GpuDataType.default,es.GpuDataType.default],cacheHint:en.cacheKey};return Object.assign(Object.assign({},ei),{get:()=>((er,en,ei)=>{let ea=en[0].dims.slice(),eu=en[1].dims.slice(),[el,ec,ep]=eo.GemmUtil.getShapeOfGemmResult(ea,ei.transA,eu,ei.transB,3===en.length?en[2].dims:void 0),ed=[el,ec];if(!ed)throw Error("Can't use gemm on the given tensors");let ef=eo.ShapeUtil.size(ed),eh="";ei.transA&&ei.transB?eh="value += a[k * M + m] * b[n * K + k];":ei.transA&&!ei.transB?eh="value += a[k * M + m] * b[k * N + n];":!ei.transA&&ei.transB?eh="value += a[m * K + k] * b[n * K + k];":ei.transA||ei.transB||(eh="value += a[m * K + k] * b[k * N + n];");let eg="f32",em=1===ei.alpha?"":"value *= alpha;",eb=3===en.length?`value += beta * c[${((er,en,ei)=>{if(0===ei.length)return"0u";let eo=1===ei.length&&1!==er||2===ei.length&&ei[0]!==er,ea=ei[ei.length-1]!==en,es="0u";return eo||(es+=`+ m * ${ei[ei.length-1]}u`),ea||(es+="+n"),es})(el,ec,en[2].dims)}];`:"",ey=[`@group(0) @binding(0) var<storage, read> a : array<${eg}>;`,`@group(0) @binding(1) var<storage, read> b : array<${eg}>;`];return 3===en.length&&ey.push(`@group(0) @binding(2) var<storage, read> c : array<${eg}>;`),Object.assign(Object.assign({},er),{outputs:[{dims:ed,dataType:en[0].dataType,gpuDataType:es.GpuDataType.default}],getShaderSource:er=>`
  const M: u32 = ${el}u;
  const N: u32 = ${ec}u;
  const K: u32 = ${ep}u;
  const alpha = ${eg}(${ei.alpha});
  const beta = ${eg}(${ei.beta});

  ${ey.join("\n")}
  @group(0) @binding(${en.length}) var<storage, read_write> output : array<${eg}>;

  ${er.mainStart()}
    ${er.guardAgainstOutOfBoundsWorkgroupSizes(ef)}

    let m = global_id.x / N;
    let n = global_id.x % N;

    var value = ${eg}(0);
    for (var k: u32 = 0u; k<${ep}u; k++) {
      ${eh}
    }

    ${em}
    ${eb}
    output[global_id.x] = value;

  }`,dispatchGroup:()=>({x:Math.ceil(ef/64)})})})(ei,er,en)})})(er.inputs,en))},en.parseGemmAttributes=er=>(0,ea.createAttributeWithCacheKey)(er)},1522:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.matMul=en.createMatmulProgramInfoLoader=void 0;let eo=ei(6952),ea=ei(1163),es=ei(3997);en.createMatmulProgramInfoLoader=(er,en)=>{var ei,eu;let el=(ei=er.length>2,eu=en.activationCacheKey,{name:"MatMul",inputTypes:ei?[ea.GpuDataType.default,ea.GpuDataType.default,ea.GpuDataType.default]:[ea.GpuDataType.default,ea.GpuDataType.default],cacheHint:eu});return Object.assign(Object.assign({},el),{get:()=>((er,en,ei)=>{let eu=en[0].dims,el=en[1].dims,ec=eo.BroadcastUtil.calcShape(eu,el,!0);if(!ec)throw Error("Can't use matmul on the given tensors");let ep=eo.ShapeUtil.size(ec),ed="f32",{activationFunction:ef,applyActivation:eh}=(0,es.getActicationSnippet)(ei),eg=ec[ec.length-2],em=eu[eu.length-1],eb=ec[ec.length-1];return Object.assign(Object.assign({},er),{outputs:[{dims:ec,dataType:en[0].dataType,gpuDataType:ea.GpuDataType.default}],getShaderSource:er=>`
  const M: u32 = ${eg}u;
  const N: u32 = ${eb}u;
  const K: u32 = ${em}u;

  @group(0) @binding(0) var<storage, read> a : array<${ed}>;
  @group(0) @binding(1) var<storage, read> b : array<${ed}>;
  @group(0) @binding(2) var<storage, read_write> output : array<${ed}>;

  ${ef}

  ${er.mainStart()}
    ${er.guardAgainstOutOfBoundsWorkgroupSizes(ep)}

    let stack = global_idx / (M * N);
    let mn = global_idx % (M * N);
    let n = global_idx % N;
    let m = mn / N;

    let offsetA = stack * (M * K);
    let offsetB = stack * (K * N);

    var value = ${ed}(0);
    for (var k: u32 = 0u; k<${em}u; k++) {
      value += a[offsetA + m * K + k] * b[offsetB + k * N + n];
    }
    ${eh}
    output[global_idx] = value;
  }`,dispatchGroup:()=>({x:Math.ceil(ep/64)})})})(el,er,en)})},en.matMul=er=>{(er=>{if(!er||2!==er.length)throw Error("MatMul requires 2 inputs.");if(er[0].dims[er[0].dims.length-1]!==er[1].dims[er[1].dims.length-2])throw Error("shared dimension does not match.");if(1!==er[0].dataType||1!==er[1].dataType)throw Error("inputs should be float type")})(er.inputs),er.compute((0,en.createMatmulProgramInfoLoader)(er.inputs,{activation:"",activationCacheKey:""}))}},5262:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.globalMaxPool=en.parseGlobalMaxPoolAttributes=en.parseMaxPoolAttributes=en.maxPool=en.globalAveragePool=en.parseGlobalAveragePoolAttributes=en.averagePool=en.parseAveragePoolAttributes=void 0;let eo=ei(6952),ea=ei(387),es=ei(1163),eu=ei(2075),el=er=>{if(!er||1!==er.length)throw Error("Pool ops requires 1 input.");if(4!==er[0].dims.length)throw Error("Pool ops supports 2-D inputs only for now.");if(1!==er[0].dataType)throw Error("Invalid input type.")},ec=(er,en,ei)=>{let ea="NHWC"===en.format,es=ea?[er[0].dims[0],er[0].dims[3],er[0].dims[1],er[0].dims[2]]:er[0].dims.slice(),eu=Object.hasOwnProperty.call(en,"dilations"),el=en.kernelShape.slice(),ec=en.strides.slice(),ep=eu?en.dilations.slice():[],ed=en.pads.slice();eo.PoolConvUtil.adjustPoolAttributes(ei,es,el,ec,ep,ed);let ef=eo.PoolConvUtil.computePoolOutputShape(ei,es,ec,ep,el,ed,en.autoPad),eh=Object.assign({},en);return eu?Object.assign(eh,{kernelShape:el,strides:ec,pads:ed,dilations:ep,cacheKey:en.cacheKey}):Object.assign(eh,{kernelShape:el,strides:ec,pads:ed,cacheKey:en.cacheKey}),[eh,ea?[ef[0],ef[2],ef[3],ef[1]]:ef]},ep=(er,en,ei,ea,es,el,ec,ep)=>{let ed="NHWC"===ea.format,ef=en.length,eh=eo.ShapeUtil.size(ei),eg=(0,eu.createIndicesHelper)("output",ei),em=(0,eu.createIndicesHelper)("x",en);if(ea.kernelShape.length<=2){let ei=ea.kernelShape[ea.kernelShape.length-1],eo=ea.strides[ea.strides.length-1],eu=ea.pads[ea.pads.length/2-1],eb=ef-(ed?2:1),ey="",ev="",e_="";if(ey=eu+ea.pads[ea.pads.length-1]!==0?`
              for (var i: u32 = 0u; i < ${ei}u; i++) {
                xIndices[${eb}] = indices[${eb}] * ${eo} - ${eu} + i;
                if (xIndices[${eb}] < 0 || xIndices[${eb}] >= ${en[eb]}) {
                  pad++;
                  continue;
                }
                let x_val = x[${em.i2oExpression("xIndices")}];
                ${es}
              }`:`
              for (var i: u32 = 0u; i < ${ei}u; i++) {
                xIndices[${eb}] = indices[${eb}] * ${eo} - ${eu} + i;
                let x_val = x[${em.i2oExpression("xIndices")}];
                ${es}
              }`,2===ea.kernelShape.length){let er=ea.kernelShape[ea.kernelShape.length-2],eo=ea.strides[ea.strides.length-2],es=ea.pads[ea.pads.length/2-2],eu=ea.pads[ea.pads.length-2],el=ef-(ed?3:2),ec=en[el];ev=es+eu!==0?`
                for (var j: u32 = 0u; j < ${er}u; j++) {
                  xIndices[${el}] = indices[${el}] * ${eo} - ${es} + j;
                  if (xIndices[${el}] < 0 || xIndices[${el}] >= ${ec}) {
                    pad+= ${ei};
                    continue;
                  }
              `:`
                for (var j: u32 = 0u; j < ${er}u; j++) {
                  xIndices[${el}] = indices[${el}] * ${eo} - ${es} + j;
                `,e_="\n              }\n            "}return`
            @group(0) @binding(0) var<storage, read> x : array<${ec}>;
            @group(0) @binding(1) var<storage, read_write> output : array<${ec}>;

            ${eg.o2iImpl}
            ${em.i2oImpl}

            ${er.mainStart()}
              ${er.guardAgainstOutOfBoundsWorkgroupSizes(eh)}

              ${eg.indicesVariableDeclaration("indices")}
              ${eg.o2iCall("global_idx","indices")}
              ${eg.indicesVariableDeclaration("xIndices")}
              ${eg.o2iCall("global_idx","xIndices")}

              var value: ${ec} = ${ec}(${ep});
              var pad = 0;
              ${ev}
              ${ey}
              ${e_}
              ${el}

              output[global_idx] = value;
            }`}{if(ed)throw Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let ei=eo.ShapeUtil.size(ea.kernelShape),eu=eo.ShapeUtil.computeStrides(ea.kernelShape),eb=eu.length,ey=ea.pads.length,ev="";return`
            @group(0) @binding(0) var<storage, read> x : array<${ec}>;
            @group(0) @binding(1) var<storage, read_write> output : array<${ec}>;

            ${eg.o2iImpl}
            ${em.i2oImpl}

            const pads = array<u32, ${ey}>(${ea.pads.map(er=>`${er}u`).join(",")});
            const inputDims = array<u32, ${ef}>(${en.map(er=>`${er}u`).join(",")});
            const kernelStrides = array<u32, ${eb}>(${eu.map(er=>`${er}u`).join(",")});
            const strides = array<u32, ${eb}>(${ea.strides.map(er=>`${er}u`).join(",")});

            ${er.mainStart()}
              ${er.guardAgainstOutOfBoundsWorkgroupSizes(eh)}

              ${eg.indicesVariableDeclaration("indices")}
              ${eg.o2iCall("global_idx","indices")}
              ${eg.indicesVariableDeclaration("xIndices")}
              ${eg.o2iCall("global_idx","xIndices")}

              var offsets: array<u32, ${eb}>;

              var value = ${ec}(${ep});
              var pad = 0;
              var isPad = false;

              for (var i: u32 = 0u; i < ${ei}u; i++) {
                var offset = i;
                for (var j = 0u; j < ${eb-1}u; j++) {
                  offsets[j] = offset / kernelStrides[j];
                  offset -= offsets[j] * kernelStrides[j];
                }
                offsets[${eb-1}] = offset;

                isPad = false;
                for (var j = ${ef-eb}u; j < ${ef}u; j++) {
                  xIndices[j] = indices[j] * strides[j - ${ef-eb}u]
                    + offsets[j - ${ef-eb}u] - pads[j - 2u];
                  ${ev=ea.pads.reduce((er,en)=>er+en)?`
                if (xIndices[j] >= inputDims[j]) {
                  pad++;
                  isPad = true;
                  break;
                }
              }
              if (!isPad) {
                let x_val = x[${em.i2oExpression("xIndices")}];
                ${es}
              }`:`
              }
              let x_val = x[${em.i2oExpression("xIndices")}];
              ${es}
            `}
              }
              ${el}

              output[global_idx] = value;
            }`}},ed=er=>({format:er.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][er.auto_pad],ceilMode:er.ceil_mode,kernelShape:er.kernel_shape,strides:er.strides,pads:er.pads}),ef=(er,en,ei,ea)=>{let[eu,el]=ec(er,ea,ei),ed=eo.ShapeUtil.size(eu.kernelShape),ef="f32",eh="";return eu.countIncludePad?eh+=`value /= ${ef}(${ed});`:eh+=`value /= ${ef}(${ed} - pad);`,Object.assign(Object.assign({},en),{outputs:[{dims:el,dataType:er[0].dataType,gpuDataType:es.GpuDataType.default}],getShaderSource:en=>ep(en,er[0].dims,el,eu,"value += x_val;",eh,ef,"0.0"),dispatchGroup:()=>({x:Math.ceil(eo.ShapeUtil.size(el)/64)})})};en.parseAveragePoolAttributes=er=>{let en=0!==er.count_include_pad,ei=ed(er);if(0!==ei.ceilMode)throw Error("using ceil() in shape computation is not yet supported for AveragePool");return(0,ea.createAttributeWithCacheKey)(Object.assign({countIncludePad:en},ei))},en.averagePool=(er,en)=>{el(er.inputs);let ei={name:"AveragePool",inputTypes:[es.GpuDataType.default],cacheHint:en.cacheKey};er.compute(Object.assign(Object.assign({},ei),{get:()=>ef(er.inputs,ei,!1,en)}))};let eh={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""};en.parseGlobalAveragePoolAttributes=er=>{let en=er.format;return Object.assign(Object.assign({format:en},eh),{cacheKey:en})},en.globalAveragePool=(er,en)=>{el(er.inputs);let ei={name:"GlobalAveragePool",inputTypes:[es.GpuDataType.default],cacheHint:en.cacheKey};er.compute(Object.assign(Object.assign({},ei),{get:()=>ef(er.inputs,ei,!0,en)}))};let eg=(er,en,ei,ea)=>{let[eu,el]=ec(er,ea,ei);return Object.assign(Object.assign({},en),{outputs:[{dims:el,dataType:er[0].dataType,gpuDataType:es.GpuDataType.default}],getShaderSource:en=>ep(en,er[0].dims,el,eu,"\n      value = max(x_val, value);\n    ","","f32","-1e5"),dispatchGroup:()=>({x:Math.ceil(eo.ShapeUtil.size(el)/64)})})};en.maxPool=(er,en)=>{el(er.inputs);let ei={name:"MaxPool",inputTypes:[es.GpuDataType.default],cacheHint:en.cacheKey};er.compute(Object.assign(Object.assign({},ei),{get:()=>eg(er.inputs,ei,!1,en)}))},en.parseMaxPoolAttributes=er=>{let en=er.storage_order,ei=er.dilations,eo=ed(er);if(0!==en)throw Error("column major storage order is not yet supported for MaxPool");if(0!==eo.ceilMode)throw Error("using ceil() in shape computation is not yet supported for MaxPool");return(0,ea.createAttributeWithCacheKey)(Object.assign({storageOrder:en,dilations:ei},eo))},en.parseGlobalMaxPoolAttributes=er=>{let en=er.format;return Object.assign(Object.assign({format:en},eh),{cacheKey:en})},en.globalMaxPool=(er,en)=>{el(er.inputs);let ei={name:"GlobalMaxPool",inputTypes:[es.GpuDataType.default],cacheHint:en.cacheKey};er.compute(Object.assign(Object.assign({},ei),{get:()=>eg(er.inputs,ei,!0,en)}))}},2625:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.parseTransposeAttributes=en.transpose=en.createTransposeProgramInfo=en.transposeProgramMetadata=void 0;let eo=ei(6952),ea=ei(387),es=ei(1163),eu=ei(2075);en.transposeProgramMetadata={name:"Transpose",inputTypes:[es.GpuDataType.default]};let el=(er,en)=>en&&en.length!==er.length?[...er.keys()].reverse():en;en.createTransposeProgramInfo=(er,ei)=>{var ea,ec;let ep=er.dims,ed=el(ep,ei),ef=(ea=ep,ec=ed,eo.ShapeUtil.sortBasedOnPerm(ea,el(ea,ec))),eh=ep.length,eg=eo.ShapeUtil.size(ef),em=(0,eu.createIndicesHelper)("output",ef),eb=(0,eu.createIndicesHelper)("a",ep);return Object.assign(Object.assign({},en.transposeProgramMetadata),{outputs:[{dims:ef,dataType:er.dataType,gpuDataType:es.GpuDataType.default}],getShaderSource:er=>`
  @group(0) @binding(0) var<storage, read> a : array<f32>;
  @group(0) @binding(1) var<storage, read_write> output : array<f32>;

  ${((er,en)=>{let ei=[];ei.push(`fn perm(a: ptr<function, array<u32, ${en}>>, i: ptr<function, array<u32, ${en}>>) {`);for(let eo=0;eo<en;++eo)ei.push(`	(*a)[${er[eo]}]=(*i)[${eo}];`);return ei.push("	}"),ei.join("\n")})(ed,eh)}
  ${em.o2iImpl}
  ${eb.i2oImpl}

  ${er.mainStart()}
    ${er.guardAgainstOutOfBoundsWorkgroupSizes(eg)}

    ${em.indicesVariableDeclaration("indices")}
    ${em.o2iCall("global_idx","indices")}
    ${eb.indicesVariableDeclaration("aIndices")}
    perm(&aIndices, &indices);

    output[global_idx] = a[${eb.i2oExpression("aIndices")}];
  }`,dispatchGroup:()=>({x:Math.ceil(eg/64)})})},en.transpose=(er,ei)=>{(er=>{if(!er||1!==er.length)throw Error("Transpose requires 1 input.");if(1!==er[0].dataType)throw Error("input should be float tensor")})(er.inputs),er.compute(Object.assign(Object.assign({},en.transposeProgramMetadata),{cacheHint:ei.cacheKey,get:()=>(0,en.createTransposeProgramInfo)(er.inputs[0],ei.perm)}))},en.parseTransposeAttributes=er=>(0,ea.createAttributeWithCacheKey)({perm:er.perm})},9302:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.thresholdedRelu=en.tanh=en.tan=en.sqrt=en.sinh=en.sin=en.sigmoid=en.relu=en.reciprocal=en.neg=en.leakyRelu=en.floor=en.exp=en.erf=en.elu=en.parseAlphaAttributes=en.cosh=en.cos=en.ceil=en.clip=en.clipV10=en.atanh=en.atan=en.asinh=en.asin=en.acosh=en.acos=en.abs=void 0;let eo=ei(6952),ea=ei(387),es=ei(1163),eu=(er,en,ei,ea,eu)=>{let el={name:en,inputTypes:[es.GpuDataType.default],cacheHint:eu};return Object.assign(Object.assign({},el),{get:()=>{var en,eu,ec,ep;return en=el,eu=er,ec=ei,ep=ea,Object.assign(Object.assign({},en),{getShaderSource:er=>((er,en,ei,eo)=>{let ea=Math.ceil(en/4),es="";return`
  @group(0) @binding(0) var<storage, read> inputData : array<vec4<f32>>;
  @group(0) @binding(1) var<storage, read_write> outputData : array<vec4<f32>>;

  ${null!=eo?eo:""}

  ${er.mainStart()}
    ${er.guardAgainstOutOfBoundsWorkgroupSizes(ea)}

    let a = inputData[global_idx];
    outputData[global_idx] = ${es="string"==typeof ei?`${ei}(a)`:ei("a")};
  }`})(er,eo.ShapeUtil.size(eu.dims),ec,ep),outputs:[{dims:eu.dims,dataType:eu.dataType,gpuDataType:es.GpuDataType.default}],dispatchGroup:er=>({x:Math.ceil(eo.ShapeUtil.size(er[0].dims)/64/4)})})}})};en.abs=er=>{er.compute(eu(er.inputs[0],"Abs","abs"))},en.acos=er=>{er.compute(eu(er.inputs[0],"Acos","acos"))},en.acosh=er=>{er.compute(eu(er.inputs[0],"Acosh","acosh"))},en.asin=er=>{er.compute(eu(er.inputs[0],"Asin","asin"))},en.asinh=er=>{er.compute(eu(er.inputs[0],"Asinh","asinh"))},en.atan=er=>{er.compute(eu(er.inputs[0],"Atan","atan"))},en.atanh=er=>{er.compute(eu(er.inputs[0],"Atanh","atanh"))},en.clipV10=(er,en)=>{er.compute(eu(er.inputs[0],"Clip",er=>`clamp(${er}, clip_min_, clip_max_)`,`
    const clip_min_: vec4<f32> = vec4(f32(${en.min}));
    const clip_max_: vec4<f32> = vec4(f32(${en.max}));
`,en.cacheKey),{inputs:[0]})},en.clip=er=>{let ei=(er=>{let en=er.length>=2?er[1].getFloat32Array()[0]:eo.MIN_CLIP,ei=er.length>=3?er[2].getFloat32Array()[0]:eo.MAX_CLIP;return(0,ea.createAttributeWithCacheKey)({min:en,max:ei})})(er.inputs);(0,en.clipV10)(er,ei)},en.ceil=er=>{er.compute(eu(er.inputs[0],"Ceil","ceil"))},en.cos=er=>{er.compute(eu(er.inputs[0],"Cos","cos"))},en.cosh=er=>{er.compute(eu(er.inputs[0],"Cosh","cosh"))},en.parseAlphaAttributes=er=>(0,ea.createAttributeWithCacheKey)(er),en.elu=(er,en)=>{er.compute(eu(er.inputs[0],"Elu",er=>`elu_vf32(${er})`,`
  const elu_alpha_: f32 = f32(${en.alpha});

  fn elu_f32(a: f32) -> f32 {
  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);
  }

  fn elu_vf32(v: vec4<f32>) -> vec4<f32> {
  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));
  }`,en.cacheKey))},en.erf=er=>{er.compute(eu(er.inputs[0],"Erf",er=>`erf_vf32(${er})`,"\n  const r0: f32 = 0.3275911;\n  const r1: f32 = 0.254829592;\n  const r2: f32 = -0.284496736;\n  const r3: f32 = 1.421413741;\n  const r4: f32 = -1.453152027;\n  const r5: f32 = 1.061405429;\n\n  fn erf_vf32(v: vec4<f32>) -> vec4<f32> {\n    let absv = abs(v);\n    let x = 1.0 / (1.0 + r0 * absv);\n    return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));\n  }"))},en.exp=er=>{er.compute(eu(er.inputs[0],"Exp","exp"))},en.floor=er=>{er.compute(eu(er.inputs[0],"Floor","floor"))},en.leakyRelu=(er,en)=>{er.compute(eu(er.inputs[0],"LeakyRelu",er=>`select(leaky_relu_alpha_ * ${er}, ${er}, ${er} >= vec4<f32>(0.0))`,`const leaky_relu_alpha_: f32 = f32(${en.alpha});`,en.cacheKey))},en.neg=er=>{er.compute(eu(er.inputs[0],"Neg",er=>`-${er}`))},en.reciprocal=er=>{er.compute(eu(er.inputs[0],"Reciprocal",er=>`1.0/${er}`))},en.relu=er=>{er.compute(eu(er.inputs[0],"Relu",er=>`select(vec4<f32>(0.0), ${er}, ${er} > vec4<f32>(0.0))`))},en.sigmoid=er=>{er.compute(eu(er.inputs[0],"Sigmoid",er=>`(1.0 / (1.0 + exp(-${er})))`))},en.sin=er=>{er.compute(eu(er.inputs[0],"Sin","sin"))},en.sinh=er=>{er.compute(eu(er.inputs[0],"Sinh","sinh"))},en.sqrt=er=>{er.compute(eu(er.inputs[0],"Sqrt","sqrt"))},en.tan=er=>{er.compute(eu(er.inputs[0],"Tan","tan"))},en.tanh=er=>{er.compute(eu(er.inputs[0],"Tanh","tanh"))},en.thresholdedRelu=(er,en)=>(er.compute(eu(er.inputs[0],"ThresholdedRelu",er=>`select(vec4<f32>(0.0), ${er}, ${er} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_: vec4<f32> = vec4<f32>(${en.alpha});`,en.cacheKey)),0)},8305:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.ProgramManager=void 0;let eo=ei(4955),ea=ei(2075);en.ProgramManager=class{constructor(er){this.backend=er,this.repo=new Map,this.attributesBound=!1}getArtifact(er){return this.repo.get(er)}setArtifact(er,en){this.repo.set(er,en)}run(er,en,ei,eo){let ea=this.backend.device,es=this.backend.getComputePassEncoder();this.backend.profilingEnabled&&es.writeTimestamp(this.backend.profilingQuerySet,0),es.setPipeline(er.computePipeline);let eu=[];for(let er of en)eu.push({binding:eu.length,resource:{buffer:er.buffer}});for(let er of ei)eu.push({binding:eu.length,resource:{buffer:er.buffer}});let el=ea.createBindGroup({layout:er.computePipeline.getBindGroupLayout(0),entries:eu});if(es.setBindGroup(0,el),es.dispatchWorkgroups(...eo),this.backend.pendingDispatchNumber++,this.backend.profilingEnabled){es.writeTimestamp(this.backend.profilingQuerySet,1);let er=this.backend.gpuDataManager.create(16,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE),en=this.backend.gpuDataManager.create(16,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.backend.endComputePass(),this.backend.getCommandEncoder().resolveQuerySet(this.backend.profilingQuerySet,0,2,er.buffer,0),this.backend.getCommandEncoder().copyBufferToBuffer(er.buffer,0,en.buffer,0,16),this.backend.flush();let ei=this.backend.currentKernelId,eo=this.backend.kernels.get(ei)[0];en.buffer.mapAsync(GPUMapMode.READ).then(()=>{let ea=new BigUint64Array(en.buffer.getMappedRange()),es=ea[0],eu=ea[1];en.buffer.unmap(),void 0===this.backend.profilingTimeBase&&(this.backend.profilingTimeBase=es);let el=Number(es-this.backend.profilingTimeBase),ec=Number(eu-this.backend.profilingTimeBase);if(!Number.isSafeInteger(el)||!Number.isSafeInteger(ec))throw RangeError("incorrect timestamp range");this.backend.gpuDataManager.release(er.id),this.backend.gpuDataManager.release(en.id),console.log(`[profiling] kernel "${ei}|${eo}" execution time: ${ec-el} ns`)})}this.backend.pendingDispatchNumber>=16&&this.backend.flush()}dispose(){}build(er,en){let ei=this.backend.device,es=er.getShaderSource((0,ea.createShaderHelper)(en)),eu=ei.createShaderModule({code:es});return(0,eo.LOG_DEBUG)("verbose",()=>`[WebGPU] shader code: ${es}`),{programInfo:er,computePipeline:ei.createComputePipeline({compute:{module:eu,entryPoint:"main"},layout:"auto"})}}normalizeDispatchGroupSize(er){let en="number"==typeof er?er:er.x,ei="number"==typeof er?1:er.y||1,eo="number"==typeof er?1:er.z||1,ea=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(en<=ea&&ei<=ea&&eo<=ea)return[en,ei,eo];let es=en*ei*eo,eu=Math.ceil(Math.sqrt(es));if(eu>ea){if((eu=Math.ceil(Math.cbrt(es)))>ea)throw Error("Total dispatch size exceeds WebGPU maximum.");return[eu,eu,eu]}return[eu,eu,1]}}},1163:(er,en)=>{"use strict";var ei;Object.defineProperty(en,"__esModule",{value:!0}),en.GpuDataType=void 0,(ei=en.GpuDataType||(en.GpuDataType={}))[ei.default=0]="default",ei[ei.upload=1]="upload",ei[ei.profile=2]="profile"},3899:(er,en)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.iterateExtraOptions=void 0,en.iterateExtraOptions=(er,ei,eo,ea)=>{if("object"==typeof er&&null!==er){if(eo.has(er))throw Error("Circular reference in options");eo.add(er)}Object.entries(er).forEach(([er,es])=>{let eu=ei?ei+er:er;if("object"==typeof es)(0,en.iterateExtraOptions)(es,eu+".",eo,ea);else if("string"==typeof es||"number"==typeof es)ea(eu,es.toString());else{if("boolean"!=typeof es)throw Error("Can't handle extra config type: "+typeof es);ea(eu,es?"1":"0")}})}},9544:function(er,en,ei){"use strict";var eo,ea=this&&this.__createBinding||(Object.create?function(er,en,ei,eo){void 0===eo&&(eo=ei);var ea=Object.getOwnPropertyDescriptor(en,ei);ea&&!("get"in ea?!en.__esModule:ea.writable||ea.configurable)||(ea={enumerable:!0,get:function(){return en[ei]}}),Object.defineProperty(er,eo,ea)}:function(er,en,ei,eo){void 0===eo&&(eo=ei),er[eo]=en[ei]}),es=this&&this.__setModuleDefault||(Object.create?function(er,en){Object.defineProperty(er,"default",{enumerable:!0,value:en})}:function(er,en){er.default=en}),eu=this&&this.__importStar||function(er){if(er&&er.__esModule)return er;var en={};if(null!=er)for(var ei in er)"default"!==ei&&Object.prototype.hasOwnProperty.call(er,ei)&&ea(en,er,ei);return es(en,er),en};Object.defineProperty(en,"__esModule",{value:!0}),en.endProfiling=en.run=en.releaseSession=en.createSession=en.createSessionFinalize=en.createSessionAllocate=en.initOrt=en.initWasm=void 0;let el=ei(8453),ec=ei(7675),ep=eu(ei(1259)),ed=ei(263),ef=()=>!!el.env.wasm.proxy&&"undefined"!=typeof document,eh,eg,em,eb=!1,ey=!1,ev=!1,e_=[],ex=[],ew=[],eT=[],eS=[],eO=[],eA=()=>{if(eb||!ey||ev||!eh)throw Error("worker not ready")},eE=er=>{switch(er.data.type){case"init-wasm":eb=!1,er.data.err?(ev=!0,eg[1](er.data.err)):(ey=!0,eg[0]());break;case"init-ort":er.data.err?em[1](er.data.err):em[0]();break;case"create_allocate":er.data.err?e_.shift()[1](er.data.err):e_.shift()[0](er.data.out);break;case"create_finalize":er.data.err?ex.shift()[1](er.data.err):ex.shift()[0](er.data.out);break;case"create":er.data.err?ew.shift()[1](er.data.err):ew.shift()[0](er.data.out);break;case"release":er.data.err?eT.shift()[1](er.data.err):eT.shift()[0]();break;case"run":er.data.err?eS.shift()[1](er.data.err):eS.shift()[0](er.data.out);break;case"end-profiling":er.data.err?eO.shift()[1](er.data.err):eO.shift()[0]()}},eI="undefined"!=typeof document?null===(eo=null==document?void 0:document.currentScript)||void 0===eo?void 0:eo.src:void 0;en.initWasm=async()=>{if(ef()){if(ey)return;if(eb)throw Error("multiple calls to 'initWasm()' detected.");if(ev)throw Error("previous call to 'initWasm()' failed.");return eb=!0,void 0===el.env.wasm.wasmPaths&&eI&&0!==eI.indexOf("blob:")&&(el.env.wasm.wasmPaths=eI.substr(0,+eI.lastIndexOf("/")+1)),new Promise((er,en)=>{null==eh||eh.terminate(),(eh=ei(8050).Z()).onmessage=eE,eg=[er,en];let eo={type:"init-wasm",in:el.env.wasm};eh.postMessage(eo)})}return(0,ed.initializeWebAssembly)(el.env.wasm)},en.initOrt=async(er,en)=>{if(ef())return eA(),new Promise((ei,eo)=>{em=[ei,eo];let ea={type:"init-ort",in:{numThreads:er,loggingLevel:en}};eh.postMessage(ea)});ep.initOrt(er,en),await (0,ec.init)((0,ed.getInstance)())},en.createSessionAllocate=async er=>ef()?(eA(),new Promise((en,ei)=>{e_.push([en,ei]);let eo={type:"create_allocate",in:{model:er}};eh.postMessage(eo,[er.buffer])})):ep.createSessionAllocate(er),en.createSessionFinalize=async(er,en)=>ef()?(eA(),new Promise((ei,eo)=>{ex.push([ei,eo]);let ea={type:"create_finalize",in:{modeldata:er,options:en}};eh.postMessage(ea)})):ep.createSessionFinalize(er,en),en.createSession=async(er,en)=>ef()?(eA(),new Promise((ei,eo)=>{ew.push([ei,eo]);let ea={type:"create",in:{model:er,options:en}};eh.postMessage(ea,[er.buffer])})):ep.createSession(er,en),en.releaseSession=async er=>{if(ef())return eA(),new Promise((en,ei)=>{eT.push([en,ei]);let eo={type:"release",in:er};eh.postMessage(eo)});ep.releaseSession(er)},en.run=async(er,en,ei,eo,ea)=>ef()?(eA(),new Promise((es,eu)=>{eS.push([es,eu]);let el={type:"run",in:{sessionId:er,inputIndices:en,inputs:ei,outputIndices:eo,options:ea}};eh.postMessage(el,ep.extractTransferableBuffers(ei))})):ep.run(er,en,ei,eo,ea),en.endProfiling=async er=>{if(ef())return eA(),new Promise((en,ei)=>{eO.push([en,ei]);let eo={type:"end-profiling",in:er};eh.postMessage(eo)});ep.endProfiling(er)}},7918:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.setRunOptions=void 0;let eo=ei(3899),ea=ei(9444),es=ei(263);en.setRunOptions=er=>{let en=(0,es.getInstance)(),ei=0,eu=[],el=er||{};try{if(void 0===(null==er?void 0:er.logSeverityLevel))el.logSeverityLevel=2;else if("number"!=typeof er.logSeverityLevel||!Number.isInteger(er.logSeverityLevel)||er.logSeverityLevel<0||er.logSeverityLevel>4)throw Error(`log serverity level is not valid: ${er.logSeverityLevel}`);if(void 0===(null==er?void 0:er.logVerbosityLevel))el.logVerbosityLevel=0;else if("number"!=typeof er.logVerbosityLevel||!Number.isInteger(er.logVerbosityLevel))throw Error(`log verbosity level is not valid: ${er.logVerbosityLevel}`);void 0===(null==er?void 0:er.terminate)&&(el.terminate=!1);let es=0;if(void 0!==(null==er?void 0:er.tag)&&(es=(0,ea.allocWasmString)(er.tag,eu)),ei=en._OrtCreateRunOptions(el.logSeverityLevel,el.logVerbosityLevel,!!el.terminate,es),0===ei)throw Error("Can't create run options");return void 0!==(null==er?void 0:er.extra)&&(0,eo.iterateExtraOptions)(er.extra,"",new WeakSet,(er,eo)=>{let es=(0,ea.allocWasmString)(er,eu),el=(0,ea.allocWasmString)(eo,eu);if(0!==en._OrtAddRunConfigEntry(ei,es,el))throw Error(`Can't set a run config entry: ${er} - ${eo}`)}),[ei,eu]}catch(er){throw 0!==ei&&en._OrtReleaseRunOptions(ei),eu.forEach(en._free),er}}},6640:(er,en,ei)=>{"use strict";let eo;Object.defineProperty(en,"__esModule",{value:!0}),en.OnnxruntimeWebAssemblySessionHandler=void 0;let ea=ei(2806),es=ei(8453),eu=ei(2850),el=ei(9544),ec=ei(7917);en.OnnxruntimeWebAssemblySessionHandler=class{async createSessionAllocate(er){let en=await fetch(er),ei=await en.arrayBuffer();return(0,el.createSessionAllocate)(new Uint8Array(ei))}async loadModel(er,en){if(eo||(await (0,el.initOrt)(es.env.wasm.numThreads,(0,ec.logLevelStringToEnum)(es.env.logLevel)),eo=!0),"string"==typeof er){if("undefined"==typeof fetch){let ei=await (0,eu.promisify)(ea.readFile)(er);[this.sessionId,this.inputNames,this.outputNames]=await (0,el.createSession)(ei,en)}else{let ei=await this.createSessionAllocate(er);[this.sessionId,this.inputNames,this.outputNames]=await (0,el.createSessionFinalize)(ei,en)}}else[this.sessionId,this.inputNames,this.outputNames]=await (0,el.createSession)(er,en)}async dispose(){return(0,el.releaseSession)(this.sessionId)}async run(er,en,ei){let eo=[],ea=[];Object.entries(er).forEach(er=>{let en=er[0],ei=er[1],es=this.inputNames.indexOf(en);if(-1===es)throw Error(`invalid input '${en}'`);eo.push(ei),ea.push(es)});let eu=[];Object.entries(en).forEach(er=>{let en=er[0],ei=this.outputNames.indexOf(en);if(-1===ei)throw Error(`invalid output '${en}'`);eu.push(ei)});let ec=await (0,el.run)(this.sessionId,ea,eo.map(er=>[er.type,er.dims,er.data]),eu,ei),ep={};for(let er=0;er<ec.length;er++)ep[this.outputNames[eu[er]]]=new es.Tensor(ec[er][0],ec[er][2],ec[er][1]);return ep}startProfiling(){}endProfiling(){(0,el.endProfiling)(this.sessionId)}}},7622:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.setSessionOptions=void 0;let eo=ei(3899),ea=ei(9444),es=ei(263);en.setSessionOptions=er=>{var en,ei,eu,el;let ec=(0,es.getInstance)(),ep=0,ed=[],ef=er||{};(er=>{er.extra||(er.extra={}),er.extra.session||(er.extra.session={});let en=er.extra.session;en.use_ort_model_bytes_directly||(en.use_ort_model_bytes_directly="1"),er.executionProviders&&er.executionProviders.some(er=>"webgpu"===("string"==typeof er?er:er.name))&&(er.enableMemPattern=!1)})(ef);try{let er=(er=>{switch(er){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw Error(`unsupported graph optimization level: ${er}`)}})(null!==(en=ef.graphOptimizationLevel)&&void 0!==en?en:"all"),eh=(er=>{switch(er){case"sequential":return 0;case"parallel":return 1;default:throw Error(`unsupported execution mode: ${er}`)}})(null!==(ei=ef.executionMode)&&void 0!==ei?ei:"sequential"),eg="string"==typeof ef.logId?(0,ea.allocWasmString)(ef.logId,ed):0,em=null!==(eu=ef.logSeverityLevel)&&void 0!==eu?eu:2;if(!Number.isInteger(em)||em<0||em>4)throw Error(`log serverity level is not valid: ${em}`);let eb=null!==(el=ef.logVerbosityLevel)&&void 0!==el?el:0;if(!Number.isInteger(eb)||eb<0||eb>4)throw Error(`log verbosity level is not valid: ${eb}`);let ey="string"==typeof ef.optimizedModelFilePath?(0,ea.allocWasmString)(ef.optimizedModelFilePath,ed):0;if(ep=ec._OrtCreateSessionOptions(er,!!ef.enableCpuMemArena,!!ef.enableMemPattern,eh,!!ef.enableProfiling,0,eg,em,eb,ey),0===ep)throw Error("Can't create session options");return ef.executionProviders&&((er,en,ei)=>{for(let eo of en){let en="string"==typeof eo?eo:eo.name;switch(en){case"xnnpack":en="XNNPACK";break;case"webgpu":en="JS";break;case"wasm":case"cpu":continue;default:throw Error(`not supported EP: ${en}`)}let eu=(0,ea.allocWasmString)(en,ei);if(0!==(0,es.getInstance)()._OrtAppendExecutionProvider(er,eu))throw Error(`Can't append execution provider: ${en}`)}})(ep,ef.executionProviders,ed),void 0!==ef.extra&&(0,eo.iterateExtraOptions)(ef.extra,"",new WeakSet,(er,en)=>{let ei=(0,ea.allocWasmString)(er,ed),eo=(0,ea.allocWasmString)(en,ed);if(0!==ec._OrtAddSessionConfigEntry(ep,ei,eo))throw Error(`Can't set a session config entry: ${er} - ${en}`)}),[ep,ed]}catch(er){throw 0!==ep&&ec._OrtReleaseSessionOptions(ep),ed.forEach(ec._free),er}}},9444:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.allocWasmString=void 0;let eo=ei(263);en.allocWasmString=(er,en)=>{let ei=(0,eo.getInstance)(),ea=ei.lengthBytesUTF8(er)+1,es=ei._malloc(ea);return ei.stringToUTF8(er,es,ea),en.push(es),es}},7917:(er,en)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.logLevelStringToEnum=en.tensorTypeToTypedArrayConstructor=en.getTensorElementSize=en.tensorDataTypeEnumToString=en.tensorDataTypeStringToEnum=void 0,en.tensorDataTypeStringToEnum=er=>{switch(er){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw Error(`unsupported data type: ${er}`)}},en.tensorDataTypeEnumToString=er=>{switch(er){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw Error(`unsupported data type: ${er}`)}},en.getTensorElementSize=er=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][er],en.tensorTypeToTypedArrayConstructor=er=>{switch(er){case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw Error(`unsupported type: ${er}`)}},en.logLevelStringToEnum=er=>{switch(er){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw Error(`unsupported logging level: ${er}`)}}},1259:(er,en,ei)=>{"use strict";Object.defineProperty(en,"__esModule",{value:!0}),en.extractTransferableBuffers=en.endProfiling=en.run=en.releaseSession=en.createSession=en.createSessionFinalize=en.createSessionAllocate=en.initOrt=void 0;let eo=ei(7918),ea=ei(7622),es=ei(9444),eu=ei(7917),el=ei(263);en.initOrt=(er,en)=>{let ei=(0,el.getInstance)()._OrtInit(er,en);if(0!==ei)throw Error(`Can't initialize onnxruntime. error code = ${ei}`)};let ec=new Map;en.createSessionAllocate=er=>{let en=(0,el.getInstance)(),ei=en._malloc(er.byteLength);return en.HEAPU8.set(er,ei),[ei,er.byteLength]},en.createSessionFinalize=(er,en)=>{let ei=(0,el.getInstance)(),eo=0,es=0,eu=[];try{if([es,eu]=(0,ea.setSessionOptions)(en),eo=ei._OrtCreateSession(er[0],er[1],es),0===eo)throw Error("Can't create a session")}finally{ei._free(er[0]),0!==es&&ei._OrtReleaseSessionOptions(es),eu.forEach(ei._free)}let ep=ei._OrtGetInputCount(eo),ed=ei._OrtGetOutputCount(eo),ef=[],eh=[],eg=[],em=[];for(let er=0;er<ep;er++){let en=ei._OrtGetInputName(eo,er);if(0===en)throw Error("Can't get an input name");eh.push(en),ef.push(ei.UTF8ToString(en))}for(let er=0;er<ed;er++){let en=ei._OrtGetOutputName(eo,er);if(0===en)throw Error("Can't get an output name");em.push(en),eg.push(ei.UTF8ToString(en))}return ec.set(eo,[eo,eh,em]),[eo,ef,eg]},en.createSession=(er,ei)=>{let eo=(0,en.createSessionAllocate)(er);return(0,en.createSessionFinalize)(eo,ei)},en.releaseSession=er=>{let en=(0,el.getInstance)(),ei=ec.get(er);if(!ei)throw Error("invalid session id");let eo=ei[0],ea=ei[1],es=ei[2];ea.forEach(en._OrtFree),es.forEach(en._OrtFree),en._OrtReleaseSession(eo),ec.delete(er)},en.run=async(er,en,ei,ea,ep)=>{let ed=(0,el.getInstance)(),ef=ec.get(er);if(!ef)throw Error("invalid session id");let eh=ef[0],eg=ef[1],em=ef[2],eb=en.length,ey=ea.length,ev=0,e_=[],ex=[],ew=[];try{[ev,e_]=(0,eo.setRunOptions)(ep);for(let er=0;er<eb;er++){let en,eo;let ea=ei[er][0],el=ei[er][1],ec=ei[er][2];if(Array.isArray(ec)){eo=4*ec.length,en=ed._malloc(eo),ew.push(en);let er=en/4;for(let en=0;en<ec.length;en++){if("string"!=typeof ec[en])throw TypeError(`tensor data at index ${en} is not a string`);ed.HEAPU32[er++]=(0,es.allocWasmString)(ec[en],ew)}}else eo=ec.byteLength,en=ed._malloc(eo),ew.push(en),ed.HEAPU8.set(new Uint8Array(ec.buffer,ec.byteOffset,eo),en);let ep=ed.stackSave(),ef=ed.stackAlloc(4*el.length);try{let er=ef/4;el.forEach(en=>ed.HEAP32[er++]=en);let ei=ed._OrtCreateTensor((0,eu.tensorDataTypeStringToEnum)(ea),en,eo,ef,el.length);if(0===ei)throw Error("Can't create a tensor");ex.push(ei)}finally{ed.stackRestore(ep)}}let er=ed.stackSave(),el=ed.stackAlloc(4*eb),ec=ed.stackAlloc(4*eb),ef=ed.stackAlloc(4*ey),eT=ed.stackAlloc(4*ey);try{let er=el/4,ei=ec/4,eo=ef/4,es=eT/4;for(let eo=0;eo<eb;eo++)ed.HEAPU32[er++]=ex[eo],ed.HEAPU32[ei++]=eg[en[eo]];for(let er=0;er<ey;er++)ed.HEAPU32[eo++]=0,ed.HEAPU32[es++]=em[ea[er]];let ep=ed._OrtRun(eh,ec,el,eb,eT,ey,ef,ev),e_=ed.jsepRunPromise;e_&&void 0!==e_.then&&(ep=await e_);let ew=[];if(0===ep)for(let er=0;er<ey;er++){let en=ed.HEAPU32[ef/4+er],ei=ed.stackSave(),eo=ed.stackAlloc(16),ea,es=0;try{if(ep=ed._OrtGetTensorData(en,eo,eo+4,eo+8,eo+12),0!==ep)throw Error(`Can't access output tensor data. error code = ${ep}`);let er=eo/4,ei=ed.HEAPU32[er++];es=ed.HEAPU32[er++];let el=ed.HEAPU32[er++],ec=ed.HEAPU32[er++],ef=[];for(let er=0;er<ec;er++)ef.push(ed.HEAPU32[el/4+er]);ed._OrtFree(el);let eh=0===ef.length?1:ef.reduce((er,en)=>er*en);if(ea=(0,eu.tensorDataTypeEnumToString)(ei),"string"===ea){let er=[],en=es/4;for(let ei=0;ei<eh;ei++){let eo=ed.HEAPU32[en++],ea=ei===eh-1?void 0:ed.HEAPU32[en]-eo;er.push(ed.UTF8ToString(eo,ea))}ew.push([ea,ef,er])}else{let er=new((0,eu.tensorTypeToTypedArrayConstructor)(ea))(eh);new Uint8Array(er.buffer,er.byteOffset,er.byteLength).set(ed.HEAPU8.subarray(es,es+er.byteLength)),ew.push([ea,ef,er])}}finally{ed.stackRestore(ei),"string"===ea&&es&&ed._free(es),ed._OrtReleaseTensor(en)}}if(0===ep)return ew;throw Error(`failed to call OrtRun(). error code = ${ep}.`)}finally{ed.stackRestore(er)}}finally{ex.forEach(ed._OrtReleaseTensor),ew.forEach(ed._free),ed._OrtReleaseRunOptions(ev),e_.forEach(ed._free)}},en.endProfiling=er=>{let en=(0,el.getInstance)(),ei=ec.get(er);if(!ei)throw Error("invalid session id");let eo=ei[0],ea=en._OrtEndProfiling(eo);if(0===ea)throw Error("Can't get an profile file name");en._OrtFree(ea)},en.extractTransferableBuffers=er=>{let en=[];for(let ei of er){let er=ei[2];!Array.isArray(er)&&er.buffer&&en.push(er.buffer)}return en}},263:function(er,en,ei){"use strict";var eo=this&&this.__createBinding||(Object.create?function(er,en,ei,eo){void 0===eo&&(eo=ei);var ea=Object.getOwnPropertyDescriptor(en,ei);ea&&!("get"in ea?!en.__esModule:ea.writable||ea.configurable)||(ea={enumerable:!0,get:function(){return en[ei]}}),Object.defineProperty(er,eo,ea)}:function(er,en,ei,eo){void 0===eo&&(eo=ei),er[eo]=en[ei]}),ea=this&&this.__setModuleDefault||(Object.create?function(er,en){Object.defineProperty(er,"default",{enumerable:!0,value:en})}:function(er,en){er.default=en}),es=this&&this.__importStar||function(er){if(er&&er.__esModule)return er;var en={};if(null!=er)for(var ei in er)"default"!==ei&&Object.prototype.hasOwnProperty.call(er,ei)&&eo(en,er,ei);return ea(en,er),en};Object.defineProperty(en,"__esModule",{value:!0}),en.dispose=en.getInstance=en.initializeWebAssembly=void 0;let eu=es(ei(6449)),el=ei(932),ec=ei(3474),ep,ed=!1,ef=!1,eh=!1;en.initializeWebAssembly=async er=>{var en;if(ed)return Promise.resolve();if(ef)throw Error("multiple calls to 'initializeWebAssembly()' detected.");if(eh)throw Error("previous call to 'initializeWebAssembly()' failed.");ef=!0;let eo=er.initTimeout,ea=er.numThreads,es=er.simd,eg=ea>1&&(()=>{try{return"undefined"!=typeof SharedArrayBuffer&&("undefined"!=typeof MessageChannel&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch(er){return!1}})(),em=es&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch(er){return!1}})(),eb=er.wasmPaths,ey="string"==typeof eb?eb:void 0,ev=(en=em,eg?en?"ort-wasm-simd-threaded.wasm":"ort-wasm-threaded.wasm":en?"ort-wasm-simd.wasm":"ort-wasm.wasm"),e_="object"==typeof eb?eb[ev]:void 0,ex=!1,ew=[];if(eo>0&&ew.push(new Promise(er=>{setTimeout(()=>{ex=!0,er()},eo)})),ew.push(new Promise((er,en)=>{let eo=eg?ec:el,ea={locateFile:(er,en)=>eg&&er.endsWith(".worker.js")&&"undefined"!=typeof Blob?URL.createObjectURL(new Blob([ei(4154)],{type:"text/javascript"})):er.endsWith(".wasm")?e_||(null!=ey?ey:en)+ev:en+er};if(eg){if("undefined"==typeof Blob)ea.mainScriptUrlOrBlob=eu.join("/","ort-wasm-threaded.js");else{let er=`var ortWasmThreaded=(function(){var _scriptDir;return ${eo.toString()}})();`;ea.mainScriptUrlOrBlob=new Blob([er],{type:"text/javascript"})}}eo(ea).then(en=>{ef=!1,ed=!0,ep=en,er()},er=>{ef=!1,eh=!0,en(er)})})),await Promise.race(ew),ex)throw Error(`WebAssembly backend initializing failed due to timeout: ${eo}ms`)},en.getInstance=()=>{if(ed&&ep)return ep;throw Error("WebAssembly is not initialized yet.")},en.dispose=()=>{var er;!ed||ef||eh||(ef=!0,null===(er=ep.PThread)||void 0===er||er.terminateAllThreads(),ep=void 0,ef=!1,ed=!1,eh=!0)}},8050:(er,en,ei)=>{"use strict";ei.d(en,{Z:()=>es});var eo=ei(6614),ea=ei.n(eo);function es(){return ea()('/*!\n* ONNX Runtime Web v1.15.0\n* Copyright (c) Microsoft Corporation. All rights reserved.\n* Licensed under the MIT License.\n*/\n(()=>{var e={899:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.iterateExtraOptions=void 0,t.iterateExtraOptions=(e,n,r,a)=>{if("object"==typeof e&&null!==e){if(r.has(e))throw new Error("Circular reference in options");r.add(e)}Object.entries(e).forEach((([e,o])=>{const i=n?n+e:e;if("object"==typeof o)(0,t.iterateExtraOptions)(o,i+".",r,a);else if("string"==typeof o||"number"==typeof o)a(i,o.toString());else{if("boolean"!=typeof o)throw new Error("Can\'t handle extra config type: "+typeof o);a(i,o?"1":"0")}}))}},918:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.setRunOptions=void 0;const r=n(899),a=n(444),o=n(263);t.setRunOptions=e=>{const t=(0,o.getInstance)();let n=0;const i=[],s=e||{};try{if(void 0===(null==e?void 0:e.logSeverityLevel))s.logSeverityLevel=2;else if("number"!=typeof e.logSeverityLevel||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(void 0===(null==e?void 0:e.logVerbosityLevel))s.logVerbosityLevel=0;else if("number"!=typeof e.logVerbosityLevel||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);void 0===(null==e?void 0:e.terminate)&&(s.terminate=!1);let o=0;if(void 0!==(null==e?void 0:e.tag)&&(o=(0,a.allocWasmString)(e.tag,i)),n=t._OrtCreateRunOptions(s.logSeverityLevel,s.logVerbosityLevel,!!s.terminate,o),0===n)throw new Error("Can\'t create run options");return void 0!==(null==e?void 0:e.extra)&&(0,r.iterateExtraOptions)(e.extra,"",new WeakSet,((e,r)=>{const o=(0,a.allocWasmString)(e,i),s=(0,a.allocWasmString)(r,i);if(0!==t._OrtAddRunConfigEntry(n,o,s))throw new Error(`Can\'t set a run config entry: ${e} - ${r}`)})),[n,i]}catch(e){throw 0!==n&&t._OrtReleaseRunOptions(n),i.forEach(t._free),e}}},622:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.setSessionOptions=void 0;const r=n(899),a=n(444),o=n(263);t.setSessionOptions=e=>{var t,n,i,s;const u=(0,o.getInstance)();let c=0;const l=[],f=e||{};(e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});const t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some((e=>"webgpu"===("string"==typeof e?e:e.name)))&&(e.enableMemPattern=!1)})(f);try{const e=(e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}})(null!==(t=f.graphOptimizationLevel)&&void 0!==t?t:"all"),p=(e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}})(null!==(n=f.executionMode)&&void 0!==n?n:"sequential"),d="string"==typeof f.logId?(0,a.allocWasmString)(f.logId,l):0,m=null!==(i=f.logSeverityLevel)&&void 0!==i?i:2;if(!Number.isInteger(m)||m<0||m>4)throw new Error(`log serverity level is not valid: ${m}`);const g=null!==(s=f.logVerbosityLevel)&&void 0!==s?s:0;if(!Number.isInteger(g)||g<0||g>4)throw new Error(`log verbosity level is not valid: ${g}`);const h="string"==typeof f.optimizedModelFilePath?(0,a.allocWasmString)(f.optimizedModelFilePath,l):0;if(c=u._OrtCreateSessionOptions(e,!!f.enableCpuMemArena,!!f.enableMemPattern,p,!!f.enableProfiling,0,d,m,g,h),0===c)throw new Error("Can\'t create session options");return f.executionProviders&&((e,t,n)=>{for(const r of t){let t="string"==typeof r?r:r.name;switch(t){case"xnnpack":t="XNNPACK";break;case"webgpu":t="JS";break;case"wasm":case"cpu":continue;default:throw new Error(`not supported EP: ${t}`)}const i=(0,a.allocWasmString)(t,n);if(0!==(0,o.getInstance)()._OrtAppendExecutionProvider(e,i))throw new Error(`Can\'t append execution provider: ${t}`)}})(c,f.executionProviders,l),void 0!==f.extra&&(0,r.iterateExtraOptions)(f.extra,"",new WeakSet,((e,t)=>{const n=(0,a.allocWasmString)(e,l),r=(0,a.allocWasmString)(t,l);if(0!==u._OrtAddSessionConfigEntry(c,n,r))throw new Error(`Can\'t set a session config entry: ${e} - ${t}`)})),[c,l]}catch(e){throw 0!==c&&u._OrtReleaseSessionOptions(c),l.forEach(u._free),e}}},444:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.allocWasmString=void 0;const r=n(263);t.allocWasmString=(e,t)=>{const n=(0,r.getInstance)(),a=n.lengthBytesUTF8(e)+1,o=n._malloc(a);return n.stringToUTF8(e,o,a),t.push(o),o}},917:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.logLevelStringToEnum=t.tensorTypeToTypedArrayConstructor=t.getTensorElementSize=t.tensorDataTypeEnumToString=t.tensorDataTypeStringToEnum=void 0,t.tensorDataTypeStringToEnum=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${e}`)}},t.tensorDataTypeEnumToString=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${e}`)}},t.getTensorElementSize=e=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][e],t.tensorTypeToTypedArrayConstructor=e=>{switch(e){case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},t.logLevelStringToEnum=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}}},259:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.extractTransferableBuffers=t.endProfiling=t.run=t.releaseSession=t.createSession=t.createSessionFinalize=t.createSessionAllocate=t.initOrt=void 0;const r=n(918),a=n(622),o=n(444),i=n(917),s=n(263);t.initOrt=(e,t)=>{const n=(0,s.getInstance)()._OrtInit(e,t);if(0!==n)throw new Error(`Can\'t initialize onnxruntime. error code = ${n}`)};const u=new Map;t.createSessionAllocate=e=>{const t=(0,s.getInstance)(),n=t._malloc(e.byteLength);return t.HEAPU8.set(e,n),[n,e.byteLength]},t.createSessionFinalize=(e,t)=>{const n=(0,s.getInstance)();let r=0,o=0,i=[];try{if([o,i]=(0,a.setSessionOptions)(t),r=n._OrtCreateSession(e[0],e[1],o),0===r)throw new Error("Can\'t create a session")}finally{n._free(e[0]),0!==o&&n._OrtReleaseSessionOptions(o),i.forEach(n._free)}const c=n._OrtGetInputCount(r),l=n._OrtGetOutputCount(r),f=[],p=[],d=[],m=[];for(let e=0;e<c;e++){const t=n._OrtGetInputName(r,e);if(0===t)throw new Error("Can\'t get an input name");p.push(t),f.push(n.UTF8ToString(t))}for(let e=0;e<l;e++){const t=n._OrtGetOutputName(r,e);if(0===t)throw new Error("Can\'t get an output name");m.push(t),d.push(n.UTF8ToString(t))}return u.set(r,[r,p,m]),[r,f,d]},t.createSession=(e,n)=>{const r=(0,t.createSessionAllocate)(e);return(0,t.createSessionFinalize)(r,n)},t.releaseSession=e=>{const t=(0,s.getInstance)(),n=u.get(e);if(!n)throw new Error("invalid session id");const r=n[0],a=n[1],o=n[2];a.forEach(t._OrtFree),o.forEach(t._OrtFree),t._OrtReleaseSession(r),u.delete(e)},t.run=async(e,t,n,a,c)=>{const l=(0,s.getInstance)(),f=u.get(e);if(!f)throw new Error("invalid session id");const p=f[0],d=f[1],m=f[2],g=t.length,h=a.length;let y=0,v=[];const b=[],w=[];try{[y,v]=(0,r.setRunOptions)(c);for(let e=0;e<g;e++){const t=n[e][0],r=n[e][1],a=n[e][2];let s,u;if(Array.isArray(a)){u=4*a.length,s=l._malloc(u),w.push(s);let e=s/4;for(let t=0;t<a.length;t++){if("string"!=typeof a[t])throw new TypeError(`tensor data at index ${t} is not a string`);l.HEAPU32[e++]=(0,o.allocWasmString)(a[t],w)}}else u=a.byteLength,s=l._malloc(u),w.push(s),l.HEAPU8.set(new Uint8Array(a.buffer,a.byteOffset,u),s);const c=l.stackSave(),f=l.stackAlloc(4*r.length);try{let e=f/4;r.forEach((t=>l.HEAP32[e++]=t));const n=l._OrtCreateTensor((0,i.tensorDataTypeStringToEnum)(t),s,u,f,r.length);if(0===n)throw new Error("Can\'t create a tensor");b.push(n)}finally{l.stackRestore(c)}}const e=l.stackSave(),s=l.stackAlloc(4*g),u=l.stackAlloc(4*g),f=l.stackAlloc(4*h),_=l.stackAlloc(4*h);try{let e=s/4,n=u/4,r=f/4,o=_/4;for(let r=0;r<g;r++)l.HEAPU32[e++]=b[r],l.HEAPU32[n++]=d[t[r]];for(let e=0;e<h;e++)l.HEAPU32[r++]=0,l.HEAPU32[o++]=m[a[e]];let c=l._OrtRun(p,u,s,g,_,h,f,y);const v=l.jsepRunPromise;v&&void 0!==v.then&&(c=await v);const w=[];if(0===c)for(let e=0;e<h;e++){const t=l.HEAPU32[f/4+e],n=l.stackSave(),r=l.stackAlloc(16);let a,o=0;try{if(c=l._OrtGetTensorData(t,r,r+4,r+8,r+12),0!==c)throw new Error(`Can\'t access output tensor data. error code = ${c}`);let e=r/4;const n=l.HEAPU32[e++];o=l.HEAPU32[e++];const s=l.HEAPU32[e++],u=l.HEAPU32[e++],f=[];for(let e=0;e<u;e++)f.push(l.HEAPU32[s/4+e]);l._OrtFree(s);const p=0===f.length?1:f.reduce(((e,t)=>e*t));if(a=(0,i.tensorDataTypeEnumToString)(n),"string"===a){const e=[];let t=o/4;for(let n=0;n<p;n++){const r=l.HEAPU32[t++],a=n===p-1?void 0:l.HEAPU32[t]-r;e.push(l.UTF8ToString(r,a))}w.push([a,f,e])}else{const e=new((0,i.tensorTypeToTypedArrayConstructor)(a))(p);new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(l.HEAPU8.subarray(o,o+e.byteLength)),w.push([a,f,e])}}finally{l.stackRestore(n),"string"===a&&o&&l._free(o),l._OrtReleaseTensor(t)}}if(0===c)return w;throw new Error(`failed to call OrtRun(). error code = ${c}.`)}finally{l.stackRestore(e)}}finally{b.forEach(l._OrtReleaseTensor),w.forEach(l._free),l._OrtReleaseRunOptions(y),v.forEach(l._free)}},t.endProfiling=e=>{const t=(0,s.getInstance)(),n=u.get(e);if(!n)throw new Error("invalid session id");const r=n[0],a=t._OrtEndProfiling(r);if(0===a)throw new Error("Can\'t get an profile file name");t._OrtFree(a)},t.extractTransferableBuffers=e=>{const t=[];for(const n of e){const e=n[2];!Array.isArray(e)&&e.buffer&&t.push(e.buffer)}return t}},263:function(e,t,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(e,t,n,r){void 0===r&&(r=n);var a=Object.getOwnPropertyDescriptor(t,n);a&&!("get"in a?!t.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return t[n]}}),Object.defineProperty(e,r,a)}:function(e,t,n,r){void 0===r&&(r=n),e[r]=t[n]}),a=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),o=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)"default"!==n&&Object.prototype.hasOwnProperty.call(e,n)&&r(t,e,n);return a(t,e),t};Object.defineProperty(t,"__esModule",{value:!0}),t.dispose=t.getInstance=t.initializeWebAssembly=void 0;const i=o(n(449)),s=n(932),u=n(474);let c,l=!1,f=!1,p=!1;t.initializeWebAssembly=async e=>{if(l)return Promise.resolve();if(f)throw new Error("multiple calls to \'initializeWebAssembly()\' detected.");if(p)throw new Error("previous call to \'initializeWebAssembly()\' failed.");f=!0;const t=e.initTimeout,r=e.numThreads,a=e.simd,o=r>1&&(()=>{try{return"undefined"!=typeof SharedArrayBuffer&&("undefined"!=typeof MessageChannel&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch(e){return!1}})(),d=a&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch(e){return!1}})(),m=e.wasmPaths,g="string"==typeof m?m:void 0,h=((e,t)=>t?e?"ort-wasm-simd-threaded.wasm":"ort-wasm-threaded.wasm":e?"ort-wasm-simd.wasm":"ort-wasm.wasm")(d,o),y="object"==typeof m?m[h]:void 0;let v=!1;const b=[];if(t>0&&b.push(new Promise((e=>{setTimeout((()=>{v=!0,e()}),t)}))),b.push(new Promise(((e,t)=>{const r=o?u:s,a={locateFile:(e,t)=>o&&e.endsWith(".worker.js")&&"undefined"!=typeof Blob?URL.createObjectURL(new Blob([n(154)],{type:"text/javascript"})):e.endsWith(".wasm")?y||(null!=g?g:t)+h:t+e};if(o)if("undefined"==typeof Blob)a.mainScriptUrlOrBlob=i.join("/","ort-wasm-threaded.js");else{const e=`var ortWasmThreaded=(function(){var _scriptDir;return ${r.toString()}})();`;a.mainScriptUrlOrBlob=new Blob([e],{type:"text/javascript"})}r(a).then((t=>{f=!1,l=!0,c=t,e()}),(e=>{f=!1,p=!0,t(e)}))}))),await Promise.race(b),v)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},t.getInstance=()=>{if(l&&c)return c;throw new Error("WebAssembly is not initialized yet.")},t.dispose=()=>{var e;!l||f||p||(f=!0,null===(e=c.PThread)||void 0===e||e.terminateAllThreads(),c=void 0,f=!1,l=!1,p=!0)}},474:(e,t,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(e){function t(){return P.buffer!=D&&G(P.buffer),F}function r(){return P.buffer!=D&&G(P.buffer),U}function a(){return P.buffer!=D&&G(P.buffer),I}function o(){return P.buffer!=D&&G(P.buffer),W}function i(){return P.buffer!=D&&G(P.buffer),j}var s,u,c;e=e||{},s||(s=void 0!==e?e:{}),s.ready=new Promise((function(e,t){u=e,c=t}));var l,f,p,d,m,g,h=Object.assign({},s),y="./this.program",v=(e,t)=>{throw t},b="object"==typeof window,w="function"==typeof importScripts,_="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,O=s.ENVIRONMENT_IS_PTHREAD||!1,S="";function T(e){return s.locateFile?s.locateFile(e,S):S+e}if(_){let t;S=w?n(908).dirname(S)+"/":"//",g=()=>{m||(d=n(384),m=n(908))},l=function(e,t){return g(),e=m.normalize(e),d.readFileSync(e,t?void 0:"utf8")},p=e=>((e=l(e,!0)).buffer||(e=new Uint8Array(e)),e),f=(e,t,n)=>{g(),e=m.normalize(e),d.readFile(e,(function(e,r){e?n(e):t(r.buffer)}))},1<process.argv.length&&(y=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(e){if(!(e instanceof ie))throw e})),process.on("unhandledRejection",(function(e){throw e})),v=(e,t)=>{if(C)throw process.exitCode=e,t;t instanceof ie||x("exiting due to exception: "+t),process.exit(e)},s.inspect=function(){return"[Emscripten Module object]"};try{t=n(925)}catch(e){throw console.error(\'The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?\'),e}n.g.Worker=t.Worker}else(b||w)&&(w?S=self.location.href:"undefined"!=typeof document&&document.currentScript&&(S=document.currentScript.src),_scriptDir&&(S=_scriptDir),S=0!==S.indexOf("blob:")?S.substr(0,S.replace(/[?#].*/,"").lastIndexOf("/")+1):"",_||(l=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},w&&(p=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),f=(e,t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?t(r.response):n()},r.onerror=n,r.send(null)}));_&&"undefined"==typeof performance&&(n.g.performance=n(953).performance);var A=console.log.bind(console),E=console.warn.bind(console);_&&(g(),A=e=>d.writeSync(1,e+"\\n"),E=e=>d.writeSync(2,e+"\\n"));var M,R=s.print||A,x=s.printErr||E;Object.assign(s,h),h=null,s.thisProgram&&(y=s.thisProgram),s.quit&&(v=s.quit),s.wasmBinary&&(M=s.wasmBinary);var C=s.noExitRuntime||!0;"object"!=typeof WebAssembly&&ne("no native wasm support detected");var P,k,D,F,U,I,W,j,H=!1,L="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function Y(e,t,n){var r=(t>>>=0)+n;for(n=t;e[n]&&!(n>=r);)++n;if(16<n-t&&e.buffer&&L)return L.decode(e.buffer instanceof SharedArrayBuffer?e.slice(t,n):e.subarray(t,n));for(r="";t<n;){var a=e[t++];if(128&a){var o=63&e[t++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|o);else{var i=63&e[t++];65536>(a=224==(240&a)?(15&a)<<12|o<<6|i:(7&a)<<18|o<<12|i<<6|63&e[t++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function z(e,t){return(e>>>=0)?Y(r(),e,t):""}function B(e,t,n,r){if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var o=0;o<e.length;++o){var i=e.charCodeAt(o);if(55296<=i&&57343>=i&&(i=65536+((1023&i)<<10)|1023&e.charCodeAt(++o)),127>=i){if(n>=r)break;t[n++>>>0]=i}else{if(2047>=i){if(n+1>=r)break;t[n++>>>0]=192|i>>6}else{if(65535>=i){if(n+2>=r)break;t[n++>>>0]=224|i>>12}else{if(n+3>=r)break;t[n++>>>0]=240|i>>18,t[n++>>>0]=128|i>>12&63}t[n++>>>0]=128|i>>6&63}t[n++>>>0]=128|63&i}}return t[n>>>0]=0,n-a}function N(e){for(var t=0,n=0;n<e.length;++n){var r=e.charCodeAt(n);127>=r?t++:2047>=r?t+=2:55296<=r&&57343>=r?(t+=4,++n):t+=3}return t}function G(e){D=e,s.HEAP8=F=new Int8Array(e),s.HEAP16=new Int16Array(e),s.HEAP32=I=new Int32Array(e),s.HEAPU8=U=new Uint8Array(e),s.HEAPU16=new Uint16Array(e),s.HEAPU32=W=new Uint32Array(e),s.HEAPF32=new Float32Array(e),s.HEAPF64=j=new Float64Array(e)}O&&(D=s.buffer);var q=s.INITIAL_MEMORY||16777216;if(O)P=s.wasmMemory,D=s.buffer;else if(s.wasmMemory)P=s.wasmMemory;else if(!((P=new WebAssembly.Memory({initial:q/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw x("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),_&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");P&&(D=P.buffer),q=D.byteLength,G(D);var $,V=[],J=[],Q=[];function X(){var e=s.preRun.shift();V.unshift(e)}var K,Z=0,ee=null,te=null;function ne(e){throw O?postMessage({cmd:"onAbort",arg:e}):s.onAbort&&s.onAbort(e),x(e="Aborted("+e+")"),H=!0,e=new WebAssembly.RuntimeError(e+". Build with -sASSERTIONS for more info."),c(e),e}function re(){return K.startsWith("data:application/octet-stream;base64,")}function ae(){var e=K;try{if(e==K&&M)return new Uint8Array(M);if(p)return p(e);throw"both async and sync fetching of the wasm failed"}catch(e){ne(e)}}K="ort-wasm-threaded.wasm",re()||(K=T(K));var oe={};function ie(e){this.name="ExitStatus",this.message="Program terminated with exit("+e+")",this.status=e}function se(e){(e=fe.La[e])||ne(),fe.Xa(e)}function ue(e){var t=fe.lb();if(!t)return 6;fe.Ra.push(t),fe.La[e.Ka]=t,t.Ka=e.Ka;var n={cmd:"run",start_routine:e.pb,arg:e.ib,pthread_ptr:e.Ka};return t.Qa=()=>{n.time=performance.now(),t.postMessage(n,e.vb)},t.loaded&&(t.Qa(),delete t.Qa),0}function ce(e){if(O)return He(1,1,e);C||(fe.qb(),s.onExit&&s.onExit(e),H=!0),v(e,new ie(e))}function le(e,t){if(!t&&O)throw de(e),"unwind";ce(e)}var fe={Oa:[],Ra:[],$a:[],La:{},Ua:function(){O&&fe.mb()},xb:function(){},mb:function(){fe.receiveObjectTransfer=fe.ob,fe.threadInitTLS=fe.Za,fe.setExitStatus=fe.Ya,C=!1},Ya:function(){},qb:function(){for(var e of Object.values(fe.La))fe.Xa(e);for(e of fe.Oa)e.terminate();fe.Oa=[]},Xa:function(e){var t=e.Ka;delete fe.La[t],fe.Oa.push(e),fe.Ra.splice(fe.Ra.indexOf(e),1),e.Ka=0,ct(t)},ob:function(){},Za:function(){fe.$a.forEach((e=>e()))},nb:function(e,t){e.onmessage=n=>{var r=(n=n.data).cmd;if(e.Ka&&(fe.kb=e.Ka),n.targetThread&&n.targetThread!=rt()){var a=fe.La[n.yb];a?a.postMessage(n,n.transferList):x(\'Internal error! Worker sent a message "\'+r+\'" to target pthread \'+n.targetThread+", but that thread no longer exists!")}else"processProxyingQueue"===r?De(n.queue):"spawnThread"===r?ue(n):"cleanupThread"===r?se(n.thread):"killThread"===r?(n=n.thread,r=fe.La[n],delete fe.La[n],r.terminate(),ct(n),fe.Ra.splice(fe.Ra.indexOf(r),1),r.Ka=0):"cancelThread"===r?fe.La[n.thread].postMessage({cmd:"cancel"}):"loaded"===r?(e.loaded=!0,t&&t(e),e.Qa&&(e.Qa(),delete e.Qa)):"print"===r?R("Thread "+n.threadId+": "+n.text):"printErr"===r?x("Thread "+n.threadId+": "+n.text):"alert"===r?alert("Thread "+n.threadId+": "+n.text):"setimmediate"===n.target?e.postMessage(n):"onAbort"===r?s.onAbort&&s.onAbort(n.arg):r&&x("worker sent an unknown command "+r);fe.kb=void 0},e.onerror=e=>{throw x("worker sent an error! "+e.filename+":"+e.lineno+": "+e.message),e},_&&(e.on("message",(function(t){e.onmessage({data:t})})),e.on("error",(function(t){e.onerror(t)})),e.on("detachedExit",(function(){}))),e.postMessage({cmd:"load",urlOrBlob:s.mainScriptUrlOrBlob||_scriptDir,wasmMemory:P,wasmModule:k})},hb:function(){var e=T("ort-wasm-threaded.worker.js");fe.Oa.push(new Worker(e))},lb:function(){return 0==fe.Oa.length&&(fe.hb(),fe.nb(fe.Oa[0])),fe.Oa.pop()}};function pe(e){for(;0<e.length;)e.shift()(s)}function de(e){if(O)return He(2,0,e);try{le(e)}catch(e){e instanceof ie||"unwind"==e||v(1,e)}}s.PThread=fe,s.establishStackSpace=function(){var e=rt(),t=a()[e+44>>2>>>0];e=a()[e+48>>2>>>0],ft(t,t-e),dt(t)};var me,ge,he=[];function ye(e){this.Pa=e-24,this.gb=function(e){o()[this.Pa+4>>2>>>0]=e},this.cb=function(e){o()[this.Pa+8>>2>>>0]=e},this.eb=function(){a()[this.Pa>>2>>>0]=0},this.bb=function(){t()[this.Pa+12>>0>>>0]=0},this.fb=function(){t()[this.Pa+13>>0>>>0]=0},this.Ua=function(e,t){this.ab(),this.gb(e),this.cb(t),this.eb(),this.bb(),this.fb()},this.ab=function(){o()[this.Pa+16>>2>>>0]=0}}function ve(e,t,n,r){return O?He(3,1,e,t,n,r):be(e,t,n,r)}function be(e,t,n,r){if("undefined"==typeof SharedArrayBuffer)return x("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var a=[];return O&&0===a.length?ve(e,t,n,r):(e={pb:n,Ka:e,ib:r,vb:a},O?(e.wb="spawnThread",postMessage(e,a),0):ue(e))}function we(e,t,n){return O?He(4,1,e,t,n):0}function _e(e,t){if(O)return He(5,1,e,t)}function Oe(e,t){if(O)return He(6,1,e,t)}function Se(e,t,n){if(O)return He(7,1,e,t,n)}function Te(e,t,n){return O?He(8,1,e,t,n):0}function Ae(e,t){if(O)return He(9,1,e,t)}function Ee(e,t,n){if(O)return He(10,1,e,t,n)}function Me(e,t,n,r){if(O)return He(11,1,e,t,n,r)}function Re(e,t,n,r){if(O)return He(12,1,e,t,n,r)}function xe(e,t,n,r){if(O)return He(13,1,e,t,n,r)}function Ce(e){if(O)return He(14,1,e)}function Pe(e,t){if(O)return He(15,1,e,t)}function ke(e,t,n){if(O)return He(16,1,e,t,n)}function De(e){Atomics.store(a(),e>>2,1),rt()&&ut(e),Atomics.compareExchange(a(),e>>2,1,0)}function Fe(e){return o()[e>>>2]+4294967296*a()[e+4>>>2]}function Ue(e,t,n,r,a,o){return O?He(17,1,e,t,n,r,a,o):-52}function Ie(e,t,n,r,a,o){if(O)return He(18,1,e,t,n,r,a,o)}function We(e){var n=N(e)+1,r=at(n);return r&&B(e,t(),r,n),r}function je(e,t,n){function r(e){return(e=e.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?e[1]:"GMT"}if(O)return He(19,1,e,t,n);var i=(new Date).getFullYear(),s=new Date(i,0,1),u=new Date(i,6,1);i=s.getTimezoneOffset();var c=u.getTimezoneOffset(),l=Math.max(i,c);a()[e>>2>>>0]=60*l,a()[t>>2>>>0]=Number(i!=c),e=r(s),t=r(u),e=We(e),t=We(t),c<i?(o()[n>>2>>>0]=e,o()[n+4>>2>>>0]=t):(o()[n>>2>>>0]=t,o()[n+4>>2>>>0]=e)}function He(e,t){var n=arguments.length-2,r=arguments;return function(e){var t=pt();return e=e(),dt(t),e}((()=>{for(var a=mt(8*n),o=a>>3,s=0;s<n;s++){var u=r[2+s];i()[o+s>>>0]=u}return st(e,n,a,t)}))}s.invokeEntryPoint=function(e,t){var n=he[e];n||(e>=he.length&&(he.length=e+1),he[e]=n=$.get(e)),e=n(t),C?fe.Ya(e):lt(e)},s.executeNotifiedProxyingQueue=De,ge=_?()=>{var e=process.hrtime();return 1e3*e[0]+e[1]/1e6}:O?()=>performance.now()-s.__performance_now_clock_drift:()=>performance.now();var Le,Ye=[],ze={};function Be(){if(!Le){var e,t={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:y||"./this.program"};for(e in ze)void 0===ze[e]?delete t[e]:t[e]=ze[e];var n=[];for(e in t)n.push(e+"="+t[e]);Le=n}return Le}function Ne(e,n){if(O)return He(20,1,e,n);var r=0;return Be().forEach((function(a,i){var s=n+r;for(i=o()[e+4*i>>2>>>0]=s,s=0;s<a.length;++s)t()[i++>>0>>>0]=a.charCodeAt(s);t()[i>>0>>>0]=0,r+=a.length+1})),0}function Ge(e,t){if(O)return He(21,1,e,t);var n=Be();o()[e>>2>>>0]=n.length;var r=0;return n.forEach((function(e){r+=e.length+1})),o()[t>>2>>>0]=r,0}function qe(e){return O?He(22,1,e):52}function $e(e,t,n,r){return O?He(23,1,e,t,n,r):52}function Ve(e,t,n,r,a){return O?He(24,1,e,t,n,r,a):70}var Je=[null,[],[]];function Qe(e,t,n,a){if(O)return He(25,1,e,t,n,a);for(var i=0,s=0;s<n;s++){var u=o()[t>>2>>>0],c=o()[t+4>>2>>>0];t+=8;for(var l=0;l<c;l++){var f=r()[u+l>>>0],p=Je[e];0===f||10===f?((1===e?R:x)(Y(p,0)),p.length=0):p.push(f)}i+=c}return o()[a>>2>>>0]=i,0}function Xe(e){return 0==e%4&&(0!=e%100||0==e%400)}var Ke=[31,29,31,30,31,30,31,31,30,31,30,31],Ze=[31,28,31,30,31,30,31,31,30,31,30,31];function et(e,n,r,o){function i(e,t,n){for(e="number"==typeof e?e.toString():e||"";e.length<t;)e=n[0]+e;return e}function s(e,t){return i(e,t,"0")}function u(e,t){function n(e){return 0>e?-1:0<e?1:0}var r;return 0===(r=n(e.getFullYear()-t.getFullYear()))&&0===(r=n(e.getMonth()-t.getMonth()))&&(r=n(e.getDate()-t.getDate())),r}function c(e){switch(e.getDay()){case 0:return new Date(e.getFullYear()-1,11,29);case 1:return e;case 2:return new Date(e.getFullYear(),0,3);case 3:return new Date(e.getFullYear(),0,2);case 4:return new Date(e.getFullYear(),0,1);case 5:return new Date(e.getFullYear()-1,11,31);case 6:return new Date(e.getFullYear()-1,11,30)}}function l(e){var t=e.Ma;for(e=new Date(new Date(e.Na+1900,0,1).getTime());0<t;){var n=e.getMonth(),r=(Xe(e.getFullYear())?Ke:Ze)[n];if(!(t>r-e.getDate())){e.setDate(e.getDate()+t);break}t-=r-e.getDate()+1,e.setDate(1),11>n?e.setMonth(n+1):(e.setMonth(0),e.setFullYear(e.getFullYear()+1))}return n=new Date(e.getFullYear()+1,0,4),t=c(new Date(e.getFullYear(),0,4)),n=c(n),0>=u(t,e)?0>=u(n,e)?e.getFullYear()+1:e.getFullYear():e.getFullYear()-1}var f=a()[o+40>>2>>>0];for(var p in o={tb:a()[o>>2>>>0],sb:a()[o+4>>2>>>0],Sa:a()[o+8>>2>>>0],Va:a()[o+12>>2>>>0],Ta:a()[o+16>>2>>>0],Na:a()[o+20>>2>>>0],Ja:a()[o+24>>2>>>0],Ma:a()[o+28>>2>>>0],zb:a()[o+32>>2>>>0],rb:a()[o+36>>2>>>0],ub:f?z(f):""},r=z(r),f={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})r=r.replace(new RegExp(p,"g"),f[p]);var d="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),m="January February March April May June July August September October November December".split(" ");for(p in f={"%a":function(e){return d[e.Ja].substring(0,3)},"%A":function(e){return d[e.Ja]},"%b":function(e){return m[e.Ta].substring(0,3)},"%B":function(e){return m[e.Ta]},"%C":function(e){return s((e.Na+1900)/100|0,2)},"%d":function(e){return s(e.Va,2)},"%e":function(e){return i(e.Va,2," ")},"%g":function(e){return l(e).toString().substring(2)},"%G":function(e){return l(e)},"%H":function(e){return s(e.Sa,2)},"%I":function(e){return 0==(e=e.Sa)?e=12:12<e&&(e-=12),s(e,2)},"%j":function(e){for(var t=0,n=0;n<=e.Ta-1;t+=(Xe(e.Na+1900)?Ke:Ze)[n++]);return s(e.Va+t,3)},"%m":function(e){return s(e.Ta+1,2)},"%M":function(e){return s(e.sb,2)},"%n":function(){return"\\n"},"%p":function(e){return 0<=e.Sa&&12>e.Sa?"AM":"PM"},"%S":function(e){return s(e.tb,2)},"%t":function(){return"\\t"},"%u":function(e){return e.Ja||7},"%U":function(e){return s(Math.floor((e.Ma+7-e.Ja)/7),2)},"%V":function(e){var t=Math.floor((e.Ma+7-(e.Ja+6)%7)/7);if(2>=(e.Ja+371-e.Ma-2)%7&&t++,t)53==t&&(4==(n=(e.Ja+371-e.Ma)%7)||3==n&&Xe(e.Na)||(t=1));else{t=52;var n=(e.Ja+7-e.Ma-1)%7;(4==n||5==n&&Xe(e.Na%400-1))&&t++}return s(t,2)},"%w":function(e){return e.Ja},"%W":function(e){return s(Math.floor((e.Ma+7-(e.Ja+6)%7)/7),2)},"%y":function(e){return(e.Na+1900).toString().substring(2)},"%Y":function(e){return e.Na+1900},"%z":function(e){var t=0<=(e=e.rb);return e=Math.abs(e)/60,(t?"+":"-")+String("0000"+(e/60*100+e%60)).slice(-4)},"%Z":function(e){return e.ub},"%%":function(){return"%"}},r=r.replace(/%%/g,"\\0\\0"),f)r.includes(p)&&(r=r.replace(new RegExp(p,"g"),f[p](o)));return p=function(e){var t=Array(N(e)+1);return B(e,t,0,t.length),t}(r=r.replace(/\\0\\0/g,"%")),p.length>n?0:(function(e,n){t().set(e,n>>>0)}(p,e),p.length-1)}fe.Ua();var tt=[null,ce,de,ve,we,_e,Oe,Se,Te,Ae,Ee,Me,Re,xe,Ce,Pe,ke,Ue,Ie,je,Ne,Ge,qe,$e,Ve,Qe],nt={b:function(e){return at(e+24)+24},c:function(e,t,n){throw new ye(e).Ua(t,n),e},L:function(e){ot(e,!w,1,!b),fe.Za()},l:function(e){O?postMessage({cmd:"cleanupThread",thread:e}):se(e)},D:be,i:we,R:_e,z:Oe,B:Se,T:Te,P:Ae,I:Ee,O:Me,p:Re,A:xe,x:Ce,Q:Pe,y:ke,r:function(){},j:function(){ne("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},s:function(){ne("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},q:function(){return Date.now()},E:function(){return 2097152},V:function(){return!0},F:function(e,t,n,r){if(e==t)setTimeout((()=>De(r)));else if(O)postMessage({targetThread:e,cmd:"processProxyingQueue",queue:r});else{if(!(e=fe.La[e]))return;e.postMessage({cmd:"processProxyingQueue",queue:r})}return 1},K:function(){return-1},W:function(e,t){e=new Date(1e3*Fe(e)),a()[t>>2>>>0]=e.getUTCSeconds(),a()[t+4>>2>>>0]=e.getUTCMinutes(),a()[t+8>>2>>>0]=e.getUTCHours(),a()[t+12>>2>>>0]=e.getUTCDate(),a()[t+16>>2>>>0]=e.getUTCMonth(),a()[t+20>>2>>>0]=e.getUTCFullYear()-1900,a()[t+24>>2>>>0]=e.getUTCDay(),e=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,a()[t+28>>2>>>0]=e},X:function(e,t){e=new Date(1e3*Fe(e)),a()[t>>2>>>0]=e.getSeconds(),a()[t+4>>2>>>0]=e.getMinutes(),a()[t+8>>2>>>0]=e.getHours(),a()[t+12>>2>>>0]=e.getDate(),a()[t+16>>2>>>0]=e.getMonth(),a()[t+20>>2>>>0]=e.getFullYear()-1900,a()[t+24>>2>>>0]=e.getDay();var n=new Date(e.getFullYear(),0,1),r=(e.getTime()-n.getTime())/864e5|0;a()[t+28>>2>>>0]=r,a()[t+36>>2>>>0]=-60*e.getTimezoneOffset(),r=new Date(e.getFullYear(),6,1).getTimezoneOffset(),e=0|(r!=(n=n.getTimezoneOffset())&&e.getTimezoneOffset()==Math.min(n,r)),a()[t+32>>2>>>0]=e},Y:function(e){var t=new Date(a()[e+20>>2>>>0]+1900,a()[e+16>>2>>>0],a()[e+12>>2>>>0],a()[e+8>>2>>>0],a()[e+4>>2>>>0],a()[e>>2>>>0],0),n=a()[e+32>>2>>>0],r=t.getTimezoneOffset(),o=new Date(t.getFullYear(),0,1),i=new Date(t.getFullYear(),6,1).getTimezoneOffset(),s=o.getTimezoneOffset(),u=Math.min(s,i);return 0>n?a()[e+32>>2>>>0]=Number(i!=s&&u==r):0<n!=(u==r)&&(i=Math.max(s,i),t.setTime(t.getTime()+6e4*((0<n?u:i)-r))),a()[e+24>>2>>>0]=t.getDay(),n=(t.getTime()-o.getTime())/864e5|0,a()[e+28>>2>>>0]=n,a()[e>>2>>>0]=t.getSeconds(),a()[e+4>>2>>>0]=t.getMinutes(),a()[e+8>>2>>>0]=t.getHours(),a()[e+12>>2>>>0]=t.getDate(),a()[e+16>>2>>>0]=t.getMonth(),t.getTime()/1e3|0},G:Ue,H:Ie,Z:function e(t,n,r){e.jb||(e.jb=!0,je(t,n,r))},d:function(){ne("")},m:function(){if(!_&&!w){var e="Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread";me||(me={}),me[e]||(me[e]=1,_&&(e="warning: "+e),x(e))}},w:function(){return 4294901760},f:ge,S:function(e,t,n){r().copyWithin(e>>>0,t>>>0,t+n>>>0)},g:function(){return _?n(993).cpus().length:navigator.hardwareConcurrency},J:function(e,t,n){Ye.length=t,n>>=3;for(var r=0;r<t;r++)Ye[r]=i()[n+r>>>0];return(0>e?oe[-e-1]:tt[e]).apply(null,Ye)},v:function(e){var t=r().length;if((e>>>=0)<=t||4294901760<e)return!1;for(var n=1;4>=n;n*=2){var a=t*(1+.2/n);a=Math.min(a,e+100663296);var o=Math;a=Math.max(e,a),o=o.min.call(o,4294901760,a+(65536-a%65536)%65536);e:{try{P.grow(o-D.byteLength+65535>>>16),G(P.buffer);var i=1;break e}catch(e){}i=void 0}if(i)return!0}return!1},U:function(){throw"unwind"},M:Ne,N:Ge,k:le,h:qe,o:$e,t:Ve,n:Qe,u:function e(r,a){e.Wa||(e.Wa=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var e=new Uint8Array(1);return()=>(crypto.getRandomValues(e),e[0])}if(_)try{var t=n(760);return()=>t.randomBytes(1)[0]}catch(e){}return()=>ne("randomDevice")}());for(var o=0;o<a;o++)t()[r+o>>0>>>0]=e.Wa();return 0},a:P||s.wasmMemory,C:et,e:function(e,t,n,r){return et(e,t,n,r)}};!function(){function e(e,t){s.asm=e.exports,fe.$a.push(s.asm.wa),$=s.asm.za,J.unshift(s.asm._),k=t,O||(Z--,s.monitorRunDependencies&&s.monitorRunDependencies(Z),0==Z&&(null!==ee&&(clearInterval(ee),ee=null),te&&(e=te,te=null,e())))}function t(t){e(t.instance,t.module)}function n(e){return function(){if(!M&&(b||w)){if("function"==typeof fetch&&!K.startsWith("file://"))return fetch(K,{credentials:"same-origin"}).then((function(e){if(!e.ok)throw"failed to load wasm binary file at \'"+K+"\'";return e.arrayBuffer()})).catch((function(){return ae()}));if(f)return new Promise((function(e,t){f(K,(function(t){e(new Uint8Array(t))}),t)}))}return Promise.resolve().then((function(){return ae()}))}().then((function(e){return WebAssembly.instantiate(e,r)})).then((function(e){return e})).then(e,(function(e){x("failed to asynchronously prepare wasm: "+e),ne(e)}))}var r={a:nt};if(O||(Z++,s.monitorRunDependencies&&s.monitorRunDependencies(Z)),s.instantiateWasm)try{return s.instantiateWasm(r,e)}catch(e){return x("Module.instantiateWasm callback failed with error: "+e),!1}(M||"function"!=typeof WebAssembly.instantiateStreaming||re()||K.startsWith("file://")||_||"function"!=typeof fetch?n(t):fetch(K,{credentials:"same-origin"}).then((function(e){return WebAssembly.instantiateStreaming(e,r).then(t,(function(e){return x("wasm streaming compile failed: "+e),x("falling back to ArrayBuffer instantiation"),n(t)}))}))).catch(c)}(),s.___wasm_call_ctors=function(){return(s.___wasm_call_ctors=s.asm._).apply(null,arguments)},s._OrtInit=function(){return(s._OrtInit=s.asm.$).apply(null,arguments)},s._OrtCreateSessionOptions=function(){return(s._OrtCreateSessionOptions=s.asm.aa).apply(null,arguments)},s._OrtAppendExecutionProvider=function(){return(s._OrtAppendExecutionProvider=s.asm.ba).apply(null,arguments)},s._OrtAddSessionConfigEntry=function(){return(s._OrtAddSessionConfigEntry=s.asm.ca).apply(null,arguments)},s._OrtReleaseSessionOptions=function(){return(s._OrtReleaseSessionOptions=s.asm.da).apply(null,arguments)},s._OrtCreateSession=function(){return(s._OrtCreateSession=s.asm.ea).apply(null,arguments)},s._OrtReleaseSession=function(){return(s._OrtReleaseSession=s.asm.fa).apply(null,arguments)},s._OrtGetInputCount=function(){return(s._OrtGetInputCount=s.asm.ga).apply(null,arguments)},s._OrtGetOutputCount=function(){return(s._OrtGetOutputCount=s.asm.ha).apply(null,arguments)},s._OrtGetInputName=function(){return(s._OrtGetInputName=s.asm.ia).apply(null,arguments)},s._OrtGetOutputName=function(){return(s._OrtGetOutputName=s.asm.ja).apply(null,arguments)},s._OrtFree=function(){return(s._OrtFree=s.asm.ka).apply(null,arguments)},s._OrtCreateTensor=function(){return(s._OrtCreateTensor=s.asm.la).apply(null,arguments)},s._OrtGetTensorData=function(){return(s._OrtGetTensorData=s.asm.ma).apply(null,arguments)},s._OrtReleaseTensor=function(){return(s._OrtReleaseTensor=s.asm.na).apply(null,arguments)},s._OrtCreateRunOptions=function(){return(s._OrtCreateRunOptions=s.asm.oa).apply(null,arguments)},s._OrtAddRunConfigEntry=function(){return(s._OrtAddRunConfigEntry=s.asm.pa).apply(null,arguments)},s._OrtReleaseRunOptions=function(){return(s._OrtReleaseRunOptions=s.asm.qa).apply(null,arguments)},s._OrtRun=function(){return(s._OrtRun=s.asm.ra).apply(null,arguments)},s._OrtEndProfiling=function(){return(s._OrtEndProfiling=s.asm.sa).apply(null,arguments)};var rt=s._pthread_self=function(){return(rt=s._pthread_self=s.asm.ta).apply(null,arguments)},at=s._malloc=function(){return(at=s._malloc=s.asm.ua).apply(null,arguments)};s._free=function(){return(s._free=s.asm.va).apply(null,arguments)},s.__emscripten_tls_init=function(){return(s.__emscripten_tls_init=s.asm.wa).apply(null,arguments)};var ot=s.__emscripten_thread_init=function(){return(ot=s.__emscripten_thread_init=s.asm.xa).apply(null,arguments)};s.__emscripten_thread_crashed=function(){return(s.__emscripten_thread_crashed=s.asm.ya).apply(null,arguments)};var it,st=s._emscripten_run_in_main_runtime_thread_js=function(){return(st=s._emscripten_run_in_main_runtime_thread_js=s.asm.Aa).apply(null,arguments)},ut=s.__emscripten_proxy_execute_task_queue=function(){return(ut=s.__emscripten_proxy_execute_task_queue=s.asm.Ba).apply(null,arguments)},ct=s.__emscripten_thread_free_data=function(){return(ct=s.__emscripten_thread_free_data=s.asm.Ca).apply(null,arguments)},lt=s.__emscripten_thread_exit=function(){return(lt=s.__emscripten_thread_exit=s.asm.Da).apply(null,arguments)},ft=s._emscripten_stack_set_limits=function(){return(ft=s._emscripten_stack_set_limits=s.asm.Ea).apply(null,arguments)},pt=s.stackSave=function(){return(pt=s.stackSave=s.asm.Fa).apply(null,arguments)},dt=s.stackRestore=function(){return(dt=s.stackRestore=s.asm.Ga).apply(null,arguments)},mt=s.stackAlloc=function(){return(mt=s.stackAlloc=s.asm.Ha).apply(null,arguments)};function gt(){function e(){if(!it&&(it=!0,s.calledRun=!0,!H)&&(O||pe(J),u(s),s.onRuntimeInitialized&&s.onRuntimeInitialized(),!O)){if(s.postRun)for("function"==typeof s.postRun&&(s.postRun=[s.postRun]);s.postRun.length;){var e=s.postRun.shift();Q.unshift(e)}pe(Q)}}if(!(0<Z))if(O)u(s),O||pe(J),postMessage({cmd:"loaded"});else{if(s.preRun)for("function"==typeof s.preRun&&(s.preRun=[s.preRun]);s.preRun.length;)X();pe(V),0<Z||(s.setStatus?(s.setStatus("Running..."),setTimeout((function(){setTimeout((function(){s.setStatus("")}),1),e()}),1)):e())}}if(s.___cxa_is_pointer_type=function(){return(s.___cxa_is_pointer_type=s.asm.Ia).apply(null,arguments)},s.UTF8ToString=z,s.stringToUTF8=function(e,t,n){return B(e,r(),t,n)},s.lengthBytesUTF8=N,s.keepRuntimeAlive=function(){return C},s.wasmMemory=P,s.stackSave=pt,s.stackRestore=dt,s.stackAlloc=mt,s.ExitStatus=ie,s.PThread=fe,te=function e(){it||gt(),it||(te=e)},s.preInit)for("function"==typeof s.preInit&&(s.preInit=[s.preInit]);0<s.preInit.length;)s.preInit.pop()();return gt(),e.ready});e.exports=r},932:(e,t,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(e){var t,r,a;e=e||{},t||(t=void 0!==e?e:{}),t.ready=new Promise((function(e,t){r=e,a=t}));var o,i,s,u,c,l,f=Object.assign({},t),p="./this.program",d=(e,t)=>{throw t},m="object"==typeof window,g="function"==typeof importScripts,h="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,y="";h?(y=g?n(908).dirname(y)+"/":"//",l=()=>{c||(u=n(384),c=n(908))},o=function(e,t){return l(),e=c.normalize(e),u.readFileSync(e,t?void 0:"utf8")},s=e=>((e=o(e,!0)).buffer||(e=new Uint8Array(e)),e),i=(e,t,n)=>{l(),e=c.normalize(e),u.readFile(e,(function(e,r){e?n(e):t(r.buffer)}))},1<process.argv.length&&(p=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(e){if(!(e instanceof $))throw e})),process.on("unhandledRejection",(function(e){throw e})),d=(e,t)=>{if(_)throw process.exitCode=e,t;t instanceof $||w("exiting due to exception: "+t),process.exit(e)},t.inspect=function(){return"[Emscripten Module object]"}):(m||g)&&(g?y=self.location.href:"undefined"!=typeof document&&document.currentScript&&(y=document.currentScript.src),_scriptDir&&(y=_scriptDir),y=0!==y.indexOf("blob:")?y.substr(0,y.replace(/[?#].*/,"").lastIndexOf("/")+1):"",o=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},g&&(s=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),i=(e,t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?t(r.response):n()},r.onerror=n,r.send(null)});var v,b=t.print||console.log.bind(console),w=t.printErr||console.warn.bind(console);Object.assign(t,f),f=null,t.thisProgram&&(p=t.thisProgram),t.quit&&(d=t.quit),t.wasmBinary&&(v=t.wasmBinary);var _=t.noExitRuntime||!0;"object"!=typeof WebAssembly&&B("no native wasm support detected");var O,S,T,A,E,M,R=!1,x="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function C(e,t,n){var r=(t>>>=0)+n;for(n=t;e[n]&&!(n>=r);)++n;if(16<n-t&&e.buffer&&x)return x.decode(e.subarray(t,n));for(r="";t<n;){var a=e[t++];if(128&a){var o=63&e[t++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|o);else{var i=63&e[t++];65536>(a=224==(240&a)?(15&a)<<12|o<<6|i:(7&a)<<18|o<<12|i<<6|63&e[t++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function P(e,t){return(e>>>=0)?C(A,e,t):""}function k(e,t,n,r){if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var o=0;o<e.length;++o){var i=e.charCodeAt(o);if(55296<=i&&57343>=i&&(i=65536+((1023&i)<<10)|1023&e.charCodeAt(++o)),127>=i){if(n>=r)break;t[n++>>>0]=i}else{if(2047>=i){if(n+1>=r)break;t[n++>>>0]=192|i>>6}else{if(65535>=i){if(n+2>=r)break;t[n++>>>0]=224|i>>12}else{if(n+3>=r)break;t[n++>>>0]=240|i>>18,t[n++>>>0]=128|i>>12&63}t[n++>>>0]=128|i>>6&63}t[n++>>>0]=128|63&i}}return t[n>>>0]=0,n-a}function D(e){for(var t=0,n=0;n<e.length;++n){var r=e.charCodeAt(n);127>=r?t++:2047>=r?t+=2:55296<=r&&57343>=r?(t+=4,++n):t+=3}return t}function F(){var e=O.buffer;S=e,t.HEAP8=T=new Int8Array(e),t.HEAP16=new Int16Array(e),t.HEAP32=E=new Int32Array(e),t.HEAPU8=A=new Uint8Array(e),t.HEAPU16=new Uint16Array(e),t.HEAPU32=M=new Uint32Array(e),t.HEAPF32=new Float32Array(e),t.HEAPF64=new Float64Array(e)}var U=[],I=[],W=[];function j(){var e=t.preRun.shift();U.unshift(e)}var H,L=0,Y=null,z=null;function B(e){throw t.onAbort&&t.onAbort(e),w(e="Aborted("+e+")"),R=!0,e=new WebAssembly.RuntimeError(e+". Build with -sASSERTIONS for more info."),a(e),e}function N(){return H.startsWith("data:application/octet-stream;base64,")}if(H="ort-wasm.wasm",!N()){var G=H;H=t.locateFile?t.locateFile(G,y):y+G}function q(){var e=H;try{if(e==H&&v)return new Uint8Array(v);if(s)return s(e);throw"both async and sync fetching of the wasm failed"}catch(e){B(e)}}function $(e){this.name="ExitStatus",this.message="Program terminated with exit("+e+")",this.status=e}function V(e){for(;0<e.length;)e.shift()(t)}function J(e){this.sa=e-24,this.Ia=function(e){M[this.sa+4>>2>>>0]=e},this.Ba=function(e){M[this.sa+8>>2>>>0]=e},this.Ga=function(){E[this.sa>>2>>>0]=0},this.Aa=function(){T[this.sa+12>>0>>>0]=0},this.Ha=function(){T[this.sa+13>>0>>>0]=0},this.ya=function(e,t){this.za(),this.Ia(e),this.Ba(t),this.Ga(),this.Aa(),this.Ha()},this.za=function(){M[this.sa+16>>2>>>0]=0}}function Q(e){var t=D(e)+1,n=ie(t);return n&&k(e,T,n,t),n}var X={};function K(){if(!Z){var e,t={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:p||"./this.program"};for(e in X)void 0===X[e]?delete t[e]:t[e]=X[e];var n=[];for(e in t)n.push(e+"="+t[e]);Z=n}return Z}var Z,ee=[null,[],[]];function te(e){return 0==e%4&&(0!=e%100||0==e%400)}var ne=[31,29,31,30,31,30,31,31,30,31,30,31],re=[31,28,31,30,31,30,31,31,30,31,30,31];function ae(e,t,n,r){function a(e,t,n){for(e="number"==typeof e?e.toString():e||"";e.length<t;)e=n[0]+e;return e}function o(e,t){return a(e,t,"0")}function i(e,t){function n(e){return 0>e?-1:0<e?1:0}var r;return 0===(r=n(e.getFullYear()-t.getFullYear()))&&0===(r=n(e.getMonth()-t.getMonth()))&&(r=n(e.getDate()-t.getDate())),r}function s(e){switch(e.getDay()){case 0:return new Date(e.getFullYear()-1,11,29);case 1:return e;case 2:return new Date(e.getFullYear(),0,3);case 3:return new Date(e.getFullYear(),0,2);case 4:return new Date(e.getFullYear(),0,1);case 5:return new Date(e.getFullYear()-1,11,31);case 6:return new Date(e.getFullYear()-1,11,30)}}function u(e){var t=e.qa;for(e=new Date(new Date(e.ra+1900,0,1).getTime());0<t;){var n=e.getMonth(),r=(te(e.getFullYear())?ne:re)[n];if(!(t>r-e.getDate())){e.setDate(e.getDate()+t);break}t-=r-e.getDate()+1,e.setDate(1),11>n?e.setMonth(n+1):(e.setMonth(0),e.setFullYear(e.getFullYear()+1))}return n=new Date(e.getFullYear()+1,0,4),t=s(new Date(e.getFullYear(),0,4)),n=s(n),0>=i(t,e)?0>=i(n,e)?e.getFullYear()+1:e.getFullYear():e.getFullYear()-1}var c=E[r+40>>2>>>0];for(var l in r={Ea:E[r>>2>>>0],Da:E[r+4>>2>>>0],ta:E[r+8>>2>>>0],va:E[r+12>>2>>>0],ua:E[r+16>>2>>>0],ra:E[r+20>>2>>>0],la:E[r+24>>2>>>0],qa:E[r+28>>2>>>0],Ja:E[r+32>>2>>>0],Ca:E[r+36>>2>>>0],Fa:c?P(c):""},n=P(n),c={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})n=n.replace(new RegExp(l,"g"),c[l]);var f="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),p="January February March April May June July August September October November December".split(" ");for(l in c={"%a":function(e){return f[e.la].substring(0,3)},"%A":function(e){return f[e.la]},"%b":function(e){return p[e.ua].substring(0,3)},"%B":function(e){return p[e.ua]},"%C":function(e){return o((e.ra+1900)/100|0,2)},"%d":function(e){return o(e.va,2)},"%e":function(e){return a(e.va,2," ")},"%g":function(e){return u(e).toString().substring(2)},"%G":function(e){return u(e)},"%H":function(e){return o(e.ta,2)},"%I":function(e){return 0==(e=e.ta)?e=12:12<e&&(e-=12),o(e,2)},"%j":function(e){for(var t=0,n=0;n<=e.ua-1;t+=(te(e.ra+1900)?ne:re)[n++]);return o(e.va+t,3)},"%m":function(e){return o(e.ua+1,2)},"%M":function(e){return o(e.Da,2)},"%n":function(){return"\\n"},"%p":function(e){return 0<=e.ta&&12>e.ta?"AM":"PM"},"%S":function(e){return o(e.Ea,2)},"%t":function(){return"\\t"},"%u":function(e){return e.la||7},"%U":function(e){return o(Math.floor((e.qa+7-e.la)/7),2)},"%V":function(e){var t=Math.floor((e.qa+7-(e.la+6)%7)/7);if(2>=(e.la+371-e.qa-2)%7&&t++,t)53==t&&(4==(n=(e.la+371-e.qa)%7)||3==n&&te(e.ra)||(t=1));else{t=52;var n=(e.la+7-e.qa-1)%7;(4==n||5==n&&te(e.ra%400-1))&&t++}return o(t,2)},"%w":function(e){return e.la},"%W":function(e){return o(Math.floor((e.qa+7-(e.la+6)%7)/7),2)},"%y":function(e){return(e.ra+1900).toString().substring(2)},"%Y":function(e){return e.ra+1900},"%z":function(e){var t=0<=(e=e.Ca);return e=Math.abs(e)/60,(t?"+":"-")+String("0000"+(e/60*100+e%60)).slice(-4)},"%Z":function(e){return e.Fa},"%%":function(){return"%"}},n=n.replace(/%%/g,"\\0\\0"),c)n.includes(l)&&(n=n.replace(new RegExp(l,"g"),c[l](r)));return l=function(e){var t=Array(D(e)+1);return k(e,t,0,t.length),t}(n=n.replace(/\\0\\0/g,"%")),l.length>t?0:(T.set(l,e>>>0),l.length-1)}var oe={a:function(e){return ie(e+24)+24},b:function(e,t,n){throw new J(e).ya(t,n),e},g:function(){return 0},I:function(){},w:function(){},y:function(){},K:function(){return 0},G:function(){},C:function(){},F:function(){},k:function(){},x:function(){},u:function(){},H:function(){},v:function(){},n:function(){},p:function(){B("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},o:function(){B("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},l:function(){return Date.now()},L:function(){return!0},M:function(e,t){e=new Date(1e3*(M[e>>>2]+4294967296*E[e+4>>>2])),E[t>>2>>>0]=e.getUTCSeconds(),E[t+4>>2>>>0]=e.getUTCMinutes(),E[t+8>>2>>>0]=e.getUTCHours(),E[t+12>>2>>>0]=e.getUTCDate(),E[t+16>>2>>>0]=e.getUTCMonth(),E[t+20>>2>>>0]=e.getUTCFullYear()-1900,E[t+24>>2>>>0]=e.getUTCDay(),E[t+28>>2>>>0]=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},N:function(e,t){e=new Date(1e3*(M[e>>>2]+4294967296*E[e+4>>>2])),E[t>>2>>>0]=e.getSeconds(),E[t+4>>2>>>0]=e.getMinutes(),E[t+8>>2>>>0]=e.getHours(),E[t+12>>2>>>0]=e.getDate(),E[t+16>>2>>>0]=e.getMonth(),E[t+20>>2>>>0]=e.getFullYear()-1900,E[t+24>>2>>>0]=e.getDay();var n=new Date(e.getFullYear(),0,1);E[t+28>>2>>>0]=(e.getTime()-n.getTime())/864e5|0,E[t+36>>2>>>0]=-60*e.getTimezoneOffset();var r=new Date(e.getFullYear(),6,1).getTimezoneOffset();n=n.getTimezoneOffset(),E[t+32>>2>>>0]=0|(r!=n&&e.getTimezoneOffset()==Math.min(n,r))},O:function(e){var t=new Date(E[e+20>>2>>>0]+1900,E[e+16>>2>>>0],E[e+12>>2>>>0],E[e+8>>2>>>0],E[e+4>>2>>>0],E[e>>2>>>0],0),n=E[e+32>>2>>>0],r=t.getTimezoneOffset(),a=new Date(t.getFullYear(),0,1),o=new Date(t.getFullYear(),6,1).getTimezoneOffset(),i=a.getTimezoneOffset(),s=Math.min(i,o);return 0>n?E[e+32>>2>>>0]=Number(o!=i&&s==r):0<n!=(s==r)&&(o=Math.max(i,o),t.setTime(t.getTime()+6e4*((0<n?s:o)-r))),E[e+24>>2>>>0]=t.getDay(),E[e+28>>2>>>0]=(t.getTime()-a.getTime())/864e5|0,E[e>>2>>>0]=t.getSeconds(),E[e+4>>2>>>0]=t.getMinutes(),E[e+8>>2>>>0]=t.getHours(),E[e+12>>2>>>0]=t.getDate(),E[e+16>>2>>>0]=t.getMonth(),t.getTime()/1e3|0},z:function(){return-52},B:function(){},m:function e(t,n,r){e.xa||(e.xa=!0,function(e,t,n){function r(e){return(e=e.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?e[1]:"GMT"}var a=(new Date).getFullYear(),o=new Date(a,0,1),i=new Date(a,6,1);a=o.getTimezoneOffset();var s=i.getTimezoneOffset();E[e>>2>>>0]=60*Math.max(a,s),E[t>>2>>>0]=Number(a!=s),e=r(o),t=r(i),e=Q(e),t=Q(t),s<a?(M[n>>2>>>0]=e,M[n+4>>2>>>0]=t):(M[n>>2>>>0]=t,M[n+4>>2>>>0]=e)}(t,n,r))},d:function(){B("")},t:function(){return 4294901760},h:h?()=>{var e=process.hrtime();return 1e3*e[0]+e[1]/1e6}:()=>performance.now(),J:function(e,t,n){A.copyWithin(e>>>0,t>>>0,t+n>>>0)},f:function(e){var t=A.length;if(4294901760<(e>>>=0))return!1;for(var n=1;4>=n;n*=2){var r=t*(1+.2/n);r=Math.min(r,e+100663296);var a=Math;r=Math.max(e,r),a=a.min.call(a,4294901760,r+(65536-r%65536)%65536);e:{try{O.grow(a-S.byteLength+65535>>>16),F();var o=1;break e}catch(e){}o=void 0}if(o)return!0}return!1},D:function(e,t){var n=0;return K().forEach((function(r,a){var o=t+n;for(a=M[e+4*a>>2>>>0]=o,o=0;o<r.length;++o)T[a++>>0>>>0]=r.charCodeAt(o);T[a>>0>>>0]=0,n+=r.length+1})),0},E:function(e,t){var n=K();M[e>>2>>>0]=n.length;var r=0;return n.forEach((function(e){r+=e.length+1})),M[t>>2>>>0]=r,0},r:function(e){_||(t.onExit&&t.onExit(e),R=!0),d(e,new $(e))},e:function(){return 52},j:function(){return 52},q:function(){return 70},i:function(e,t,n,r){for(var a=0,o=0;o<n;o++){var i=M[t>>2>>>0],s=M[t+4>>2>>>0];t+=8;for(var u=0;u<s;u++){var c=A[i+u>>>0],l=ee[e];0===c||10===c?((1===e?b:w)(C(l,0)),l.length=0):l.push(c)}a+=s}return M[r>>2>>>0]=a,0},s:function e(t,r){e.wa||(e.wa=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var e=new Uint8Array(1);return()=>(crypto.getRandomValues(e),e[0])}if(h)try{var t=n(760);return()=>t.randomBytes(1)[0]}catch(e){}return()=>B("randomDevice")}());for(var a=0;a<r;a++)T[t+a>>0>>>0]=e.wa();return 0},A:ae,c:function(e,t,n,r){return ae(e,t,n,r)}};!function(){function e(e){t.asm=e.exports,O=t.asm.P,F(),I.unshift(t.asm.Q),L--,t.monitorRunDependencies&&t.monitorRunDependencies(L),0==L&&(null!==Y&&(clearInterval(Y),Y=null),z&&(e=z,z=null,e()))}function n(t){e(t.instance)}function r(e){return function(){if(!v&&(m||g)){if("function"==typeof fetch&&!H.startsWith("file://"))return fetch(H,{credentials:"same-origin"}).then((function(e){if(!e.ok)throw"failed to load wasm binary file at \'"+H+"\'";return e.arrayBuffer()})).catch((function(){return q()}));if(i)return new Promise((function(e,t){i(H,(function(t){e(new Uint8Array(t))}),t)}))}return Promise.resolve().then((function(){return q()}))}().then((function(e){return WebAssembly.instantiate(e,o)})).then((function(e){return e})).then(e,(function(e){w("failed to asynchronously prepare wasm: "+e),B(e)}))}var o={a:oe};if(L++,t.monitorRunDependencies&&t.monitorRunDependencies(L),t.instantiateWasm)try{return t.instantiateWasm(o,e)}catch(e){return w("Module.instantiateWasm callback failed with error: "+e),!1}(v||"function"!=typeof WebAssembly.instantiateStreaming||N()||H.startsWith("file://")||h||"function"!=typeof fetch?r(n):fetch(H,{credentials:"same-origin"}).then((function(e){return WebAssembly.instantiateStreaming(e,o).then(n,(function(e){return w("wasm streaming compile failed: "+e),w("falling back to ArrayBuffer instantiation"),r(n)}))}))).catch(a)}(),t.___wasm_call_ctors=function(){return(t.___wasm_call_ctors=t.asm.Q).apply(null,arguments)},t._OrtInit=function(){return(t._OrtInit=t.asm.R).apply(null,arguments)},t._OrtCreateSessionOptions=function(){return(t._OrtCreateSessionOptions=t.asm.S).apply(null,arguments)},t._OrtAppendExecutionProvider=function(){return(t._OrtAppendExecutionProvider=t.asm.T).apply(null,arguments)},t._OrtAddSessionConfigEntry=function(){return(t._OrtAddSessionConfigEntry=t.asm.U).apply(null,arguments)},t._OrtReleaseSessionOptions=function(){return(t._OrtReleaseSessionOptions=t.asm.V).apply(null,arguments)},t._OrtCreateSession=function(){return(t._OrtCreateSession=t.asm.W).apply(null,arguments)},t._OrtReleaseSession=function(){return(t._OrtReleaseSession=t.asm.X).apply(null,arguments)},t._OrtGetInputCount=function(){return(t._OrtGetInputCount=t.asm.Y).apply(null,arguments)},t._OrtGetOutputCount=function(){return(t._OrtGetOutputCount=t.asm.Z).apply(null,arguments)},t._OrtGetInputName=function(){return(t._OrtGetInputName=t.asm._).apply(null,arguments)},t._OrtGetOutputName=function(){return(t._OrtGetOutputName=t.asm.$).apply(null,arguments)},t._OrtFree=function(){return(t._OrtFree=t.asm.aa).apply(null,arguments)},t._OrtCreateTensor=function(){return(t._OrtCreateTensor=t.asm.ba).apply(null,arguments)},t._OrtGetTensorData=function(){return(t._OrtGetTensorData=t.asm.ca).apply(null,arguments)},t._OrtReleaseTensor=function(){return(t._OrtReleaseTensor=t.asm.da).apply(null,arguments)},t._OrtCreateRunOptions=function(){return(t._OrtCreateRunOptions=t.asm.ea).apply(null,arguments)},t._OrtAddRunConfigEntry=function(){return(t._OrtAddRunConfigEntry=t.asm.fa).apply(null,arguments)},t._OrtReleaseRunOptions=function(){return(t._OrtReleaseRunOptions=t.asm.ga).apply(null,arguments)},t._OrtRun=function(){return(t._OrtRun=t.asm.ha).apply(null,arguments)},t._OrtEndProfiling=function(){return(t._OrtEndProfiling=t.asm.ia).apply(null,arguments)};var ie=t._malloc=function(){return(ie=t._malloc=t.asm.ja).apply(null,arguments)};t._free=function(){return(t._free=t.asm.ka).apply(null,arguments)};var se,ue=t.stackSave=function(){return(ue=t.stackSave=t.asm.ma).apply(null,arguments)},ce=t.stackRestore=function(){return(ce=t.stackRestore=t.asm.na).apply(null,arguments)},le=t.stackAlloc=function(){return(le=t.stackAlloc=t.asm.oa).apply(null,arguments)};function fe(){function e(){if(!se&&(se=!0,t.calledRun=!0,!R)){if(V(I),r(t),t.onRuntimeInitialized&&t.onRuntimeInitialized(),t.postRun)for("function"==typeof t.postRun&&(t.postRun=[t.postRun]);t.postRun.length;){var e=t.postRun.shift();W.unshift(e)}V(W)}}if(!(0<L)){if(t.preRun)for("function"==typeof t.preRun&&(t.preRun=[t.preRun]);t.preRun.length;)j();V(U),0<L||(t.setStatus?(t.setStatus("Running..."),setTimeout((function(){setTimeout((function(){t.setStatus("")}),1),e()}),1)):e())}}if(t.___cxa_is_pointer_type=function(){return(t.___cxa_is_pointer_type=t.asm.pa).apply(null,arguments)},t.UTF8ToString=P,t.stringToUTF8=function(e,t,n){return k(e,A,t,n)},t.lengthBytesUTF8=D,t.stackSave=ue,t.stackRestore=ce,t.stackAlloc=le,z=function e(){se||fe(),se||(z=e)},t.preInit)for("function"==typeof t.preInit&&(t.preInit=[t.preInit]);0<t.preInit.length;)t.preInit.pop()();return fe(),e.ready});e.exports=r},154:e=>{"use strict";e.exports=\'"use strict";var e={},t="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(t){var r=require("worker_threads"),a=r.parentPort;a.on("message",(e=>onmessage({data:e})));var o=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:function(e){(0,eval)(o.readFileSync(e,"utf8"))},postMessage:function(e){a.postMessage(e)},performance:global.performance||{now:function(){return Date.now()}}})}var s=!1,n=[],i=function(){var e=Array.prototype.slice.call(arguments).join(" ");t?o.writeSync(2,e+"\\\\n"):console.error(e)};self.alert=function(){var t=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:t,threadId:e._pthread_self()})},e.instantiateWasm=(t,r)=>{var a=new WebAssembly.Instance(e.wasmModule,t);return r(a),e.wasmModule=null,a.exports},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=t=>{try{if("load"===t.data.cmd){if(e.wasmModule=t.data.wasmModule,e.wasmMemory=t.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof t.data.urlOrBlob)importScripts(t.data.urlOrBlob);else{var r=URL.createObjectURL(t.data.urlOrBlob);importScripts(r),URL.revokeObjectURL(r)}ortWasmThreaded(e).then((function(t){e=t}))}else if("run"===t.data.cmd){e.__performance_now_clock_drift=performance.now()-t.data.time,e.__emscripten_thread_init(t.data.pthread_ptr,0,0,1),e.establishStackSpace(),e.PThread.receiveObjectTransfer(t.data),e.PThread.threadInitTLS(),s||(n.forEach((t=>{e.executeNotifiedProxyingQueue(t)})),n=[],s=!0);try{e.invokeEntryPoint(t.data.start_routine,t.data.arg)}catch(t){if("unwind"!=t){if(!(t instanceof e.ExitStatus))throw t;e.keepRuntimeAlive()||e.__emscripten_thread_exit(t.status)}}}else"cancel"===t.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===t.data.target||("processProxyingQueue"===t.data.cmd?s?e.executeNotifiedProxyingQueue(t.data.queue):n.push(t.data.queue):(i("worker.js received unknown command "+t.data.cmd),i(t.data)))}catch(t){throw i("worker.js onmessage() captured an uncaught exception: "+t),t&&t.stack&&i(t.stack),e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),t}};\\n\'},760:()=>{},384:()=>{},993:()=>{},908:()=>{},953:()=>{},925:()=>{},449:()=>{}},t={};function n(r){var a=t[r];if(void 0!==a)return a.exports;var o=t[r]={exports:{}};return e[r].call(o.exports,o,o.exports,n),o.exports}n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),(()=>{"use strict";const e=n(259),t=n(263);self.onmessage=n=>{switch(n.data.type){case"init-wasm":(0,t.initializeWebAssembly)(n.data.in).then((()=>postMessage({type:"init-wasm"})),(e=>postMessage({type:"init-wasm",err:e})));break;case"init-ort":try{const{numThreads:t,loggingLevel:r}=n.data.in;(0,e.initOrt)(t,r),postMessage({type:"init-ort"})}catch(e){postMessage({type:"init-ort",err:e})}break;case"create_allocate":try{const{model:t}=n.data.in,r=(0,e.createSessionAllocate)(t);postMessage({type:"create_allocate",out:r})}catch(e){postMessage({type:"create_allocate",err:e})}break;case"create_finalize":try{const{modeldata:t,options:r}=n.data.in,a=(0,e.createSessionFinalize)(t,r);postMessage({type:"create_finalize",out:a})}catch(e){postMessage({type:"create_finalize",err:e})}break;case"create":try{const{model:t,options:r}=n.data.in,a=(0,e.createSession)(t,r);postMessage({type:"create",out:a})}catch(e){postMessage({type:"create",err:e})}break;case"release":try{const t=n.data.in;(0,e.releaseSession)(t),postMessage({type:"release"})}catch(e){postMessage({type:"release",err:e})}break;case"run":try{const{sessionId:t,inputIndices:r,inputs:a,outputIndices:o,options:i}=n.data.in;(0,e.run)(t,r,a,o,i).then((t=>{postMessage({type:"run",out:t},(0,e.extractTransferableBuffers)(t))}),(e=>{postMessage({type:"run",err:e})}))}catch(e){postMessage({type:"run",err:e})}break;case"end-profiling":try{const t=n.data.in;(0,e.endProfiling)(t),postMessage({type:"end-profiling"})}catch(e){postMessage({type:"end-profiling",err:e})}}}})()})();\n',"Worker",void 0,void 0)}},6614:er=>{"use strict";er.exports=function(er,en,ei,eo){var ea=self||window;try{try{try{es=new ea.Blob([er])}catch(en){(es=new(ea.BlobBuilder||ea.WebKitBlobBuilder||ea.MozBlobBuilder||ea.MSBlobBuilder)).append(er),es=es.getBlob()}var es,eu=ea.URL||ea.webkitURL,el=eu.createObjectURL(es),ec=new ea[en](el,ei);return eu.revokeObjectURL(el),ec}catch(eo){return new ea[en]("data:application/javascript,".concat(encodeURIComponent(er)),ei)}}catch(er){if(!eo)throw Error("Inline worker is not supported");return new ea[en](eo,ei)}}},3474:(er,en,ei)=>{var eo,ea=(eo=(eo="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(er){function en(){return eR.buffer!=eN&&eK(eR.buffer),eF}function ea(){return eR.buffer!=eN&&eK(eR.buffer),eL}function es(){return eR.buffer!=eN&&eK(eR.buffer),ej}function eu(){return eR.buffer!=eN&&eK(eR.buffer),eU}function el(){return eR.buffer!=eN&&eK(eR.buffer),eB}er=er||{},ec||(ec=void 0!==er?er:{}),ec.ready=new Promise(function(er,en){ep=er,ed=en});var ec,ep,ed,ef,eh,eg,em,eb,ey,ev=Object.assign({},ec),e_="./this.program",ex=(er,en)=>{throw en},ew="object"==typeof window,eT="function"==typeof importScripts,eS="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,eO=ec.ENVIRONMENT_IS_PTHREAD||!1,eA="";function eE(er){return ec.locateFile?ec.locateFile(er,eA):eA+er}if(eS){let er;eA=eT?ei(908).dirname(eA)+"/":"//",ey=()=>{eb||(em=ei(1384),eb=ei(908))},ef=function(er,en){return ey(),er=eb.normalize(er),em.readFileSync(er,en?void 0:"utf8")},eg=er=>((er=ef(er,!0)).buffer||(er=new Uint8Array(er)),er),eh=(er,en,ei)=>{ey(),er=eb.normalize(er),em.readFile(er,function(er,eo){er?ei(er):en(eo.buffer)})},1<process.argv.length&&(e_=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",function(er){if(!(er instanceof e9))throw er}),process.on("unhandledRejection",function(er){throw er}),ex=(er,en)=>{if(eC)throw process.exitCode=er,en;en instanceof e9||ek("exiting due to exception: "+en),process.exit(er)},ec.inspect=function(){return"[Emscripten Module object]"};try{er=ei(9925)}catch(er){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),er}ei.g.Worker=er.Worker}else(ew||eT)&&(eT?eA=self.location.href:"undefined"!=typeof document&&document.currentScript&&(eA=document.currentScript.src),eo&&(eA=eo),eA=0!==eA.indexOf("blob:")?eA.substr(0,eA.replace(/[?#].*/,"").lastIndexOf("/")+1):"",eS||(ef=er=>{var en=new XMLHttpRequest;return en.open("GET",er,!1),en.send(null),en.responseText},eT&&(eg=er=>{var en=new XMLHttpRequest;return en.open("GET",er,!1),en.responseType="arraybuffer",en.send(null),new Uint8Array(en.response)}),eh=(er,en,ei)=>{var eo=new XMLHttpRequest;eo.open("GET",er,!0),eo.responseType="arraybuffer",eo.onload=()=>{200==eo.status||0==eo.status&&eo.response?en(eo.response):ei()},eo.onerror=ei,eo.send(null)}));eS&&"undefined"==typeof performance&&(ei.g.performance=ei(6953).performance);var eI=console.log.bind(console),e$=console.warn.bind(console);eS&&(ey(),eI=er=>em.writeSync(1,er+"\n"),e$=er=>em.writeSync(2,er+"\n"));var eP,eD=ec.print||eI,ek=ec.printErr||e$;Object.assign(ec,ev),ev=null,ec.thisProgram&&(e_=ec.thisProgram),ec.quit&&(ex=ec.quit),ec.wasmBinary&&(eP=ec.wasmBinary);var eC=ec.noExitRuntime||!0;"object"!=typeof WebAssembly&&e6("no native wasm support detected");var eR,eM,eN,eF,eL,ej,eU,eB,eG=!1,eV="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function ez(er,en,ei){var eo=(en>>>=0)+ei;for(ei=en;er[ei]&&!(ei>=eo);)++ei;if(16<ei-en&&er.buffer&&eV)return eV.decode(er.buffer instanceof SharedArrayBuffer?er.slice(en,ei):er.subarray(en,ei));for(eo="";en<ei;){var ea=er[en++];if(128&ea){var es=63&er[en++];if(192==(224&ea))eo+=String.fromCharCode((31&ea)<<6|es);else{var eu=63&er[en++];65536>(ea=224==(240&ea)?(15&ea)<<12|es<<6|eu:(7&ea)<<18|es<<12|eu<<6|63&er[en++])?eo+=String.fromCharCode(ea):(ea-=65536,eo+=String.fromCharCode(55296|ea>>10,56320|1023&ea))}}else eo+=String.fromCharCode(ea)}return eo}function eH(er,en){return(er>>>=0)?ez(ea(),er,en):""}function eW(er,en,ei,eo){if(!(0<eo))return 0;var ea=ei>>>=0;eo=ei+eo-1;for(var es=0;es<er.length;++es){var eu=er.charCodeAt(es);if(55296<=eu&&57343>=eu&&(eu=65536+((1023&eu)<<10)|1023&er.charCodeAt(++es)),127>=eu){if(ei>=eo)break;en[ei++>>>0]=eu}else{if(2047>=eu){if(ei+1>=eo)break;en[ei++>>>0]=192|eu>>6}else{if(65535>=eu){if(ei+2>=eo)break;en[ei++>>>0]=224|eu>>12}else{if(ei+3>=eo)break;en[ei++>>>0]=240|eu>>18,en[ei++>>>0]=128|eu>>12&63}en[ei++>>>0]=128|eu>>6&63}en[ei++>>>0]=128|63&eu}}return en[ei>>>0]=0,ei-ea}function eq(er){for(var en=0,ei=0;ei<er.length;++ei){var eo=er.charCodeAt(ei);127>=eo?en++:2047>=eo?en+=2:55296<=eo&&57343>=eo?(en+=4,++ei):en+=3}return en}function eK(er){eN=er,ec.HEAP8=eF=new Int8Array(er),ec.HEAP16=new Int16Array(er),ec.HEAP32=ej=new Int32Array(er),ec.HEAPU8=eL=new Uint8Array(er),ec.HEAPU16=new Uint16Array(er),ec.HEAPU32=eU=new Uint32Array(er),ec.HEAPF32=new Float32Array(er),ec.HEAPF64=eB=new Float64Array(er)}eO&&(eN=ec.buffer);var eX=ec.INITIAL_MEMORY||16777216;if(eO)eR=ec.wasmMemory,eN=ec.buffer;else if(ec.wasmMemory)eR=ec.wasmMemory;else if(!((eR=new WebAssembly.Memory({initial:eX/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw ek("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),eS&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");eR&&(eN=eR.buffer),eX=eN.byteLength,eK(eN);var eY,eJ=[],eZ=[],eQ=[];function e0(){var er=ec.preRun.shift();eJ.unshift(er)}var e1,e2=0,e3=null,e4=null;function e6(er){throw eO?postMessage({cmd:"onAbort",arg:er}):ec.onAbort&&ec.onAbort(er),ek(er="Aborted("+er+")"),eG=!0,ed(er=new WebAssembly.RuntimeError(er+". Build with -sASSERTIONS for more info.")),er}function e5(){return e1.startsWith("data:application/octet-stream;base64,")}function e8(){var er=e1;try{if(er==e1&&eP)return new Uint8Array(eP);if(eg)return eg(er);throw"both async and sync fetching of the wasm failed"}catch(er){e6(er)}}e1="ort-wasm-threaded.wasm",e5()||(e1=eE(e1));var e7={};function e9(er){this.name="ExitStatus",this.message="Program terminated with exit("+er+")",this.status=er}function tr(er){(er=ta.La[er])||e6(),ta.Xa(er)}function tn(er){var en=ta.lb();if(!en)return 6;ta.Ra.push(en),ta.La[er.Ka]=en,en.Ka=er.Ka;var ei={cmd:"run",start_routine:er.pb,arg:er.ib,pthread_ptr:er.Ka};return en.Qa=()=>{ei.time=performance.now(),en.postMessage(ei,er.vb)},en.loaded&&(en.Qa(),delete en.Qa),0}function ti(er){if(eO)return tR(1,1,er);eC||(ta.qb(),ec.onExit&&ec.onExit(er),eG=!0),ex(er,new e9(er))}function to(er,en){if(!en&&eO)throw tu(er),"unwind";ti(er)}var ta={Oa:[],Ra:[],$a:[],La:{},Ua:function(){eO&&ta.mb()},xb:function(){},mb:function(){ta.receiveObjectTransfer=ta.ob,ta.threadInitTLS=ta.Za,ta.setExitStatus=ta.Ya,eC=!1},Ya:function(){},qb:function(){for(var er of Object.values(ta.La))ta.Xa(er);for(er of ta.Oa)er.terminate();ta.Oa=[]},Xa:function(er){var en=er.Ka;delete ta.La[en],ta.Oa.push(er),ta.Ra.splice(ta.Ra.indexOf(er),1),er.Ka=0,t4(en)},ob:function(){},Za:function(){ta.$a.forEach(er=>er())},nb:function(er,en){er.onmessage=ei=>{var eo=(ei=ei.data).cmd;if(er.Ka&&(ta.kb=er.Ka),ei.targetThread&&ei.targetThread!=tZ()){var ea=ta.La[ei.yb];ea?ea.postMessage(ei,ei.transferList):ek('Internal error! Worker sent a message "'+eo+'" to target pthread '+ei.targetThread+", but that thread no longer exists!")}else"processProxyingQueue"===eo?tI(ei.queue):"spawnThread"===eo?tn(ei):"cleanupThread"===eo?tr(ei.thread):"killThread"===eo?(ei=ei.thread,eo=ta.La[ei],delete ta.La[ei],eo.terminate(),t4(ei),ta.Ra.splice(ta.Ra.indexOf(eo),1),eo.Ka=0):"cancelThread"===eo?ta.La[ei.thread].postMessage({cmd:"cancel"}):"loaded"===eo?(er.loaded=!0,en&&en(er),er.Qa&&(er.Qa(),delete er.Qa)):"print"===eo?eD("Thread "+ei.threadId+": "+ei.text):"printErr"===eo?ek("Thread "+ei.threadId+": "+ei.text):"alert"===eo?alert("Thread "+ei.threadId+": "+ei.text):"setimmediate"===ei.target?er.postMessage(ei):"onAbort"===eo?ec.onAbort&&ec.onAbort(ei.arg):eo&&ek("worker sent an unknown command "+eo);ta.kb=void 0},er.onerror=er=>{throw ek("worker sent an error! "+er.filename+":"+er.lineno+": "+er.message),er},eS&&(er.on("message",function(en){er.onmessage({data:en})}),er.on("error",function(en){er.onerror(en)}),er.on("detachedExit",function(){})),er.postMessage({cmd:"load",urlOrBlob:ec.mainScriptUrlOrBlob||eo,wasmMemory:eR,wasmModule:eM})},hb:function(){var er=eE("ort-wasm-threaded.worker.js");ta.Oa.push(new Worker(er))},lb:function(){return 0==ta.Oa.length&&(ta.hb(),ta.nb(ta.Oa[0])),ta.Oa.pop()}};function ts(er){for(;0<er.length;)er.shift()(ec)}function tu(er){if(eO)return tR(2,0,er);try{to(er)}catch(er){er instanceof e9||"unwind"==er||ex(1,er)}}ec.PThread=ta,ec.establishStackSpace=function(){var er=tZ(),en=es()[er+44>>2>>>0];t5(en,en-(er=es()[er+48>>2>>>0])),t7(en)};var tl,tc,tp=[];function td(er){this.Pa=er-24,this.gb=function(er){eu()[this.Pa+4>>2>>>0]=er},this.cb=function(er){eu()[this.Pa+8>>2>>>0]=er},this.eb=function(){es()[this.Pa>>2>>>0]=0},this.bb=function(){en()[this.Pa+12>>0>>>0]=0},this.fb=function(){en()[this.Pa+13>>0>>>0]=0},this.Ua=function(er,en){this.ab(),this.gb(er),this.cb(en),this.eb(),this.bb(),this.fb()},this.ab=function(){eu()[this.Pa+16>>2>>>0]=0}}function tf(er,en,ei,eo){return eO?tR(3,1,er,en,ei,eo):th(er,en,ei,eo)}function th(er,en,ei,eo){if("undefined"==typeof SharedArrayBuffer)return ek("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var ea=[];return eO&&0===ea.length?tf(er,en,ei,eo):(er={pb:ei,Ka:er,ib:eo,vb:ea},eO?(er.wb="spawnThread",postMessage(er,ea),0):tn(er))}function tg(er,en,ei){return eO?tR(4,1,er,en,ei):0}function tm(er,en){if(eO)return tR(5,1,er,en)}function tb(er,en){if(eO)return tR(6,1,er,en)}function ty(er,en,ei){if(eO)return tR(7,1,er,en,ei)}function tv(er,en,ei){return eO?tR(8,1,er,en,ei):0}function t_(er,en){if(eO)return tR(9,1,er,en)}function tx(er,en,ei){if(eO)return tR(10,1,er,en,ei)}function tw(er,en,ei,eo){if(eO)return tR(11,1,er,en,ei,eo)}function tT(er,en,ei,eo){if(eO)return tR(12,1,er,en,ei,eo)}function tS(er,en,ei,eo){if(eO)return tR(13,1,er,en,ei,eo)}function tO(er){if(eO)return tR(14,1,er)}function tA(er,en){if(eO)return tR(15,1,er,en)}function tE(er,en,ei){if(eO)return tR(16,1,er,en,ei)}function tI(er){Atomics.store(es(),er>>2,1),tZ()&&t3(er),Atomics.compareExchange(es(),er>>2,1,0)}function t$(er){return eu()[er>>>2]+4294967296*es()[er+4>>>2]}function tP(er,en,ei,eo,ea,es){return eO?tR(17,1,er,en,ei,eo,ea,es):-52}function tD(er,en,ei,eo,ea,es){if(eO)return tR(18,1,er,en,ei,eo,ea,es)}function tk(er){var ei=eq(er)+1,eo=tQ(ei);return eo&&eW(er,en(),eo,ei),eo}function tC(er,en,ei){function eo(er){return(er=er.toTimeString().match(/\(([A-Za-z ]+)\)$/))?er[1]:"GMT"}if(eO)return tR(19,1,er,en,ei);var ea=(new Date).getFullYear(),el=new Date(ea,0,1),ec=new Date(ea,6,1);ea=el.getTimezoneOffset();var ep=ec.getTimezoneOffset(),ed=Math.max(ea,ep);es()[er>>2>>>0]=60*ed,es()[en>>2>>>0]=Number(ea!=ep),er=eo(el),en=eo(ec),er=tk(er),en=tk(en),ep<ea?(eu()[ei>>2>>>0]=er,eu()[ei+4>>2>>>0]=en):(eu()[ei>>2>>>0]=en,eu()[ei+4>>2>>>0]=er)}function tR(er,en){var ei=arguments.length-2,eo=arguments;return function(er){var en=t8();return er=er(),t7(en),er}(()=>{for(var ea=t9(8*ei),es=ea>>3,eu=0;eu<ei;eu++){var ec=eo[2+eu];el()[es+eu>>>0]=ec}return t2(er,ei,ea,en)})}ec.invokeEntryPoint=function(er,en){var ei=tp[er];ei||(er>=tp.length&&(tp.length=er+1),tp[er]=ei=eY.get(er)),er=ei(en),eC?ta.Ya(er):t6(er)},ec.executeNotifiedProxyingQueue=tI,tc=eS?()=>{var er=process.hrtime();return 1e3*er[0]+er[1]/1e6}:eO?()=>performance.now()-ec.__performance_now_clock_drift:()=>performance.now();var tM,tN=[],tF={};function tL(){if(!tM){var er,en={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:e_||"./this.program"};for(er in tF)void 0===tF[er]?delete en[er]:en[er]=tF[er];var ei=[];for(er in en)ei.push(er+"="+en[er]);tM=ei}return tM}function tj(er,ei){if(eO)return tR(20,1,er,ei);var eo=0;return tL().forEach(function(ea,es){var el=ei+eo;for(es=eu()[er+4*es>>2>>>0]=el,el=0;el<ea.length;++el)en()[es++>>0>>>0]=ea.charCodeAt(el);en()[es>>0>>>0]=0,eo+=ea.length+1}),0}function tU(er,en){if(eO)return tR(21,1,er,en);var ei=tL();eu()[er>>2>>>0]=ei.length;var eo=0;return ei.forEach(function(er){eo+=er.length+1}),eu()[en>>2>>>0]=eo,0}function tB(er){return eO?tR(22,1,er):52}function tG(er,en,ei,eo){return eO?tR(23,1,er,en,ei,eo):52}function tV(er,en,ei,eo,ea){return eO?tR(24,1,er,en,ei,eo,ea):70}var tz=[null,[],[]];function tH(er,en,ei,eo){if(eO)return tR(25,1,er,en,ei,eo);for(var es=0,el=0;el<ei;el++){var ec=eu()[en>>2>>>0],ep=eu()[en+4>>2>>>0];en+=8;for(var ed=0;ed<ep;ed++){var ef=ea()[ec+ed>>>0],eh=tz[er];0===ef||10===ef?((1===er?eD:ek)(ez(eh,0)),eh.length=0):eh.push(ef)}es+=ep}return eu()[eo>>2>>>0]=es,0}function tW(er){return 0==er%4&&(0!=er%100||0==er%400)}var tq=[31,29,31,30,31,30,31,31,30,31,30,31],tK=[31,28,31,30,31,30,31,31,30,31,30,31];function tX(er,ei,eo,ea){function eu(er,en,ei){for(er="number"==typeof er?er.toString():er||"";er.length<en;)er=ei[0]+er;return er}function el(er,en){return eu(er,en,"0")}function ec(er,en){var ei;function eo(er){return 0>er?-1:0<er?1:0}return 0===(ei=eo(er.getFullYear()-en.getFullYear()))&&0===(ei=eo(er.getMonth()-en.getMonth()))&&(ei=eo(er.getDate()-en.getDate())),ei}function ep(er){switch(er.getDay()){case 0:return new Date(er.getFullYear()-1,11,29);case 1:return er;case 2:return new Date(er.getFullYear(),0,3);case 3:return new Date(er.getFullYear(),0,2);case 4:return new Date(er.getFullYear(),0,1);case 5:return new Date(er.getFullYear()-1,11,31);case 6:return new Date(er.getFullYear()-1,11,30)}}function ed(er){var en=er.Ma;for(er=new Date(new Date(er.Na+1900,0,1).getTime());0<en;){var ei=er.getMonth(),eo=(tW(er.getFullYear())?tq:tK)[ei];if(!(en>eo-er.getDate())){er.setDate(er.getDate()+en);break}en-=eo-er.getDate()+1,er.setDate(1),11>ei?er.setMonth(ei+1):(er.setMonth(0),er.setFullYear(er.getFullYear()+1))}return ei=new Date(er.getFullYear()+1,0,4),en=ep(new Date(er.getFullYear(),0,4)),ei=ep(ei),0>=ec(en,er)?0>=ec(ei,er)?er.getFullYear()+1:er.getFullYear():er.getFullYear()-1}var ef=es()[ea+40>>2>>>0];for(var eh in ea={tb:es()[ea>>2>>>0],sb:es()[ea+4>>2>>>0],Sa:es()[ea+8>>2>>>0],Va:es()[ea+12>>2>>>0],Ta:es()[ea+16>>2>>>0],Na:es()[ea+20>>2>>>0],Ja:es()[ea+24>>2>>>0],Ma:es()[ea+28>>2>>>0],zb:es()[ea+32>>2>>>0],rb:es()[ea+36>>2>>>0],ub:ef?eH(ef):""},eo=eH(eo),ef={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})eo=eo.replace(RegExp(eh,"g"),ef[eh]);var eg="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),em="January February March April May June July August September October November December".split(" ");for(eh in ef={"%a":function(er){return eg[er.Ja].substring(0,3)},"%A":function(er){return eg[er.Ja]},"%b":function(er){return em[er.Ta].substring(0,3)},"%B":function(er){return em[er.Ta]},"%C":function(er){return el((er.Na+1900)/100|0,2)},"%d":function(er){return el(er.Va,2)},"%e":function(er){return eu(er.Va,2," ")},"%g":function(er){return ed(er).toString().substring(2)},"%G":function(er){return ed(er)},"%H":function(er){return el(er.Sa,2)},"%I":function(er){return 0==(er=er.Sa)?er=12:12<er&&(er-=12),el(er,2)},"%j":function(er){for(var en=0,ei=0;ei<=er.Ta-1;en+=(tW(er.Na+1900)?tq:tK)[ei++]);return el(er.Va+en,3)},"%m":function(er){return el(er.Ta+1,2)},"%M":function(er){return el(er.sb,2)},"%n":function(){return"\n"},"%p":function(er){return 0<=er.Sa&&12>er.Sa?"AM":"PM"},"%S":function(er){return el(er.tb,2)},"%t":function(){return"	"},"%u":function(er){return er.Ja||7},"%U":function(er){return el(Math.floor((er.Ma+7-er.Ja)/7),2)},"%V":function(er){var en=Math.floor((er.Ma+7-(er.Ja+6)%7)/7);if(2>=(er.Ja+371-er.Ma-2)%7&&en++,en)53==en&&(4==(ei=(er.Ja+371-er.Ma)%7)||3==ei&&tW(er.Na)||(en=1));else{en=52;var ei=(er.Ja+7-er.Ma-1)%7;(4==ei||5==ei&&tW(er.Na%400-1))&&en++}return el(en,2)},"%w":function(er){return er.Ja},"%W":function(er){return el(Math.floor((er.Ma+7-(er.Ja+6)%7)/7),2)},"%y":function(er){return(er.Na+1900).toString().substring(2)},"%Y":function(er){return er.Na+1900},"%z":function(er){var en=0<=(er=er.rb);return(en?"+":"-")+String("0000"+((er=Math.abs(er)/60)/60*100+er%60)).slice(-4)},"%Z":function(er){return er.ub},"%%":function(){return"%"}},eo=eo.replace(/%%/g,"\x00\x00"),ef)eo.includes(eh)&&(eo=eo.replace(RegExp(eh,"g"),ef[eh](ea)));return(eh=function(er){var en=Array(eq(er)+1);return eW(er,en,0,en.length),en}(eo=eo.replace(/\0\0/g,"%"))).length>ei?0:(function(er,ei){en().set(er,ei>>>0)}(eh,er),eh.length-1)}ta.Ua();var tY=[null,ti,tu,tf,tg,tm,tb,ty,tv,t_,tx,tw,tT,tS,tO,tA,tE,tP,tD,tC,tj,tU,tB,tG,tV,tH],tJ={b:function(er){return tQ(er+24)+24},c:function(er,en,ei){throw new td(er).Ua(en,ei),er},L:function(er){t0(er,!eT,1,!ew),ta.Za()},l:function(er){eO?postMessage({cmd:"cleanupThread",thread:er}):tr(er)},D:th,i:tg,R:tm,z:tb,B:ty,T:tv,P:t_,I:tx,O:tw,p:tT,A:tS,x:tO,Q:tA,y:tE,r:function(){},j:function(){e6("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},s:function(){e6("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},q:function(){return Date.now()},E:function(){return 2097152},V:function(){return!0},F:function(er,en,ei,eo){if(er==en)setTimeout(()=>tI(eo));else if(eO)postMessage({targetThread:er,cmd:"processProxyingQueue",queue:eo});else{if(!(er=ta.La[er]))return;er.postMessage({cmd:"processProxyingQueue",queue:eo})}return 1},K:function(){return -1},W:function(er,en){er=new Date(1e3*t$(er)),es()[en>>2>>>0]=er.getUTCSeconds(),es()[en+4>>2>>>0]=er.getUTCMinutes(),es()[en+8>>2>>>0]=er.getUTCHours(),es()[en+12>>2>>>0]=er.getUTCDate(),es()[en+16>>2>>>0]=er.getUTCMonth(),es()[en+20>>2>>>0]=er.getUTCFullYear()-1900,es()[en+24>>2>>>0]=er.getUTCDay(),er=(er.getTime()-Date.UTC(er.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,es()[en+28>>2>>>0]=er},X:function(er,en){er=new Date(1e3*t$(er)),es()[en>>2>>>0]=er.getSeconds(),es()[en+4>>2>>>0]=er.getMinutes(),es()[en+8>>2>>>0]=er.getHours(),es()[en+12>>2>>>0]=er.getDate(),es()[en+16>>2>>>0]=er.getMonth(),es()[en+20>>2>>>0]=er.getFullYear()-1900,es()[en+24>>2>>>0]=er.getDay();var ei=new Date(er.getFullYear(),0,1),eo=(er.getTime()-ei.getTime())/864e5|0;es()[en+28>>2>>>0]=eo,es()[en+36>>2>>>0]=-60*er.getTimezoneOffset(),er=0|((eo=new Date(er.getFullYear(),6,1).getTimezoneOffset())!=(ei=ei.getTimezoneOffset())&&er.getTimezoneOffset()==Math.min(ei,eo)),es()[en+32>>2>>>0]=er},Y:function(er){var en=new Date(es()[er+20>>2>>>0]+1900,es()[er+16>>2>>>0],es()[er+12>>2>>>0],es()[er+8>>2>>>0],es()[er+4>>2>>>0],es()[er>>2>>>0],0),ei=es()[er+32>>2>>>0],eo=en.getTimezoneOffset(),ea=new Date(en.getFullYear(),0,1),eu=new Date(en.getFullYear(),6,1).getTimezoneOffset(),el=ea.getTimezoneOffset(),ec=Math.min(el,eu);return 0>ei?es()[er+32>>2>>>0]=Number(eu!=el&&ec==eo):0<ei!=(ec==eo)&&(eu=Math.max(el,eu),en.setTime(en.getTime()+6e4*((0<ei?ec:eu)-eo))),es()[er+24>>2>>>0]=en.getDay(),ei=(en.getTime()-ea.getTime())/864e5|0,es()[er+28>>2>>>0]=ei,es()[er>>2>>>0]=en.getSeconds(),es()[er+4>>2>>>0]=en.getMinutes(),es()[er+8>>2>>>0]=en.getHours(),es()[er+12>>2>>>0]=en.getDate(),es()[er+16>>2>>>0]=en.getMonth(),en.getTime()/1e3|0},G:tP,H:tD,Z:function er(en,ei,eo){er.jb||(er.jb=!0,tC(en,ei,eo))},d:function(){e6("")},m:function(){if(!eS&&!eT){var er="Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread";tl||(tl={}),tl[er]||(tl[er]=1,eS&&(er="warning: "+er),ek(er))}},w:function(){return 4294901760},f:tc,S:function(er,en,ei){ea().copyWithin(er>>>0,en>>>0,en+ei>>>0)},g:function(){return eS?ei(3993).cpus().length:navigator.hardwareConcurrency},J:function(er,en,ei){tN.length=en,ei>>=3;for(var eo=0;eo<en;eo++)tN[eo]=el()[ei+eo>>>0];return(0>er?e7[-er-1]:tY[er]).apply(null,tN)},v:function(er){var en=ea().length;if((er>>>=0)<=en||4294901760<er)return!1;for(var ei=1;4>=ei;ei*=2){var eo=en*(1+.2/ei);eo=Math.min(eo,er+100663296);var es=Math;eo=Math.max(er,eo),es=es.min.call(es,4294901760,eo+(65536-eo%65536)%65536);e:{try{eR.grow(es-eN.byteLength+65535>>>16),eK(eR.buffer);var eu=1;break e}catch(er){}eu=void 0}if(eu)return!0}return!1},U:function(){throw"unwind"},M:tj,N:tU,k:to,h:tB,o:tG,t:tV,n:tH,u:function er(eo,ea){er.Wa||(er.Wa=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var er=new Uint8Array(1);return()=>(crypto.getRandomValues(er),er[0])}if(eS)try{var en=ei(760);return()=>en.randomBytes(1)[0]}catch(er){}return()=>e6("randomDevice")}());for(var es=0;es<ea;es++)en()[eo+es>>0>>>0]=er.Wa();return 0},a:eR||ec.wasmMemory,C:tX,e:function(er,en,ei,eo){return tX(er,en,ei,eo)}};(function(){function er(er,en){ec.asm=er.exports,ta.$a.push(ec.asm.wa),eY=ec.asm.za,eZ.unshift(ec.asm._),eM=en,eO||(e2--,ec.monitorRunDependencies&&ec.monitorRunDependencies(e2),0==e2&&(null!==e3&&(clearInterval(e3),e3=null),e4&&(er=e4,e4=null,er())))}function en(en){er(en.instance,en.module)}function ei(er){return(function(){if(!eP&&(ew||eT)){if("function"==typeof fetch&&!e1.startsWith("file://"))return fetch(e1,{credentials:"same-origin"}).then(function(er){if(!er.ok)throw"failed to load wasm binary file at '"+e1+"'";return er.arrayBuffer()}).catch(function(){return e8()});if(eh)return new Promise(function(er,en){eh(e1,function(en){er(new Uint8Array(en))},en)})}return Promise.resolve().then(function(){return e8()})})().then(function(er){return WebAssembly.instantiate(er,eo)}).then(function(er){return er}).then(er,function(er){ek("failed to asynchronously prepare wasm: "+er),e6(er)})}var eo={a:tJ};if(eO||(e2++,ec.monitorRunDependencies&&ec.monitorRunDependencies(e2)),ec.instantiateWasm)try{return ec.instantiateWasm(eo,er)}catch(er){return ek("Module.instantiateWasm callback failed with error: "+er),!1}(eP||"function"!=typeof WebAssembly.instantiateStreaming||e5()||e1.startsWith("file://")||eS||"function"!=typeof fetch?ei(en):fetch(e1,{credentials:"same-origin"}).then(function(er){return WebAssembly.instantiateStreaming(er,eo).then(en,function(er){return ek("wasm streaming compile failed: "+er),ek("falling back to ArrayBuffer instantiation"),ei(en)})})).catch(ed)})(),ec.___wasm_call_ctors=function(){return(ec.___wasm_call_ctors=ec.asm._).apply(null,arguments)},ec._OrtInit=function(){return(ec._OrtInit=ec.asm.$).apply(null,arguments)},ec._OrtCreateSessionOptions=function(){return(ec._OrtCreateSessionOptions=ec.asm.aa).apply(null,arguments)},ec._OrtAppendExecutionProvider=function(){return(ec._OrtAppendExecutionProvider=ec.asm.ba).apply(null,arguments)},ec._OrtAddSessionConfigEntry=function(){return(ec._OrtAddSessionConfigEntry=ec.asm.ca).apply(null,arguments)},ec._OrtReleaseSessionOptions=function(){return(ec._OrtReleaseSessionOptions=ec.asm.da).apply(null,arguments)},ec._OrtCreateSession=function(){return(ec._OrtCreateSession=ec.asm.ea).apply(null,arguments)},ec._OrtReleaseSession=function(){return(ec._OrtReleaseSession=ec.asm.fa).apply(null,arguments)},ec._OrtGetInputCount=function(){return(ec._OrtGetInputCount=ec.asm.ga).apply(null,arguments)},ec._OrtGetOutputCount=function(){return(ec._OrtGetOutputCount=ec.asm.ha).apply(null,arguments)},ec._OrtGetInputName=function(){return(ec._OrtGetInputName=ec.asm.ia).apply(null,arguments)},ec._OrtGetOutputName=function(){return(ec._OrtGetOutputName=ec.asm.ja).apply(null,arguments)},ec._OrtFree=function(){return(ec._OrtFree=ec.asm.ka).apply(null,arguments)},ec._OrtCreateTensor=function(){return(ec._OrtCreateTensor=ec.asm.la).apply(null,arguments)},ec._OrtGetTensorData=function(){return(ec._OrtGetTensorData=ec.asm.ma).apply(null,arguments)},ec._OrtReleaseTensor=function(){return(ec._OrtReleaseTensor=ec.asm.na).apply(null,arguments)},ec._OrtCreateRunOptions=function(){return(ec._OrtCreateRunOptions=ec.asm.oa).apply(null,arguments)},ec._OrtAddRunConfigEntry=function(){return(ec._OrtAddRunConfigEntry=ec.asm.pa).apply(null,arguments)},ec._OrtReleaseRunOptions=function(){return(ec._OrtReleaseRunOptions=ec.asm.qa).apply(null,arguments)},ec._OrtRun=function(){return(ec._OrtRun=ec.asm.ra).apply(null,arguments)},ec._OrtEndProfiling=function(){return(ec._OrtEndProfiling=ec.asm.sa).apply(null,arguments)};var tZ=ec._pthread_self=function(){return(tZ=ec._pthread_self=ec.asm.ta).apply(null,arguments)},tQ=ec._malloc=function(){return(tQ=ec._malloc=ec.asm.ua).apply(null,arguments)};ec._free=function(){return(ec._free=ec.asm.va).apply(null,arguments)},ec.__emscripten_tls_init=function(){return(ec.__emscripten_tls_init=ec.asm.wa).apply(null,arguments)};var t0=ec.__emscripten_thread_init=function(){return(t0=ec.__emscripten_thread_init=ec.asm.xa).apply(null,arguments)};ec.__emscripten_thread_crashed=function(){return(ec.__emscripten_thread_crashed=ec.asm.ya).apply(null,arguments)};var t1,t2=ec._emscripten_run_in_main_runtime_thread_js=function(){return(t2=ec._emscripten_run_in_main_runtime_thread_js=ec.asm.Aa).apply(null,arguments)},t3=ec.__emscripten_proxy_execute_task_queue=function(){return(t3=ec.__emscripten_proxy_execute_task_queue=ec.asm.Ba).apply(null,arguments)},t4=ec.__emscripten_thread_free_data=function(){return(t4=ec.__emscripten_thread_free_data=ec.asm.Ca).apply(null,arguments)},t6=ec.__emscripten_thread_exit=function(){return(t6=ec.__emscripten_thread_exit=ec.asm.Da).apply(null,arguments)},t5=ec._emscripten_stack_set_limits=function(){return(t5=ec._emscripten_stack_set_limits=ec.asm.Ea).apply(null,arguments)},t8=ec.stackSave=function(){return(t8=ec.stackSave=ec.asm.Fa).apply(null,arguments)},t7=ec.stackRestore=function(){return(t7=ec.stackRestore=ec.asm.Ga).apply(null,arguments)},t9=ec.stackAlloc=function(){return(t9=ec.stackAlloc=ec.asm.Ha).apply(null,arguments)};function rr(){function er(){if(!t1&&(t1=!0,ec.calledRun=!0,!eG)&&(eO||ts(eZ),ep(ec),ec.onRuntimeInitialized&&ec.onRuntimeInitialized(),!eO)){if(ec.postRun)for("function"==typeof ec.postRun&&(ec.postRun=[ec.postRun]);ec.postRun.length;){var er=ec.postRun.shift();eQ.unshift(er)}ts(eQ)}}if(!(0<e2)){if(eO)ep(ec),eO||ts(eZ),postMessage({cmd:"loaded"});else{if(ec.preRun)for("function"==typeof ec.preRun&&(ec.preRun=[ec.preRun]);ec.preRun.length;)e0();ts(eJ),0<e2||(ec.setStatus?(ec.setStatus("Running..."),setTimeout(function(){setTimeout(function(){ec.setStatus("")},1),er()},1)):er())}}}if(ec.___cxa_is_pointer_type=function(){return(ec.___cxa_is_pointer_type=ec.asm.Ia).apply(null,arguments)},ec.UTF8ToString=eH,ec.stringToUTF8=function(er,en,ei){return eW(er,ea(),en,ei)},ec.lengthBytesUTF8=eq,ec.keepRuntimeAlive=function(){return eC},ec.wasmMemory=eR,ec.stackSave=t8,ec.stackRestore=t7,ec.stackAlloc=t9,ec.ExitStatus=e9,ec.PThread=ta,e4=function er(){t1||rr(),t1||(e4=er)},ec.preInit)for("function"==typeof ec.preInit&&(ec.preInit=[ec.preInit]);0<ec.preInit.length;)ec.preInit.pop()();return rr(),er.ready});er.exports=ea},932:(er,en,ei)=>{var eo,ea=(eo=(eo="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(er){er=er||{},en||(en=void 0!==er?er:{}),en.ready=new Promise(function(er,en){ea=er,es=en});var en,ea,es,eu,el,ec,ep,ed,ef,eh=Object.assign({},en),eg="./this.program",em=(er,en)=>{throw en},eb="object"==typeof window,ey="function"==typeof importScripts,ev="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,e_="";ev?(e_=ey?ei(908).dirname(e_)+"/":"//",ef=()=>{ed||(ep=ei(1384),ed=ei(908))},eu=function(er,en){return ef(),er=ed.normalize(er),ep.readFileSync(er,en?void 0:"utf8")},ec=er=>((er=eu(er,!0)).buffer||(er=new Uint8Array(er)),er),el=(er,en,ei)=>{ef(),er=ed.normalize(er),ep.readFile(er,function(er,eo){er?ei(er):en(eo.buffer)})},1<process.argv.length&&(eg=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",function(er){if(!(er instanceof eY))throw er}),process.on("unhandledRejection",function(er){throw er}),em=(er,en)=>{if(eS)throw process.exitCode=er,en;en instanceof eY||eT("exiting due to exception: "+en),process.exit(er)},en.inspect=function(){return"[Emscripten Module object]"}):(eb||ey)&&(ey?e_=self.location.href:"undefined"!=typeof document&&document.currentScript&&(e_=document.currentScript.src),eo&&(e_=eo),e_=0!==e_.indexOf("blob:")?e_.substr(0,e_.replace(/[?#].*/,"").lastIndexOf("/")+1):"",eu=er=>{var en=new XMLHttpRequest;return en.open("GET",er,!1),en.send(null),en.responseText},ey&&(ec=er=>{var en=new XMLHttpRequest;return en.open("GET",er,!1),en.responseType="arraybuffer",en.send(null),new Uint8Array(en.response)}),el=(er,en,ei)=>{var eo=new XMLHttpRequest;eo.open("GET",er,!0),eo.responseType="arraybuffer",eo.onload=()=>{200==eo.status||0==eo.status&&eo.response?en(eo.response):ei()},eo.onerror=ei,eo.send(null)});var ex,ew=en.print||console.log.bind(console),eT=en.printErr||console.warn.bind(console);Object.assign(en,eh),eh=null,en.thisProgram&&(eg=en.thisProgram),en.quit&&(em=en.quit),en.wasmBinary&&(ex=en.wasmBinary);var eS=en.noExitRuntime||!0;"object"!=typeof WebAssembly&&eW("no native wasm support detected");var eO,eA,eE,eI,e$,eP,eD=!1,ek="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function eC(er,en,ei){var eo=(en>>>=0)+ei;for(ei=en;er[ei]&&!(ei>=eo);)++ei;if(16<ei-en&&er.buffer&&ek)return ek.decode(er.subarray(en,ei));for(eo="";en<ei;){var ea=er[en++];if(128&ea){var es=63&er[en++];if(192==(224&ea))eo+=String.fromCharCode((31&ea)<<6|es);else{var eu=63&er[en++];65536>(ea=224==(240&ea)?(15&ea)<<12|es<<6|eu:(7&ea)<<18|es<<12|eu<<6|63&er[en++])?eo+=String.fromCharCode(ea):(ea-=65536,eo+=String.fromCharCode(55296|ea>>10,56320|1023&ea))}}else eo+=String.fromCharCode(ea)}return eo}function eR(er,en){return(er>>>=0)?eC(eI,er,en):""}function eM(er,en,ei,eo){if(!(0<eo))return 0;var ea=ei>>>=0;eo=ei+eo-1;for(var es=0;es<er.length;++es){var eu=er.charCodeAt(es);if(55296<=eu&&57343>=eu&&(eu=65536+((1023&eu)<<10)|1023&er.charCodeAt(++es)),127>=eu){if(ei>=eo)break;en[ei++>>>0]=eu}else{if(2047>=eu){if(ei+1>=eo)break;en[ei++>>>0]=192|eu>>6}else{if(65535>=eu){if(ei+2>=eo)break;en[ei++>>>0]=224|eu>>12}else{if(ei+3>=eo)break;en[ei++>>>0]=240|eu>>18,en[ei++>>>0]=128|eu>>12&63}en[ei++>>>0]=128|eu>>6&63}en[ei++>>>0]=128|63&eu}}return en[ei>>>0]=0,ei-ea}function eN(er){for(var en=0,ei=0;ei<er.length;++ei){var eo=er.charCodeAt(ei);127>=eo?en++:2047>=eo?en+=2:55296<=eo&&57343>=eo?(en+=4,++ei):en+=3}return en}function eF(){var er=eO.buffer;eA=er,en.HEAP8=eE=new Int8Array(er),en.HEAP16=new Int16Array(er),en.HEAP32=e$=new Int32Array(er),en.HEAPU8=eI=new Uint8Array(er),en.HEAPU16=new Uint16Array(er),en.HEAPU32=eP=new Uint32Array(er),en.HEAPF32=new Float32Array(er),en.HEAPF64=new Float64Array(er)}var eL=[],ej=[],eU=[];function eB(){var er=en.preRun.shift();eL.unshift(er)}var eG,eV=0,ez=null,eH=null;function eW(er){throw en.onAbort&&en.onAbort(er),eT(er="Aborted("+er+")"),eD=!0,es(er=new WebAssembly.RuntimeError(er+". Build with -sASSERTIONS for more info.")),er}function eq(){return eG.startsWith("data:application/octet-stream;base64,")}if(eG="ort-wasm.wasm",!eq()){var eK=eG;eG=en.locateFile?en.locateFile(eK,e_):e_+eK}function eX(){var er=eG;try{if(er==eG&&ex)return new Uint8Array(ex);if(ec)return ec(er);throw"both async and sync fetching of the wasm failed"}catch(er){eW(er)}}function eY(er){this.name="ExitStatus",this.message="Program terminated with exit("+er+")",this.status=er}function eJ(er){for(;0<er.length;)er.shift()(en)}function eZ(er){this.sa=er-24,this.Ia=function(er){eP[this.sa+4>>2>>>0]=er},this.Ba=function(er){eP[this.sa+8>>2>>>0]=er},this.Ga=function(){e$[this.sa>>2>>>0]=0},this.Aa=function(){eE[this.sa+12>>0>>>0]=0},this.Ha=function(){eE[this.sa+13>>0>>>0]=0},this.ya=function(er,en){this.za(),this.Ia(er),this.Ba(en),this.Ga(),this.Aa(),this.Ha()},this.za=function(){eP[this.sa+16>>2>>>0]=0}}function eQ(er){var en=eN(er)+1,ei=e9(en);return ei&&eM(er,eE,ei,en),ei}var e0={};function e1(){if(!e2){var er,en={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:eg||"./this.program"};for(er in e0)void 0===e0[er]?delete en[er]:en[er]=e0[er];var ei=[];for(er in en)ei.push(er+"="+en[er]);e2=ei}return e2}var e2,e3=[null,[],[]];function e4(er){return 0==er%4&&(0!=er%100||0==er%400)}var e6=[31,29,31,30,31,30,31,31,30,31,30,31],e5=[31,28,31,30,31,30,31,31,30,31,30,31];function e8(er,en,ei,eo){function ea(er,en,ei){for(er="number"==typeof er?er.toString():er||"";er.length<en;)er=ei[0]+er;return er}function es(er,en){return ea(er,en,"0")}function eu(er,en){var ei;function eo(er){return 0>er?-1:0<er?1:0}return 0===(ei=eo(er.getFullYear()-en.getFullYear()))&&0===(ei=eo(er.getMonth()-en.getMonth()))&&(ei=eo(er.getDate()-en.getDate())),ei}function el(er){switch(er.getDay()){case 0:return new Date(er.getFullYear()-1,11,29);case 1:return er;case 2:return new Date(er.getFullYear(),0,3);case 3:return new Date(er.getFullYear(),0,2);case 4:return new Date(er.getFullYear(),0,1);case 5:return new Date(er.getFullYear()-1,11,31);case 6:return new Date(er.getFullYear()-1,11,30)}}function ec(er){var en=er.qa;for(er=new Date(new Date(er.ra+1900,0,1).getTime());0<en;){var ei=er.getMonth(),eo=(e4(er.getFullYear())?e6:e5)[ei];if(!(en>eo-er.getDate())){er.setDate(er.getDate()+en);break}en-=eo-er.getDate()+1,er.setDate(1),11>ei?er.setMonth(ei+1):(er.setMonth(0),er.setFullYear(er.getFullYear()+1))}return ei=new Date(er.getFullYear()+1,0,4),en=el(new Date(er.getFullYear(),0,4)),ei=el(ei),0>=eu(en,er)?0>=eu(ei,er)?er.getFullYear()+1:er.getFullYear():er.getFullYear()-1}var ep=e$[eo+40>>2>>>0];for(var ed in eo={Ea:e$[eo>>2>>>0],Da:e$[eo+4>>2>>>0],ta:e$[eo+8>>2>>>0],va:e$[eo+12>>2>>>0],ua:e$[eo+16>>2>>>0],ra:e$[eo+20>>2>>>0],la:e$[eo+24>>2>>>0],qa:e$[eo+28>>2>>>0],Ja:e$[eo+32>>2>>>0],Ca:e$[eo+36>>2>>>0],Fa:ep?eR(ep):""},ei=eR(ei),ep={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})ei=ei.replace(RegExp(ed,"g"),ep[ed]);var ef="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),eh="January February March April May June July August September October November December".split(" ");for(ed in ep={"%a":function(er){return ef[er.la].substring(0,3)},"%A":function(er){return ef[er.la]},"%b":function(er){return eh[er.ua].substring(0,3)},"%B":function(er){return eh[er.ua]},"%C":function(er){return es((er.ra+1900)/100|0,2)},"%d":function(er){return es(er.va,2)},"%e":function(er){return ea(er.va,2," ")},"%g":function(er){return ec(er).toString().substring(2)},"%G":function(er){return ec(er)},"%H":function(er){return es(er.ta,2)},"%I":function(er){return 0==(er=er.ta)?er=12:12<er&&(er-=12),es(er,2)},"%j":function(er){for(var en=0,ei=0;ei<=er.ua-1;en+=(e4(er.ra+1900)?e6:e5)[ei++]);return es(er.va+en,3)},"%m":function(er){return es(er.ua+1,2)},"%M":function(er){return es(er.Da,2)},"%n":function(){return"\n"},"%p":function(er){return 0<=er.ta&&12>er.ta?"AM":"PM"},"%S":function(er){return es(er.Ea,2)},"%t":function(){return"	"},"%u":function(er){return er.la||7},"%U":function(er){return es(Math.floor((er.qa+7-er.la)/7),2)},"%V":function(er){var en=Math.floor((er.qa+7-(er.la+6)%7)/7);if(2>=(er.la+371-er.qa-2)%7&&en++,en)53==en&&(4==(ei=(er.la+371-er.qa)%7)||3==ei&&e4(er.ra)||(en=1));else{en=52;var ei=(er.la+7-er.qa-1)%7;(4==ei||5==ei&&e4(er.ra%400-1))&&en++}return es(en,2)},"%w":function(er){return er.la},"%W":function(er){return es(Math.floor((er.qa+7-(er.la+6)%7)/7),2)},"%y":function(er){return(er.ra+1900).toString().substring(2)},"%Y":function(er){return er.ra+1900},"%z":function(er){var en=0<=(er=er.Ca);return(en?"+":"-")+String("0000"+((er=Math.abs(er)/60)/60*100+er%60)).slice(-4)},"%Z":function(er){return er.Fa},"%%":function(){return"%"}},ei=ei.replace(/%%/g,"\x00\x00"),ep)ei.includes(ed)&&(ei=ei.replace(RegExp(ed,"g"),ep[ed](eo)));return(ed=function(er){var en=Array(eN(er)+1);return eM(er,en,0,en.length),en}(ei=ei.replace(/\0\0/g,"%"))).length>en?0:(eE.set(ed,er>>>0),ed.length-1)}var e7={a:function(er){return e9(er+24)+24},b:function(er,en,ei){throw new eZ(er).ya(en,ei),er},g:function(){return 0},I:function(){},w:function(){},y:function(){},K:function(){return 0},G:function(){},C:function(){},F:function(){},k:function(){},x:function(){},u:function(){},H:function(){},v:function(){},n:function(){},p:function(){eW("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},o:function(){eW("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},l:function(){return Date.now()},L:function(){return!0},M:function(er,en){er=new Date(1e3*(eP[er>>>2]+4294967296*e$[er+4>>>2])),e$[en>>2>>>0]=er.getUTCSeconds(),e$[en+4>>2>>>0]=er.getUTCMinutes(),e$[en+8>>2>>>0]=er.getUTCHours(),e$[en+12>>2>>>0]=er.getUTCDate(),e$[en+16>>2>>>0]=er.getUTCMonth(),e$[en+20>>2>>>0]=er.getUTCFullYear()-1900,e$[en+24>>2>>>0]=er.getUTCDay(),e$[en+28>>2>>>0]=(er.getTime()-Date.UTC(er.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},N:function(er,en){er=new Date(1e3*(eP[er>>>2]+4294967296*e$[er+4>>>2])),e$[en>>2>>>0]=er.getSeconds(),e$[en+4>>2>>>0]=er.getMinutes(),e$[en+8>>2>>>0]=er.getHours(),e$[en+12>>2>>>0]=er.getDate(),e$[en+16>>2>>>0]=er.getMonth(),e$[en+20>>2>>>0]=er.getFullYear()-1900,e$[en+24>>2>>>0]=er.getDay();var ei=new Date(er.getFullYear(),0,1);e$[en+28>>2>>>0]=(er.getTime()-ei.getTime())/864e5|0,e$[en+36>>2>>>0]=-60*er.getTimezoneOffset();var eo=new Date(er.getFullYear(),6,1).getTimezoneOffset();ei=ei.getTimezoneOffset(),e$[en+32>>2>>>0]=0|(eo!=ei&&er.getTimezoneOffset()==Math.min(ei,eo))},O:function(er){var en=new Date(e$[er+20>>2>>>0]+1900,e$[er+16>>2>>>0],e$[er+12>>2>>>0],e$[er+8>>2>>>0],e$[er+4>>2>>>0],e$[er>>2>>>0],0),ei=e$[er+32>>2>>>0],eo=en.getTimezoneOffset(),ea=new Date(en.getFullYear(),0,1),es=new Date(en.getFullYear(),6,1).getTimezoneOffset(),eu=ea.getTimezoneOffset(),el=Math.min(eu,es);return 0>ei?e$[er+32>>2>>>0]=Number(es!=eu&&el==eo):0<ei!=(el==eo)&&(es=Math.max(eu,es),en.setTime(en.getTime()+6e4*((0<ei?el:es)-eo))),e$[er+24>>2>>>0]=en.getDay(),e$[er+28>>2>>>0]=(en.getTime()-ea.getTime())/864e5|0,e$[er>>2>>>0]=en.getSeconds(),e$[er+4>>2>>>0]=en.getMinutes(),e$[er+8>>2>>>0]=en.getHours(),e$[er+12>>2>>>0]=en.getDate(),e$[er+16>>2>>>0]=en.getMonth(),en.getTime()/1e3|0},z:function(){return -52},B:function(){},m:function er(en,ei,eo){er.xa||(er.xa=!0,function(er,en,ei){function eo(er){return(er=er.toTimeString().match(/\(([A-Za-z ]+)\)$/))?er[1]:"GMT"}var ea=(new Date).getFullYear(),es=new Date(ea,0,1),eu=new Date(ea,6,1);ea=es.getTimezoneOffset();var el=eu.getTimezoneOffset();e$[er>>2>>>0]=60*Math.max(ea,el),e$[en>>2>>>0]=Number(ea!=el),er=eo(es),en=eo(eu),er=eQ(er),en=eQ(en),el<ea?(eP[ei>>2>>>0]=er,eP[ei+4>>2>>>0]=en):(eP[ei>>2>>>0]=en,eP[ei+4>>2>>>0]=er)}(en,ei,eo))},d:function(){eW("")},t:function(){return 4294901760},h:ev?()=>{var er=process.hrtime();return 1e3*er[0]+er[1]/1e6}:()=>performance.now(),J:function(er,en,ei){eI.copyWithin(er>>>0,en>>>0,en+ei>>>0)},f:function(er){var en=eI.length;if(4294901760<(er>>>=0))return!1;for(var ei=1;4>=ei;ei*=2){var eo=en*(1+.2/ei);eo=Math.min(eo,er+100663296);var ea=Math;eo=Math.max(er,eo),ea=ea.min.call(ea,4294901760,eo+(65536-eo%65536)%65536);e:{try{eO.grow(ea-eA.byteLength+65535>>>16),eF();var es=1;break e}catch(er){}es=void 0}if(es)return!0}return!1},D:function(er,en){var ei=0;return e1().forEach(function(eo,ea){var es=en+ei;for(ea=eP[er+4*ea>>2>>>0]=es,es=0;es<eo.length;++es)eE[ea++>>0>>>0]=eo.charCodeAt(es);eE[ea>>0>>>0]=0,ei+=eo.length+1}),0},E:function(er,en){var ei=e1();eP[er>>2>>>0]=ei.length;var eo=0;return ei.forEach(function(er){eo+=er.length+1}),eP[en>>2>>>0]=eo,0},r:function(er){eS||(en.onExit&&en.onExit(er),eD=!0),em(er,new eY(er))},e:function(){return 52},j:function(){return 52},q:function(){return 70},i:function(er,en,ei,eo){for(var ea=0,es=0;es<ei;es++){var eu=eP[en>>2>>>0],el=eP[en+4>>2>>>0];en+=8;for(var ec=0;ec<el;ec++){var ep=eI[eu+ec>>>0],ed=e3[er];0===ep||10===ep?((1===er?ew:eT)(eC(ed,0)),ed.length=0):ed.push(ep)}ea+=el}return eP[eo>>2>>>0]=ea,0},s:function er(en,eo){er.wa||(er.wa=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var er=new Uint8Array(1);return()=>(crypto.getRandomValues(er),er[0])}if(ev)try{var en=ei(760);return()=>en.randomBytes(1)[0]}catch(er){}return()=>eW("randomDevice")}());for(var ea=0;ea<eo;ea++)eE[en+ea>>0>>>0]=er.wa();return 0},A:e8,c:function(er,en,ei,eo){return e8(er,en,ei,eo)}};(function(){function er(er){en.asm=er.exports,eO=en.asm.P,eF(),ej.unshift(en.asm.Q),eV--,en.monitorRunDependencies&&en.monitorRunDependencies(eV),0==eV&&(null!==ez&&(clearInterval(ez),ez=null),eH&&(er=eH,eH=null,er()))}function ei(en){er(en.instance)}function eo(er){return(function(){if(!ex&&(eb||ey)){if("function"==typeof fetch&&!eG.startsWith("file://"))return fetch(eG,{credentials:"same-origin"}).then(function(er){if(!er.ok)throw"failed to load wasm binary file at '"+eG+"'";return er.arrayBuffer()}).catch(function(){return eX()});if(el)return new Promise(function(er,en){el(eG,function(en){er(new Uint8Array(en))},en)})}return Promise.resolve().then(function(){return eX()})})().then(function(er){return WebAssembly.instantiate(er,ea)}).then(function(er){return er}).then(er,function(er){eT("failed to asynchronously prepare wasm: "+er),eW(er)})}var ea={a:e7};if(eV++,en.monitorRunDependencies&&en.monitorRunDependencies(eV),en.instantiateWasm)try{return en.instantiateWasm(ea,er)}catch(er){return eT("Module.instantiateWasm callback failed with error: "+er),!1}(ex||"function"!=typeof WebAssembly.instantiateStreaming||eq()||eG.startsWith("file://")||ev||"function"!=typeof fetch?eo(ei):fetch(eG,{credentials:"same-origin"}).then(function(er){return WebAssembly.instantiateStreaming(er,ea).then(ei,function(er){return eT("wasm streaming compile failed: "+er),eT("falling back to ArrayBuffer instantiation"),eo(ei)})})).catch(es)})(),en.___wasm_call_ctors=function(){return(en.___wasm_call_ctors=en.asm.Q).apply(null,arguments)},en._OrtInit=function(){return(en._OrtInit=en.asm.R).apply(null,arguments)},en._OrtCreateSessionOptions=function(){return(en._OrtCreateSessionOptions=en.asm.S).apply(null,arguments)},en._OrtAppendExecutionProvider=function(){return(en._OrtAppendExecutionProvider=en.asm.T).apply(null,arguments)},en._OrtAddSessionConfigEntry=function(){return(en._OrtAddSessionConfigEntry=en.asm.U).apply(null,arguments)},en._OrtReleaseSessionOptions=function(){return(en._OrtReleaseSessionOptions=en.asm.V).apply(null,arguments)},en._OrtCreateSession=function(){return(en._OrtCreateSession=en.asm.W).apply(null,arguments)},en._OrtReleaseSession=function(){return(en._OrtReleaseSession=en.asm.X).apply(null,arguments)},en._OrtGetInputCount=function(){return(en._OrtGetInputCount=en.asm.Y).apply(null,arguments)},en._OrtGetOutputCount=function(){return(en._OrtGetOutputCount=en.asm.Z).apply(null,arguments)},en._OrtGetInputName=function(){return(en._OrtGetInputName=en.asm._).apply(null,arguments)},en._OrtGetOutputName=function(){return(en._OrtGetOutputName=en.asm.$).apply(null,arguments)},en._OrtFree=function(){return(en._OrtFree=en.asm.aa).apply(null,arguments)},en._OrtCreateTensor=function(){return(en._OrtCreateTensor=en.asm.ba).apply(null,arguments)},en._OrtGetTensorData=function(){return(en._OrtGetTensorData=en.asm.ca).apply(null,arguments)},en._OrtReleaseTensor=function(){return(en._OrtReleaseTensor=en.asm.da).apply(null,arguments)},en._OrtCreateRunOptions=function(){return(en._OrtCreateRunOptions=en.asm.ea).apply(null,arguments)},en._OrtAddRunConfigEntry=function(){return(en._OrtAddRunConfigEntry=en.asm.fa).apply(null,arguments)},en._OrtReleaseRunOptions=function(){return(en._OrtReleaseRunOptions=en.asm.ga).apply(null,arguments)},en._OrtRun=function(){return(en._OrtRun=en.asm.ha).apply(null,arguments)},en._OrtEndProfiling=function(){return(en._OrtEndProfiling=en.asm.ia).apply(null,arguments)};var e9=en._malloc=function(){return(e9=en._malloc=en.asm.ja).apply(null,arguments)};en._free=function(){return(en._free=en.asm.ka).apply(null,arguments)};var tr,tn=en.stackSave=function(){return(tn=en.stackSave=en.asm.ma).apply(null,arguments)},ti=en.stackRestore=function(){return(ti=en.stackRestore=en.asm.na).apply(null,arguments)},to=en.stackAlloc=function(){return(to=en.stackAlloc=en.asm.oa).apply(null,arguments)};function ta(){function er(){if(!tr&&(tr=!0,en.calledRun=!0,!eD)){if(eJ(ej),ea(en),en.onRuntimeInitialized&&en.onRuntimeInitialized(),en.postRun)for("function"==typeof en.postRun&&(en.postRun=[en.postRun]);en.postRun.length;){var er=en.postRun.shift();eU.unshift(er)}eJ(eU)}}if(!(0<eV)){if(en.preRun)for("function"==typeof en.preRun&&(en.preRun=[en.preRun]);en.preRun.length;)eB();eJ(eL),0<eV||(en.setStatus?(en.setStatus("Running..."),setTimeout(function(){setTimeout(function(){en.setStatus("")},1),er()},1)):er())}}if(en.___cxa_is_pointer_type=function(){return(en.___cxa_is_pointer_type=en.asm.pa).apply(null,arguments)},en.UTF8ToString=eR,en.stringToUTF8=function(er,en,ei){return eM(er,eI,en,ei)},en.lengthBytesUTF8=eN,en.stackSave=tn,en.stackRestore=ti,en.stackAlloc=to,eH=function er(){tr||ta(),tr||(eH=er)},en.preInit)for("function"==typeof en.preInit&&(en.preInit=[en.preInit]);0<en.preInit.length;)en.preInit.pop()();return ta(),er.ready});er.exports=ea},4537:er=>{"use strict";er.exports=function(er,en){for(var ei=Array(arguments.length-1),eo=0,ea=2,es=!0;ea<arguments.length;)ei[eo++]=arguments[ea++];return new Promise(function(ea,eu){ei[eo]=function(er){if(es){if(es=!1,er)eu(er);else{for(var en=Array(arguments.length-1),ei=0;ei<en.length;)en[ei++]=arguments[ei];ea.apply(null,en)}}};try{er.apply(en||null,ei)}catch(er){es&&(es=!1,eu(er))}})}},7419:(er,en)=>{"use strict";var ei=en;ei.length=function(er){var en=er.length;if(!en)return 0;for(var ei=0;--en%4>1&&"="===er.charAt(en);)++ei;return Math.ceil(3*er.length)/4-ei};for(var eo=Array(64),ea=Array(123),es=0;es<64;)ea[eo[es]=es<26?es+65:es<52?es+71:es<62?es-4:es-59|43]=es++;ei.encode=function(er,en,ei){for(var ea,es=null,eu=[],el=0,ec=0;en<ei;){var ep=er[en++];switch(ec){case 0:eu[el++]=eo[ep>>2],ea=(3&ep)<<4,ec=1;break;case 1:eu[el++]=eo[ea|ep>>4],ea=(15&ep)<<2,ec=2;break;case 2:eu[el++]=eo[ea|ep>>6],eu[el++]=eo[63&ep],ec=0}el>8191&&((es||(es=[])).push(String.fromCharCode.apply(String,eu)),el=0)}return ec&&(eu[el++]=eo[ea],eu[el++]=61,1===ec&&(eu[el++]=61)),es?(el&&es.push(String.fromCharCode.apply(String,eu.slice(0,el))),es.join("")):String.fromCharCode.apply(String,eu.slice(0,el))};var eu="invalid encoding";ei.decode=function(er,en,ei){for(var eo,es=ei,el=0,ec=0;ec<er.length;){var ep=er.charCodeAt(ec++);if(61===ep&&el>1)break;if(void 0===(ep=ea[ep]))throw Error(eu);switch(el){case 0:eo=ep,el=1;break;case 1:en[ei++]=eo<<2|(48&ep)>>4,eo=ep,el=2;break;case 2:en[ei++]=(15&eo)<<4|(60&ep)>>2,eo=ep,el=3;break;case 3:en[ei++]=(3&eo)<<6|ep,el=0}}if(1===el)throw Error(eu);return ei-es},ei.test=function(er){return/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(er)}},9211:er=>{"use strict";function en(){this._listeners={}}er.exports=en,en.prototype.on=function(er,en,ei){return(this._listeners[er]||(this._listeners[er]=[])).push({fn:en,ctx:ei||this}),this},en.prototype.off=function(er,en){if(void 0===er)this._listeners={};else if(void 0===en)this._listeners[er]=[];else for(var ei=this._listeners[er],eo=0;eo<ei.length;)ei[eo].fn===en?ei.splice(eo,1):++eo;return this},en.prototype.emit=function(er){var en=this._listeners[er];if(en){for(var ei=[],eo=1;eo<arguments.length;)ei.push(arguments[eo++]);for(eo=0;eo<en.length;)en[eo].fn.apply(en[eo++].ctx,ei)}return this}},945:er=>{"use strict";function en(er){return"undefined"!=typeof Float32Array?function(){var en=new Float32Array([-0]),ei=new Uint8Array(en.buffer),eo=128===ei[3];function ea(er,eo,ea){en[0]=er,eo[ea]=ei[0],eo[ea+1]=ei[1],eo[ea+2]=ei[2],eo[ea+3]=ei[3]}function es(er,eo,ea){en[0]=er,eo[ea]=ei[3],eo[ea+1]=ei[2],eo[ea+2]=ei[1],eo[ea+3]=ei[0]}function eu(er,eo){return ei[0]=er[eo],ei[1]=er[eo+1],ei[2]=er[eo+2],ei[3]=er[eo+3],en[0]}function el(er,eo){return ei[3]=er[eo],ei[2]=er[eo+1],ei[1]=er[eo+2],ei[0]=er[eo+3],en[0]}er.writeFloatLE=eo?ea:es,er.writeFloatBE=eo?es:ea,er.readFloatLE=eo?eu:el,er.readFloatBE=eo?el:eu}():function(){function en(er,en,ei,eo){var ea=en<0?1:0;if(ea&&(en=-en),0===en)er(1/en>0?0:2147483648,ei,eo);else if(isNaN(en))er(2143289344,ei,eo);else if(en>34028234663852886e22)er((ea<<31|2139095040)>>>0,ei,eo);else if(en<11754943508222875e-54)er((ea<<31|Math.round(en/1401298464324817e-60))>>>0,ei,eo);else{var es=Math.floor(Math.log(en)/Math.LN2);er((ea<<31|es+127<<23|8388607&Math.round(en*Math.pow(2,-es)*8388608))>>>0,ei,eo)}}function eu(er,en,ei){var eo=er(en,ei),ea=2*(eo>>31)+1,es=eo>>>23&255,eu=8388607&eo;return 255===es?eu?NaN:ea*(1/0):0===es?1401298464324817e-60*ea*eu:ea*Math.pow(2,es-150)*(eu+8388608)}er.writeFloatLE=en.bind(null,ei),er.writeFloatBE=en.bind(null,eo),er.readFloatLE=eu.bind(null,ea),er.readFloatBE=eu.bind(null,es)}(),"undefined"!=typeof Float64Array?function(){var en=new Float64Array([-0]),ei=new Uint8Array(en.buffer),eo=128===ei[7];function ea(er,eo,ea){en[0]=er,eo[ea]=ei[0],eo[ea+1]=ei[1],eo[ea+2]=ei[2],eo[ea+3]=ei[3],eo[ea+4]=ei[4],eo[ea+5]=ei[5],eo[ea+6]=ei[6],eo[ea+7]=ei[7]}function es(er,eo,ea){en[0]=er,eo[ea]=ei[7],eo[ea+1]=ei[6],eo[ea+2]=ei[5],eo[ea+3]=ei[4],eo[ea+4]=ei[3],eo[ea+5]=ei[2],eo[ea+6]=ei[1],eo[ea+7]=ei[0]}function eu(er,eo){return ei[0]=er[eo],ei[1]=er[eo+1],ei[2]=er[eo+2],ei[3]=er[eo+3],ei[4]=er[eo+4],ei[5]=er[eo+5],ei[6]=er[eo+6],ei[7]=er[eo+7],en[0]}function el(er,eo){return ei[7]=er[eo],ei[6]=er[eo+1],ei[5]=er[eo+2],ei[4]=er[eo+3],ei[3]=er[eo+4],ei[2]=er[eo+5],ei[1]=er[eo+6],ei[0]=er[eo+7],en[0]}er.writeDoubleLE=eo?ea:es,er.writeDoubleBE=eo?es:ea,er.readDoubleLE=eo?eu:el,er.readDoubleBE=eo?el:eu}():function(){function en(er,en,ei,eo,ea,es){var eu,el=eo<0?1:0;if(el&&(eo=-eo),0===eo)er(0,ea,es+en),er(1/eo>0?0:2147483648,ea,es+ei);else if(isNaN(eo))er(0,ea,es+en),er(2146959360,ea,es+ei);else if(eo>17976931348623157e292)er(0,ea,es+en),er((el<<31|2146435072)>>>0,ea,es+ei);else if(eo<22250738585072014e-324)er((eu=eo/5e-324)>>>0,ea,es+en),er((el<<31|eu/4294967296)>>>0,ea,es+ei);else{var ec=Math.floor(Math.log(eo)/Math.LN2);1024===ec&&(ec=1023),er(4503599627370496*(eu=eo*Math.pow(2,-ec))>>>0,ea,es+en),er((el<<31|ec+1023<<20|1048576*eu&1048575)>>>0,ea,es+ei)}}function eu(er,en,ei,eo,ea){var es=er(eo,ea+en),eu=er(eo,ea+ei),el=2*(eu>>31)+1,ec=eu>>>20&2047,ep=4294967296*(1048575&eu)+es;return 2047===ec?ep?NaN:el*(1/0):0===ec?5e-324*el*ep:el*Math.pow(2,ec-1075)*(ep+4503599627370496)}er.writeDoubleLE=en.bind(null,ei,0,4),er.writeDoubleBE=en.bind(null,eo,4,0),er.readDoubleLE=eu.bind(null,ea,0,4),er.readDoubleBE=eu.bind(null,es,4,0)}(),er}function ei(er,en,ei){en[ei]=255&er,en[ei+1]=er>>>8&255,en[ei+2]=er>>>16&255,en[ei+3]=er>>>24}function eo(er,en,ei){en[ei]=er>>>24,en[ei+1]=er>>>16&255,en[ei+2]=er>>>8&255,en[ei+3]=255&er}function ea(er,en){return(er[en]|er[en+1]<<8|er[en+2]<<16|er[en+3]<<24)>>>0}function es(er,en){return(er[en]<<24|er[en+1]<<16|er[en+2]<<8|er[en+3])>>>0}er.exports=en(en)},7199:module=>{"use strict";function inquire(moduleName){try{var mod=eval("quire".replace(/^/,"re"))(moduleName);if(mod&&(mod.length||Object.keys(mod).length))return mod}catch(e){}return null}module.exports=inquire},6662:er=>{"use strict";er.exports=function(er,en,ei){var eo=ei||8192,ea=eo>>>1,es=null,eu=eo;return function(ei){if(ei<1||ei>ea)return er(ei);eu+ei>eo&&(es=er(eo),eu=0);var el=en.call(es,eu,eu+=ei);return 7&eu&&(eu=1+(7|eu)),el}}},4997:(er,en)=>{"use strict";var ei=en;ei.length=function(er){for(var en=0,ei=0,eo=0;eo<er.length;++eo)(ei=er.charCodeAt(eo))<128?en+=1:ei<2048?en+=2:55296==(64512&ei)&&56320==(64512&er.charCodeAt(eo+1))?(++eo,en+=4):en+=3;return en},ei.read=function(er,en,ei){if(ei-en<1)return"";for(var eo,ea=null,es=[],eu=0;en<ei;)(eo=er[en++])<128?es[eu++]=eo:eo>191&&eo<224?es[eu++]=(31&eo)<<6|63&er[en++]:eo>239&&eo<365?(eo=((7&eo)<<18|(63&er[en++])<<12|(63&er[en++])<<6|63&er[en++])-65536,es[eu++]=55296+(eo>>10),es[eu++]=56320+(1023&eo)):es[eu++]=(15&eo)<<12|(63&er[en++])<<6|63&er[en++],eu>8191&&((ea||(ea=[])).push(String.fromCharCode.apply(String,es)),eu=0);return ea?(eu&&ea.push(String.fromCharCode.apply(String,es.slice(0,eu))),ea.join("")):String.fromCharCode.apply(String,es.slice(0,eu))},ei.write=function(er,en,ei){for(var eo,ea,es=ei,eu=0;eu<er.length;++eu)(eo=er.charCodeAt(eu))<128?en[ei++]=eo:eo<2048?(en[ei++]=eo>>6|192,en[ei++]=63&eo|128):55296==(64512&eo)&&56320==(64512&(ea=er.charCodeAt(eu+1)))?(eo=65536+((1023&eo)<<10)+(1023&ea),++eu,en[ei++]=eo>>18|240,en[ei++]=eo>>12&63|128,en[ei++]=eo>>6&63|128,en[ei++]=63&eo|128):(en[ei++]=eo>>12|224,en[ei++]=eo>>6&63|128,en[ei++]=63&eo|128);return ei-es}},3442:(er,en)=>{"use strict";en.__esModule=!0;var ei=function(){function er(en){if(!en)throw TypeError("Invalid argument; `value` has no value.");this.value=er.EMPTY,en&&er.isGuid(en)&&(this.value=en)}return er.isGuid=function(en){var ei=en.toString();return en&&(en instanceof er||er.validator.test(ei))},er.create=function(){return new er([er.gen(2),er.gen(1),er.gen(1),er.gen(1),er.gen(3)].join("-"))},er.createEmpty=function(){return new er("emptyguid")},er.parse=function(en){return new er(en)},er.raw=function(){return[er.gen(2),er.gen(1),er.gen(1),er.gen(1),er.gen(3)].join("-")},er.gen=function(er){for(var en="",ei=0;ei<er;ei++)en+=(65536*(1+Math.random())|0).toString(16).substring(1);return en},er.prototype.equals=function(en){return er.isGuid(en)&&this.value===en.toString()},er.prototype.isEmpty=function(){return this.value===er.EMPTY},er.prototype.toString=function(){return this.value},er.prototype.toJSON=function(){return{value:this.value}},er.validator=RegExp("^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$","i"),er.EMPTY="00000000-0000-0000-0000-000000000000",er}();en.Guid=ei},3720:er=>{er.exports=ei;var en=null;try{en=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(er){}function ei(er,en,ei){this.low=0|er,this.high=0|en,this.unsigned=!!ei}function eo(er){return!0===(er&&er.__isLong__)}ei.prototype.__isLong__,Object.defineProperty(ei.prototype,"__isLong__",{value:!0}),ei.isLong=eo;var ea={},es={};function eu(er,en){var ei,eo,eu;return en?(eu=0<=(er>>>=0)&&er<256)&&(eo=es[er])?eo:(ei=ec(er,(0|er)<0?-1:0,!0),eu&&(es[er]=ei),ei):(eu=-128<=(er|=0)&&er<128)&&(eo=ea[er])?eo:(ei=ec(er,er<0?-1:0,!1),eu&&(ea[er]=ei),ei)}function el(er,en){if(isNaN(er))return en?ev:ey;if(en){if(er<0)return ev;if(er>=eg)return eS}else{if(er<=-em)return eO;if(er+1>=em)return eT}return er<0?el(-er,en).neg():ec(er%eh|0,er/eh|0,en)}function ec(er,en,eo){return new ei(er,en,eo)}ei.fromInt=eu,ei.fromNumber=el,ei.fromBits=ec;var ep=Math.pow;function ed(er,en,ei){if(0===er.length)throw Error("empty string");if("NaN"===er||"Infinity"===er||"+Infinity"===er||"-Infinity"===er)return ey;if("number"==typeof en?(ei=en,en=!1):en=!!en,(ei=ei||10)<2||36<ei)throw RangeError("radix");if((eo=er.indexOf("-"))>0)throw Error("interior hyphen");if(0===eo)return ed(er.substring(1),en,ei).neg();for(var eo,ea=el(ep(ei,8)),es=ey,eu=0;eu<er.length;eu+=8){var ec=Math.min(8,er.length-eu),ef=parseInt(er.substring(eu,eu+ec),ei);if(ec<8){var eh=el(ep(ei,ec));es=es.mul(eh).add(el(ef))}else es=(es=es.mul(ea)).add(el(ef))}return es.unsigned=en,es}function ef(er,en){return"number"==typeof er?el(er,en):"string"==typeof er?ed(er,en):ec(er.low,er.high,"boolean"==typeof en?en:er.unsigned)}ei.fromString=ed,ei.fromValue=ef;var eh=4294967296,eg=18446744073709552e3,em=18446744073709552e3/2,eb=eu(16777216),ey=eu(0);ei.ZERO=ey;var ev=eu(0,!0);ei.UZERO=ev;var e_=eu(1);ei.ONE=e_;var ex=eu(1,!0);ei.UONE=ex;var ew=eu(-1);ei.NEG_ONE=ew;var eT=ec(-1,2147483647,!1);ei.MAX_VALUE=eT;var eS=ec(-1,-1,!0);ei.MAX_UNSIGNED_VALUE=eS;var eO=ec(0,-2147483648,!1);ei.MIN_VALUE=eO;var eA=ei.prototype;eA.toInt=function(){return this.unsigned?this.low>>>0:this.low},eA.toNumber=function(){return this.unsigned?(this.high>>>0)*eh+(this.low>>>0):this.high*eh+(this.low>>>0)},eA.toString=function(er){if((er=er||10)<2||36<er)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(eO)){var en=el(er),ei=this.div(en),eo=ei.mul(en).sub(this);return ei.toString(er)+eo.toInt().toString(er)}return"-"+this.neg().toString(er)}for(var ea=el(ep(er,6),this.unsigned),es=this,eu="";;){var ec=es.div(ea),ed=(es.sub(ec.mul(ea)).toInt()>>>0).toString(er);if((es=ec).isZero())return ed+eu;for(;ed.length<6;)ed="0"+ed;eu=""+ed+eu}},eA.getHighBits=function(){return this.high},eA.getHighBitsUnsigned=function(){return this.high>>>0},eA.getLowBits=function(){return this.low},eA.getLowBitsUnsigned=function(){return this.low>>>0},eA.getNumBitsAbs=function(){if(this.isNegative())return this.eq(eO)?64:this.neg().getNumBitsAbs();for(var er=0!=this.high?this.high:this.low,en=31;en>0&&0==(er&1<<en);en--);return 0!=this.high?en+33:en+1},eA.isZero=function(){return 0===this.high&&0===this.low},eA.eqz=eA.isZero,eA.isNegative=function(){return!this.unsigned&&this.high<0},eA.isPositive=function(){return this.unsigned||this.high>=0},eA.isOdd=function(){return 1==(1&this.low)},eA.isEven=function(){return 0==(1&this.low)},eA.equals=function(er){return eo(er)||(er=ef(er)),(this.unsigned===er.unsigned||this.high>>>31!=1||er.high>>>31!=1)&&this.high===er.high&&this.low===er.low},eA.eq=eA.equals,eA.notEquals=function(er){return!this.eq(er)},eA.neq=eA.notEquals,eA.ne=eA.notEquals,eA.lessThan=function(er){return 0>this.comp(er)},eA.lt=eA.lessThan,eA.lessThanOrEqual=function(er){return 0>=this.comp(er)},eA.lte=eA.lessThanOrEqual,eA.le=eA.lessThanOrEqual,eA.greaterThan=function(er){return this.comp(er)>0},eA.gt=eA.greaterThan,eA.greaterThanOrEqual=function(er){return this.comp(er)>=0},eA.gte=eA.greaterThanOrEqual,eA.ge=eA.greaterThanOrEqual,eA.compare=function(er){if(eo(er)||(er=ef(er)),this.eq(er))return 0;var en=this.isNegative(),ei=er.isNegative();return en&&!ei?-1:!en&&ei?1:this.unsigned?er.high>>>0>this.high>>>0||er.high===this.high&&er.low>>>0>this.low>>>0?-1:1:this.sub(er).isNegative()?-1:1},eA.comp=eA.compare,eA.negate=function(){return!this.unsigned&&this.eq(eO)?eO:this.not().add(e_)},eA.neg=eA.negate,eA.add=function(er){eo(er)||(er=ef(er));var en,ei,ea,es,eu=this.high>>>16,el=65535&this.high,ep=this.low>>>16,ed=65535&this.low,eh=er.high>>>16,eg=65535&er.high,em=er.low>>>16;return es=0+(((ea=0+((en=0+((ei=0+(ed+(65535&er.low)))>>>16)+(ep+em))>>>16)+(el+eg))>>>16)+(eu+eh)),ec((en&=65535)<<16|(ei&=65535),(es&=65535)<<16|(ea&=65535),this.unsigned)},eA.subtract=function(er){return eo(er)||(er=ef(er)),this.add(er.neg())},eA.sub=eA.subtract,eA.multiply=function(er){if(this.isZero())return ey;if(eo(er)||(er=ef(er)),en)return ec(en.mul(this.low,this.high,er.low,er.high),en.get_high(),this.unsigned);if(er.isZero())return ey;if(this.eq(eO))return er.isOdd()?eO:ey;if(er.eq(eO))return this.isOdd()?eO:ey;if(this.isNegative())return er.isNegative()?this.neg().mul(er.neg()):this.neg().mul(er).neg();if(er.isNegative())return this.mul(er.neg()).neg();if(this.lt(eb)&&er.lt(eb))return el(this.toNumber()*er.toNumber(),this.unsigned);var ei,ea,es,eu=this.high>>>16,ep=65535&this.high,ed=this.low>>>16,eh=65535&this.low,eg=er.high>>>16,em=65535&er.high,ev=er.low>>>16,e_=65535&er.low,ex=0;return es=0+((ei=0+((ea=0+eh*e_)>>>16)+ed*e_)>>>16),ei&=65535,es+=(ei+=eh*ev)>>>16,ex+=(es+=ep*e_)>>>16,es&=65535,ex+=(es+=ed*ev)>>>16,es&=65535,ex+=((es+=eh*em)>>>16)+(eu*e_+ep*ev+ed*em+eh*eg),ec((ei&=65535)<<16|(ea&=65535),(ex&=65535)<<16|(es&=65535),this.unsigned)},eA.mul=eA.multiply,eA.divide=function(er){if(eo(er)||(er=ef(er)),er.isZero())throw Error("division by zero");if(en)return this.unsigned||-2147483648!==this.high||-1!==er.low||-1!==er.high?ec((this.unsigned?en.div_u:en.div_s)(this.low,this.high,er.low,er.high),en.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?ev:ey;if(this.unsigned){if(er.unsigned||(er=er.toUnsigned()),er.gt(this))return ev;if(er.gt(this.shru(1)))return ex;es=ev}else{if(this.eq(eO))return er.eq(e_)||er.eq(ew)?eO:er.eq(eO)?e_:(ei=this.shr(1).div(er).shl(1)).eq(ey)?er.isNegative()?e_:ew:(ea=this.sub(er.mul(ei)),es=ei.add(ea.div(er)));if(er.eq(eO))return this.unsigned?ev:ey;if(this.isNegative())return er.isNegative()?this.neg().div(er.neg()):this.neg().div(er).neg();if(er.isNegative())return this.div(er.neg()).neg();es=ey}for(ea=this;ea.gte(er);){ei=Math.max(1,Math.floor(ea.toNumber()/er.toNumber()));for(var ei,ea,es,eu=Math.ceil(Math.log(ei)/Math.LN2),ed=eu<=48?1:ep(2,eu-48),eh=el(ei),eg=eh.mul(er);eg.isNegative()||eg.gt(ea);)eg=(eh=el(ei-=ed,this.unsigned)).mul(er);eh.isZero()&&(eh=e_),es=es.add(eh),ea=ea.sub(eg)}return es},eA.div=eA.divide,eA.modulo=function(er){return eo(er)||(er=ef(er)),en?ec((this.unsigned?en.rem_u:en.rem_s)(this.low,this.high,er.low,er.high),en.get_high(),this.unsigned):this.sub(this.div(er).mul(er))},eA.mod=eA.modulo,eA.rem=eA.modulo,eA.not=function(){return ec(~this.low,~this.high,this.unsigned)},eA.and=function(er){return eo(er)||(er=ef(er)),ec(this.low&er.low,this.high&er.high,this.unsigned)},eA.or=function(er){return eo(er)||(er=ef(er)),ec(this.low|er.low,this.high|er.high,this.unsigned)},eA.xor=function(er){return eo(er)||(er=ef(er)),ec(this.low^er.low,this.high^er.high,this.unsigned)},eA.shiftLeft=function(er){return eo(er)&&(er=er.toInt()),0==(er&=63)?this:er<32?ec(this.low<<er,this.high<<er|this.low>>>32-er,this.unsigned):ec(0,this.low<<er-32,this.unsigned)},eA.shl=eA.shiftLeft,eA.shiftRight=function(er){return eo(er)&&(er=er.toInt()),0==(er&=63)?this:er<32?ec(this.low>>>er|this.high<<32-er,this.high>>er,this.unsigned):ec(this.high>>er-32,this.high>=0?0:-1,this.unsigned)},eA.shr=eA.shiftRight,eA.shiftRightUnsigned=function(er){if(eo(er)&&(er=er.toInt()),0==(er&=63))return this;var en=this.high;return er<32?ec(this.low>>>er|en<<32-er,en>>>er,this.unsigned):ec(32===er?en:en>>>er-32,0,this.unsigned)},eA.shru=eA.shiftRightUnsigned,eA.shr_u=eA.shiftRightUnsigned,eA.toSigned=function(){return this.unsigned?ec(this.low,this.high,!1):this},eA.toUnsigned=function(){return this.unsigned?this:ec(this.low,this.high,!0)},eA.toBytes=function(er){return er?this.toBytesLE():this.toBytesBE()},eA.toBytesLE=function(){var er=this.high,en=this.low;return[255&en,en>>>8&255,en>>>16&255,en>>>24,255&er,er>>>8&255,er>>>16&255,er>>>24]},eA.toBytesBE=function(){var er=this.high,en=this.low;return[er>>>24,er>>>16&255,er>>>8&255,255&er,en>>>24,en>>>16&255,en>>>8&255,255&en]},ei.fromBytes=function(er,en,eo){return eo?ei.fromBytesLE(er,en):ei.fromBytesBE(er,en)},ei.fromBytesLE=function(er,en){return new ei(er[0]|er[1]<<8|er[2]<<16|er[3]<<24,er[4]|er[5]<<8|er[6]<<16|er[7]<<24,en)},ei.fromBytesBE=function(er,en){return new ei(er[4]<<24|er[5]<<16|er[6]<<8|er[7],er[0]<<24|er[1]<<16|er[2]<<8|er[3],en)}},1446:(er,en,ei)=>{"use strict";var eo,ea,es,eu=ei(2100),el=eu.Reader,ec=eu.Writer,ep=eu.util,ed=eu.roots.default||(eu.roots.default={});ed.onnx=((es={}).Version=((ea=Object.create(eo={}))[eo[0]="_START_VERSION"]=0,ea[eo[1]="IR_VERSION_2017_10_10"]=1,ea[eo[2]="IR_VERSION_2017_10_30"]=2,ea[eo[3]="IR_VERSION_2017_11_3"]=3,ea[eo[4]="IR_VERSION_2019_1_22"]=4,ea[eo[5]="IR_VERSION"]=5,ea),es.AttributeProto=function(){function er(er){if(this.floats=[],this.ints=[],this.strings=[],this.tensors=[],this.graphs=[],er)for(var en=Object.keys(er),ei=0;ei<en.length;++ei)null!=er[en[ei]]&&(this[en[ei]]=er[en[ei]])}return er.prototype.name="",er.prototype.refAttrName="",er.prototype.docString="",er.prototype.type=0,er.prototype.f=0,er.prototype.i=ep.Long?ep.Long.fromBits(0,0,!1):0,er.prototype.s=ep.newBuffer([]),er.prototype.t=null,er.prototype.g=null,er.prototype.floats=ep.emptyArray,er.prototype.ints=ep.emptyArray,er.prototype.strings=ep.emptyArray,er.prototype.tensors=ep.emptyArray,er.prototype.graphs=ep.emptyArray,er.create=function(en){return new er(en)},er.encode=function(er,en){if(en||(en=ec.create()),null!=er.name&&er.hasOwnProperty("name")&&en.uint32(10).string(er.name),null!=er.f&&er.hasOwnProperty("f")&&en.uint32(21).float(er.f),null!=er.i&&er.hasOwnProperty("i")&&en.uint32(24).int64(er.i),null!=er.s&&er.hasOwnProperty("s")&&en.uint32(34).bytes(er.s),null!=er.t&&er.hasOwnProperty("t")&&ed.onnx.TensorProto.encode(er.t,en.uint32(42).fork()).ldelim(),null!=er.g&&er.hasOwnProperty("g")&&ed.onnx.GraphProto.encode(er.g,en.uint32(50).fork()).ldelim(),null!=er.floats&&er.floats.length){en.uint32(58).fork();for(var ei=0;ei<er.floats.length;++ei)en.float(er.floats[ei]);en.ldelim()}if(null!=er.ints&&er.ints.length){for(en.uint32(66).fork(),ei=0;ei<er.ints.length;++ei)en.int64(er.ints[ei]);en.ldelim()}if(null!=er.strings&&er.strings.length)for(ei=0;ei<er.strings.length;++ei)en.uint32(74).bytes(er.strings[ei]);if(null!=er.tensors&&er.tensors.length)for(ei=0;ei<er.tensors.length;++ei)ed.onnx.TensorProto.encode(er.tensors[ei],en.uint32(82).fork()).ldelim();if(null!=er.graphs&&er.graphs.length)for(ei=0;ei<er.graphs.length;++ei)ed.onnx.GraphProto.encode(er.graphs[ei],en.uint32(90).fork()).ldelim();return null!=er.docString&&er.hasOwnProperty("docString")&&en.uint32(106).string(er.docString),null!=er.type&&er.hasOwnProperty("type")&&en.uint32(160).int32(er.type),null!=er.refAttrName&&er.hasOwnProperty("refAttrName")&&en.uint32(170).string(er.refAttrName),en},er.encodeDelimited=function(er,en){return this.encode(er,en).ldelim()},er.decode=function(er,en){er instanceof el||(er=el.create(er));for(var ei=void 0===en?er.len:er.pos+en,eo=new ed.onnx.AttributeProto;er.pos<ei;){var ea=er.uint32();switch(ea>>>3){case 1:eo.name=er.string();break;case 21:eo.refAttrName=er.string();break;case 13:eo.docString=er.string();break;case 20:eo.type=er.int32();break;case 2:eo.f=er.float();break;case 3:eo.i=er.int64();break;case 4:eo.s=er.bytes();break;case 5:eo.t=ed.onnx.TensorProto.decode(er,er.uint32());break;case 6:eo.g=ed.onnx.GraphProto.decode(er,er.uint32());break;case 7:if(eo.floats&&eo.floats.length||(eo.floats=[]),2==(7&ea))for(var es=er.uint32()+er.pos;er.pos<es;)eo.floats.push(er.float());else eo.floats.push(er.float());break;case 8:if(eo.ints&&eo.ints.length||(eo.ints=[]),2==(7&ea))for(es=er.uint32()+er.pos;er.pos<es;)eo.ints.push(er.int64());else eo.ints.push(er.int64());break;case 9:eo.strings&&eo.strings.length||(eo.strings=[]),eo.strings.push(er.bytes());break;case 10:eo.tensors&&eo.tensors.length||(eo.tensors=[]),eo.tensors.push(ed.onnx.TensorProto.decode(er,er.uint32()));break;case 11:eo.graphs&&eo.graphs.length||(eo.graphs=[]),eo.graphs.push(ed.onnx.GraphProto.decode(er,er.uint32()));break;default:er.skipType(7&ea)}}return eo},er.decodeDelimited=function(er){return er instanceof el||(er=new el(er)),this.decode(er,er.uint32())},er.verify=function(er){if("object"!=typeof er||null===er)return"object expected";if(null!=er.name&&er.hasOwnProperty("name")&&!ep.isString(er.name))return"name: string expected";if(null!=er.refAttrName&&er.hasOwnProperty("refAttrName")&&!ep.isString(er.refAttrName))return"refAttrName: string expected";if(null!=er.docString&&er.hasOwnProperty("docString")&&!ep.isString(er.docString))return"docString: string expected";if(null!=er.type&&er.hasOwnProperty("type"))switch(er.type){default:return"type: enum value expected";case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:case 10:}if(null!=er.f&&er.hasOwnProperty("f")&&"number"!=typeof er.f)return"f: number expected";if(null!=er.i&&er.hasOwnProperty("i")&&!(ep.isInteger(er.i)||er.i&&ep.isInteger(er.i.low)&&ep.isInteger(er.i.high)))return"i: integer|Long expected";if(null!=er.s&&er.hasOwnProperty("s")&&!(er.s&&"number"==typeof er.s.length||ep.isString(er.s)))return"s: buffer expected";if(null!=er.t&&er.hasOwnProperty("t")&&(en=ed.onnx.TensorProto.verify(er.t)))return"t."+en;if(null!=er.g&&er.hasOwnProperty("g")&&(en=ed.onnx.GraphProto.verify(er.g)))return"g."+en;if(null!=er.floats&&er.hasOwnProperty("floats")){if(!Array.isArray(er.floats))return"floats: array expected";for(var en,ei=0;ei<er.floats.length;++ei)if("number"!=typeof er.floats[ei])return"floats: number[] expected"}if(null!=er.ints&&er.hasOwnProperty("ints")){if(!Array.isArray(er.ints))return"ints: array expected";for(ei=0;ei<er.ints.length;++ei)if(!(ep.isInteger(er.ints[ei])||er.ints[ei]&&ep.isInteger(er.ints[ei].low)&&ep.isInteger(er.ints[ei].high)))return"ints: integer|Long[] expected"}if(null!=er.strings&&er.hasOwnProperty("strings")){if(!Array.isArray(er.strings))return"strings: array expected";for(ei=0;ei<er.strings.length;++ei)if(!(er.strings[ei]&&"number"==typeof er.strings[ei].length||ep.isString(er.strings[ei])))return"strings: buffer[] expected"}if(null!=er.tensors&&er.hasOwnProperty("tensors")){if(!Array.isArray(er.tensors))return"tensors: array expected";for(ei=0;ei<er.tensors.length;++ei)if(en=ed.onnx.TensorProto.verify(er.tensors[ei]))return"tensors."+en}if(null!=er.graphs&&er.hasOwnProperty("graphs")){if(!Array.isArray(er.graphs))return"graphs: array expected";for(ei=0;ei<er.graphs.length;++ei)if(en=ed.onnx.GraphProto.verify(er.graphs[ei]))return"graphs."+en}return null},er.fromObject=function(er){if(er instanceof ed.onnx.AttributeProto)return er;var en=new ed.onnx.AttributeProto;switch(null!=er.name&&(en.name=String(er.name)),null!=er.refAttrName&&(en.refAttrName=String(er.refAttrName)),null!=er.docString&&(en.docString=String(er.docString)),er.type){case"UNDEFINED":case 0:en.type=0;break;case"FLOAT":case 1:en.type=1;break;case"INT":case 2:en.type=2;break;case"STRING":case 3:en.type=3;break;case"TENSOR":case 4:en.type=4;break;case"GRAPH":case 5:en.type=5;break;case"FLOATS":case 6:en.type=6;break;case"INTS":case 7:en.type=7;break;case"STRINGS":case 8:en.type=8;break;case"TENSORS":case 9:en.type=9;break;case"GRAPHS":case 10:en.type=10}if(null!=er.f&&(en.f=Number(er.f)),null!=er.i&&(ep.Long?(en.i=ep.Long.fromValue(er.i)).unsigned=!1:"string"==typeof er.i?en.i=parseInt(er.i,10):"number"==typeof er.i?en.i=er.i:"object"==typeof er.i&&(en.i=new ep.LongBits(er.i.low>>>0,er.i.high>>>0).toNumber())),null!=er.s&&("string"==typeof er.s?ep.base64.decode(er.s,en.s=ep.newBuffer(ep.base64.length(er.s)),0):er.s.length&&(en.s=er.s)),null!=er.t){if("object"!=typeof er.t)throw TypeError(".onnx.AttributeProto.t: object expected");en.t=ed.onnx.TensorProto.fromObject(er.t)}if(null!=er.g){if("object"!=typeof er.g)throw TypeError(".onnx.AttributeProto.g: object expected");en.g=ed.onnx.GraphProto.fromObject(er.g)}if(er.floats){if(!Array.isArray(er.floats))throw TypeError(".onnx.AttributeProto.floats: array expected");en.floats=[];for(var ei=0;ei<er.floats.length;++ei)en.floats[ei]=Number(er.floats[ei])}if(er.ints){if(!Array.isArray(er.ints))throw TypeError(".onnx.AttributeProto.ints: array expected");for(en.ints=[],ei=0;ei<er.ints.length;++ei)ep.Long?(en.ints[ei]=ep.Long.fromValue(er.ints[ei])).unsigned=!1:"string"==typeof er.ints[ei]?en.ints[ei]=parseInt(er.ints[ei],10):"number"==typeof er.ints[ei]?en.ints[ei]=er.ints[ei]:"object"==typeof er.ints[ei]&&(en.ints[ei]=new ep.LongBits(er.ints[ei].low>>>0,er.ints[ei].high>>>0).toNumber())}if(er.strings){if(!Array.isArray(er.strings))throw TypeError(".onnx.AttributeProto.strings: array expected");for(en.strings=[],ei=0;ei<er.strings.length;++ei)"string"==typeof er.strings[ei]?ep.base64.decode(er.strings[ei],en.strings[ei]=ep.newBuffer(ep.base64.length(er.strings[ei])),0):er.strings[ei].length&&(en.strings[ei]=er.strings[ei])}if(er.tensors){if(!Array.isArray(er.tensors))throw TypeError(".onnx.AttributeProto.tensors: array expected");for(en.tensors=[],ei=0;ei<er.tensors.length;++ei){if("object"!=typeof er.tensors[ei])throw TypeError(".onnx.AttributeProto.tensors: object expected");en.tensors[ei]=ed.onnx.TensorProto.fromObject(er.tensors[ei])}}if(er.graphs){if(!Array.isArray(er.graphs))throw TypeError(".onnx.AttributeProto.graphs: array expected");for(en.graphs=[],ei=0;ei<er.graphs.length;++ei){if("object"!=typeof er.graphs[ei])throw TypeError(".onnx.AttributeProto.graphs: object expected");en.graphs[ei]=ed.onnx.GraphProto.fromObject(er.graphs[ei])}}return en},er.toObject=function(er,en){en||(en={});var ei={};if((en.arrays||en.defaults)&&(ei.floats=[],ei.ints=[],ei.strings=[],ei.tensors=[],ei.graphs=[]),en.defaults){if(ei.name="",ei.f=0,ep.Long){var eo=new ep.Long(0,0,!1);ei.i=en.longs===String?eo.toString():en.longs===Number?eo.toNumber():eo}else ei.i=en.longs===String?"0":0;en.bytes===String?ei.s="":(ei.s=[],en.bytes!==Array&&(ei.s=ep.newBuffer(ei.s))),ei.t=null,ei.g=null,ei.docString="",ei.type=en.enums===String?"UNDEFINED":0,ei.refAttrName=""}if(null!=er.name&&er.hasOwnProperty("name")&&(ei.name=er.name),null!=er.f&&er.hasOwnProperty("f")&&(ei.f=en.json&&!isFinite(er.f)?String(er.f):er.f),null!=er.i&&er.hasOwnProperty("i")&&("number"==typeof er.i?ei.i=en.longs===String?String(er.i):er.i:ei.i=en.longs===String?ep.Long.prototype.toString.call(er.i):en.longs===Number?new ep.LongBits(er.i.low>>>0,er.i.high>>>0).toNumber():er.i),null!=er.s&&er.hasOwnProperty("s")&&(ei.s=en.bytes===String?ep.base64.encode(er.s,0,er.s.length):en.bytes===Array?Array.prototype.slice.call(er.s):er.s),null!=er.t&&er.hasOwnProperty("t")&&(ei.t=ed.onnx.TensorProto.toObject(er.t,en)),null!=er.g&&er.hasOwnProperty("g")&&(ei.g=ed.onnx.GraphProto.toObject(er.g,en)),er.floats&&er.floats.length){ei.floats=[];for(var ea=0;ea<er.floats.length;++ea)ei.floats[ea]=en.json&&!isFinite(er.floats[ea])?String(er.floats[ea]):er.floats[ea]}if(er.ints&&er.ints.length)for(ei.ints=[],ea=0;ea<er.ints.length;++ea)"number"==typeof er.ints[ea]?ei.ints[ea]=en.longs===String?String(er.ints[ea]):er.ints[ea]:ei.ints[ea]=en.longs===String?ep.Long.prototype.toString.call(er.ints[ea]):en.longs===Number?new ep.LongBits(er.ints[ea].low>>>0,er.ints[ea].high>>>0).toNumber():er.ints[ea];if(er.strings&&er.strings.length)for(ei.strings=[],ea=0;ea<er.strings.length;++ea)ei.strings[ea]=en.bytes===String?ep.base64.encode(er.strings[ea],0,er.strings[ea].length):en.bytes===Array?Array.prototype.slice.call(er.strings[ea]):er.strings[ea];if(er.tensors&&er.tensors.length)for(ei.tensors=[],ea=0;ea<er.tensors.length;++ea)ei.tensors[ea]=ed.onnx.TensorProto.toObject(er.tensors[ea],en);if(er.graphs&&er.graphs.length)for(ei.graphs=[],ea=0;ea<er.graphs.length;++ea)ei.graphs[ea]=ed.onnx.GraphProto.toObject(er.graphs[ea],en);return null!=er.docString&&er.hasOwnProperty("docString")&&(ei.docString=er.docString),null!=er.type&&er.hasOwnProperty("type")&&(ei.type=en.enums===String?ed.onnx.AttributeProto.AttributeType[er.type]:er.type),null!=er.refAttrName&&er.hasOwnProperty("refAttrName")&&(ei.refAttrName=er.refAttrName),ei},er.prototype.toJSON=function(){return this.constructor.toObject(this,eu.util.toJSONOptions)},er.AttributeType=function(){var er={},en=Object.create(er);return en[er[0]="UNDEFINED"]=0,en[er[1]="FLOAT"]=1,en[er[2]="INT"]=2,en[er[3]="STRING"]=3,en[er[4]="TENSOR"]=4,en[er[5]="GRAPH"]=5,en[er[6]="FLOATS"]=6,en[er[7]="INTS"]=7,en[er[8]="STRINGS"]=8,en[er[9]="TENSORS"]=9,en[er[10]="GRAPHS"]=10,en}(),er}(),es.ValueInfoProto=function(){function er(er){if(er)for(var en=Object.keys(er),ei=0;ei<en.length;++ei)null!=er[en[ei]]&&(this[en[ei]]=er[en[ei]])}return er.prototype.name="",er.prototype.type=null,er.prototype.docString="",er.create=function(en){return new er(en)},er.encode=function(er,en){return en||(en=ec.create()),null!=er.name&&er.hasOwnProperty("name")&&en.uint32(10).string(er.name),null!=er.type&&er.hasOwnProperty("type")&&ed.onnx.TypeProto.encode(er.type,en.uint32(18).fork()).ldelim(),null!=er.docString&&er.hasOwnProperty("docString")&&en.uint32(26).string(er.docString),en},er.encodeDelimited=function(er,en){return this.encode(er,en).ldelim()},er.decode=function(er,en){er instanceof el||(er=el.create(er));for(var ei=void 0===en?er.len:er.pos+en,eo=new ed.onnx.ValueInfoProto;er.pos<ei;){var ea=er.uint32();switch(ea>>>3){case 1:eo.name=er.string();break;case 2:eo.type=ed.onnx.TypeProto.decode(er,er.uint32());break;case 3:eo.docString=er.string();break;default:er.skipType(7&ea)}}return eo},er.decodeDelimited=function(er){return er instanceof el||(er=new el(er)),this.decode(er,er.uint32())},er.verify=function(er){if("object"!=typeof er||null===er)return"object expected";if(null!=er.name&&er.hasOwnProperty("name")&&!ep.isString(er.name))return"name: string expected";if(null!=er.type&&er.hasOwnProperty("type")){var en=ed.onnx.TypeProto.verify(er.type);if(en)return"type."+en}return null!=er.docString&&er.hasOwnProperty("docString")&&!ep.isString(er.docString)?"docString: string expected":null},er.fromObject=function(er){if(er instanceof ed.onnx.ValueInfoProto)return er;var en=new ed.onnx.ValueInfoProto;if(null!=er.name&&(en.name=String(er.name)),null!=er.type){if("object"!=typeof er.type)throw TypeError(".onnx.ValueInfoProto.type: object expected");en.type=ed.onnx.TypeProto.fromObject(er.type)}return null!=er.docString&&(en.docString=String(er.docString)),en},er.toObject=function(er,en){en||(en={});var ei={};return en.defaults&&(ei.name="",ei.type=null,ei.docString=""),null!=er.name&&er.hasOwnProperty("name")&&(ei.name=er.name),null!=er.type&&er.hasOwnProperty("type")&&(ei.type=ed.onnx.TypeProto.toObject(er.type,en)),null!=er.docString&&er.hasOwnProperty("docString")&&(ei.docString=er.docString),ei},er.prototype.toJSON=function(){return this.constructor.toObject(this,eu.util.toJSONOptions)},er}(),es.NodeProto=function(){function er(er){if(this.input=[],this.output=[],this.attribute=[],er)for(var en=Object.keys(er),ei=0;ei<en.length;++ei)null!=er[en[ei]]&&(this[en[ei]]=er[en[ei]])}return er.prototype.input=ep.emptyArray,er.prototype.output=ep.emptyArray,er.prototype.name="",er.prototype.opType="",er.prototype.domain="",er.prototype.attribute=ep.emptyArray,er.prototype.docString="",er.create=function(en){return new er(en)},er.encode=function(er,en){if(en||(en=ec.create()),null!=er.input&&er.input.length)for(var ei=0;ei<er.input.length;++ei)en.uint32(10).string(er.input[ei]);if(null!=er.output&&er.output.length)for(ei=0;ei<er.output.length;++ei)en.uint32(18).string(er.output[ei]);if(null!=er.name&&er.hasOwnProperty("name")&&en.uint32(26).string(er.name),null!=er.opType&&er.hasOwnProperty("opType")&&en.uint32(34).string(er.opType),null!=er.attribute&&er.attribute.length)for(ei=0;ei<er.attribute.length;++ei)ed.onnx.AttributeProto.encode(er.attribute[ei],en.uint32(42).fork()).ldelim();return null!=er.docString&&er.hasOwnProperty("docString")&&en.uint32(50).string(er.docString),null!=er.domain&&er.hasOwnProperty("domain")&&en.uint32(58).string(er.domain),en},er.encodeDelimited=function(er,en){return this.encode(er,en).ldelim()},er.decode=function(er,en){er instanceof el||(er=el.create(er));for(var ei=void 0===en?er.len:er.pos+en,eo=new ed.onnx.NodeProto;er.pos<ei;){var ea=er.uint32();switch(ea>>>3){case 1:eo.input&&eo.input.length||(eo.input=[]),eo.input.push(er.string());break;case 2:eo.output&&eo.output.length||(eo.output=[]),eo.output.push(er.string());break;case 3:eo.name=er.string();break;case 4:eo.opType=er.string();break;case 7:eo.domain=er.string();break;case 5:eo.attribute&&eo.attribute.length||(eo.attribute=[]),eo.attribute.push(ed.onnx.AttributeProto.decode(er,er.uint32()));break;case 6:eo.docString=er.string();break;default:er.skipType(7&ea)}}return eo},er.decodeDelimited=function(er){return er instanceof el||(er=new el(er)),this.decode(er,er.uint32())},er.verify=function(er){if("object"!=typeof er||null===er)return"object expected";if(null!=er.input&&er.hasOwnProperty("input")){if(!Array.isArray(er.input))return"input: array expected";for(var en=0;en<er.input.length;++en)if(!ep.isString(er.input[en]))return"input: string[] expected"}if(null!=er.output&&er.hasOwnProperty("output")){if(!Array.isArray(er.output))return"output: array expected";for(en=0;en<er.output.length;++en)if(!ep.isString(er.output[en]))return"output: string[] expected"}if(null!=er.name&&er.hasOwnProperty("name")&&!ep.isString(er.name))return"name: string expected";if(null!=er.opType&&er.hasOwnProperty("opType")&&!ep.isString(er.opType))return"opType: string expected";if(null!=er.domain&&er.hasOwnProperty("domain")&&!ep.isString(er.domain))return"domain: string expected";if(null!=er.attribute&&er.hasOwnProperty("attribute")){if(!Array.isArray(er.attribute))return"attribute: array expected";for(en=0;en<er.attribute.length;++en){var ei=ed.onnx.AttributeProto.verify(er.attribute[en]);if(ei)return"attribute."+ei}}return null!=er.docString&&er.hasOwnProperty("docString")&&!ep.isString(er.docString)?"docString: string expected":null},er.fromObject=function(er){if(er instanceof ed.onnx.NodeProto)return er;var en=new ed.onnx.NodeProto;if(er.input){if(!Array.isArray(er.input))throw TypeError(".onnx.NodeProto.input: array expected");en.input=[];for(var ei=0;ei<er.input.length;++ei)en.input[ei]=String(er.input[ei])}if(er.output){if(!Array.isArray(er.output))throw TypeError(".onnx.NodeProto.output: array expected");for(en.output=[],ei=0;ei<er.output.length;++ei)en.output[ei]=String(er.output[ei])}if(null!=er.name&&(en.name=String(er.name)),null!=er.opType&&(en.opType=String(er.opType)),null!=er.domain&&(en.domain=String(er.domain)),er.attribute){if(!Array.isArray(er.attribute))throw TypeError(".onnx.NodeProto.attribute: array expected");for(en.attribute=[],ei=0;ei<er.attribute.length;++ei){if("object"!=typeof er.attribute[ei])throw TypeError(".onnx.NodeProto.attribute: object expected");en.attribute[ei]=ed.onnx.AttributeProto.fromObject(er.attribute[ei])}}return null!=er.docString&&(en.docString=String(er.docString)),en},er.toObject=function(er,en){en||(en={});var ei={};if((en.arrays||en.defaults)&&(ei.input=[],ei.output=[],ei.attribute=[]),en.defaults&&(ei.name="",ei.opType="",ei.docString="",ei.domain=""),er.input&&er.input.length){ei.input=[];for(var eo=0;eo<er.input.length;++eo)ei.input[eo]=er.input[eo]}if(er.output&&er.output.length)for(ei.output=[],eo=0;eo<er.output.length;++eo)ei.output[eo]=er.output[eo];if(null!=er.name&&er.hasOwnProperty("name")&&(ei.name=er.name),null!=er.opType&&er.hasOwnProperty("opType")&&(ei.opType=er.opType),er.attribute&&er.attribute.length)for(ei.attribute=[],eo=0;eo<er.attribute.length;++eo)ei.attribute[eo]=ed.onnx.AttributeProto.toObject(er.attribute[eo],en);return null!=er.docString&&er.hasOwnProperty("docString")&&(ei.docString=er.docString),null!=er.domain&&er.hasOwnProperty("domain")&&(ei.domain=er.domain),ei},er.prototype.toJSON=function(){return this.constructor.toObject(this,eu.util.toJSONOptions)},er}(),es.ModelProto=function(){function er(er){if(this.opsetImport=[],this.metadataProps=[],er)for(var en=Object.keys(er),ei=0;ei<en.length;++ei)null!=er[en[ei]]&&(this[en[ei]]=er[en[ei]])}return er.prototype.irVersion=ep.Long?ep.Long.fromBits(0,0,!1):0,er.prototype.opsetImport=ep.emptyArray,er.prototype.producerName="",er.prototype.producerVersion="",er.prototype.domain="",er.prototype.modelVersion=ep.Long?ep.Long.fromBits(0,0,!1):0,er.prototype.docString="",er.prototype.graph=null,er.prototype.metadataProps=ep.emptyArray,er.create=function(en){return new er(en)},er.encode=function(er,en){if(en||(en=ec.create()),null!=er.irVersion&&er.hasOwnProperty("irVersion")&&en.uint32(8).int64(er.irVersion),null!=er.producerName&&er.hasOwnProperty("producerName")&&en.uint32(18).string(er.producerName),null!=er.producerVersion&&er.hasOwnProperty("producerVersion")&&en.uint32(26).string(er.producerVersion),null!=er.domain&&er.hasOwnProperty("domain")&&en.uint32(34).string(er.domain),null!=er.modelVersion&&er.hasOwnProperty("modelVersion")&&en.uint32(40).int64(er.modelVersion),null!=er.docString&&er.hasOwnProperty("docString")&&en.uint32(50).string(er.docString),null!=er.graph&&er.hasOwnProperty("graph")&&ed.onnx.GraphProto.encode(er.graph,en.uint32(58).fork()).ldelim(),null!=er.opsetImport&&er.opsetImport.length)for(var ei=0;ei<er.opsetImport.length;++ei)ed.onnx.OperatorSetIdProto.encode(er.opsetImport[ei],en.uint32(66).fork()).ldelim();if(null!=er.metadataProps&&er.metadataProps.length)for(ei=0;ei<er.metadataProps.length;++ei)ed.onnx.StringStringEntryProto.encode(er.metadataProps[ei],en.uint32(114).fork()).ldelim();return en},er.encodeDelimited=function(er,en){return this.encode(er,en).ldelim()},er.decode=function(er,en){er instanceof el||(er=el.create(er));for(var ei=void 0===en?er.len:er.pos+en,eo=new ed.onnx.ModelProto;er.pos<ei;){var ea=er.uint32();switch(ea>>>3){case 1:eo.irVersion=er.int64();break;case 8:eo.opsetImport&&eo.opsetImport.length||(eo.opsetImport=[]),eo.opsetImport.push(ed.onnx.OperatorSetIdProto.decode(er,er.uint32()));break;case 2:eo.producerName=er.string();break;case 3:eo.producerVersion=er.string();break;case 4:eo.domain=er.string();break;case 5:eo.modelVersion=er.int64();break;case 6:eo.docString=er.string();break;case 7:eo.graph=ed.onnx.GraphProto.decode(er,er.uint32());break;case 14:eo.metadataProps&&eo.metadataProps.length||(eo.metadataProps=[]),eo.metadataProps.push(ed.onnx.StringStringEntryProto.decode(er,er.uint32()));break;default:er.skipType(7&ea)}}return eo},er.decodeDelimited=function(er){return er instanceof el||(er=new el(er)),this.decode(er,er.uint32())},er.verify=function(er){if("object"!=typeof er||null===er)return"object expected";if(null!=er.irVersion&&er.hasOwnProperty("irVersion")&&!(ep.isInteger(er.irVersion)||er.irVersion&&ep.isInteger(er.irVersion.low)&&ep.isInteger(er.irVersion.high)))return"irVersion: integer|Long expected";if(null!=er.opsetImport&&er.hasOwnProperty("opsetImport")){if(!Array.isArray(er.opsetImport))return"opsetImport: array expected";for(var en,ei=0;ei<er.opsetImport.length;++ei)if(en=ed.onnx.OperatorSetIdProto.verify(er.opsetImport[ei]))return"opsetImport."+en}if(null!=er.producerName&&er.hasOwnProperty("producerName")&&!ep.isString(er.producerName))return"producerName: string expected";if(null!=er.producerVersion&&er.hasOwnProperty("producerVersion")&&!ep.isString(er.producerVersion))return"producerVersion: string expected";if(null!=er.domain&&er.hasOwnProperty("domain")&&!ep.isString(er.domain))return"domain: string expected";if(null!=er.modelVersion&&er.hasOwnProperty("modelVersion")&&!(ep.isInteger(er.modelVersion)||er.modelVersion&&ep.isInteger(er.modelVersion.low)&&ep.isInteger(er.modelVersion.high)))return"modelVersion: integer|Long expected";if(null!=er.docString&&er.hasOwnProperty("docString")&&!ep.isString(er.docString))return"docString: string expected";if(null!=er.graph&&er.hasOwnProperty("graph")&&(en=ed.onnx.GraphProto.verify(er.graph)))return"graph."+en;if(null!=er.metadataProps&&er.hasOwnProperty("metadataProps")){if(!Array.isArray(er.metadataProps))return"metadataProps: array expected";for(ei=0;ei<er.metadataProps.length;++ei)if(en=ed.onnx.StringStringEntryProto.verify(er.metadataProps[ei]))return"metadataProps."+en}return null},er.fromObject=function(er){if(er instanceof ed.onnx.ModelProto)return er;var en=new ed.onnx.ModelProto;if(null!=er.irVersion&&(ep.Long?(en.irVersion=ep.Long.fromValue(er.irVersion)).unsigned=!1:"string"==typeof er.irVersion?en.irVersion=parseInt(er.irVersion,10):"number"==typeof er.irVersion?en.irVersion=er.irVersion:"object"==typeof er.irVersion&&(en.irVersion=new ep.LongBits(er.irVersion.low>>>0,er.irVersion.high>>>0).toNumber())),er.opsetImport){if(!Array.isArray(er.opsetImport))throw TypeError(".onnx.ModelProto.opsetImport: array expected");en.opsetImport=[];for(var ei=0;ei<er.opsetImport.length;++ei){if("object"!=typeof er.opsetImport[ei])throw TypeError(".onnx.ModelProto.opsetImport: object expected");en.opsetImport[ei]=ed.onnx.OperatorSetIdProto.fromObject(er.opsetImport[ei])}}if(null!=er.producerName&&(en.producerName=String(er.producerName)),null!=er.producerVersion&&(en.producerVersion=String(er.producerVersion)),null!=er.domain&&(en.domain=String(er.domain)),null!=er.modelVersion&&(ep.Long?(en.modelVersion=ep.Long.fromValue(er.modelVersion)).unsigned=!1:"string"==typeof er.modelVersion?en.modelVersion=parseInt(er.modelVersion,10):"number"==typeof er.modelVersion?en.modelVersion=er.modelVersion:"object"==typeof er.modelVersion&&(en.modelVersion=new ep.LongBits(er.modelVersion.low>>>0,er.modelVersion.high>>>0).toNumber())),null!=er.docString&&(en.docString=String(er.docString)),null!=er.graph){if("object"!=typeof er.graph)throw TypeError(".onnx.ModelProto.graph: object expected");en.graph=ed.onnx.GraphProto.fromObject(er.graph)}if(er.metadataProps){if(!Array.isArray(er.metadataProps))throw TypeError(".onnx.ModelProto.metadataProps: array expected");for(en.metadataProps=[],ei=0;ei<er.metadataProps.length;++ei){if("object"!=typeof er.metadataProps[ei])throw TypeError(".onnx.ModelProto.metadataProps: object expected");en.metadataProps[ei]=ed.onnx.StringStringEntryProto.fromObject(er.metadataProps[ei])}}return en},er.toObject=function(er,en){en||(en={});var ei={};if((en.arrays||en.defaults)&&(ei.opsetImport=[],ei.metadataProps=[]),en.defaults){if(ep.Long){var eo=new ep.Long(0,0,!1);ei.irVersion=en.longs===String?eo.toString():en.longs===Number?eo.toNumber():eo}else ei.irVersion=en.longs===String?"0":0;ei.producerName="",ei.producerVersion="",ei.domain="",ep.Long?(eo=new ep.Long(0,0,!1),ei.modelVersion=en.longs===String?eo.toString():en.longs===Number?eo.toNumber():eo):ei.modelVersion=en.longs===String?"0":0,ei.docString="",ei.graph=null}if(null!=er.irVersion&&er.hasOwnProperty("irVersion")&&("number"==typeof er.irVersion?ei.irVersion=en.longs===String?String(er.irVersion):er.irVersion:ei.irVersion=en.longs===String?ep.Long.prototype.toString.call(er.irVersion):en.longs===Number?new ep.LongBits(er.irVersion.low>>>0,er.irVersion.high>>>0).toNumber():er.irVersion),null!=er.producerName&&er.hasOwnProperty("producerName")&&(ei.producerName=er.producerName),null!=er.producerVersion&&er.hasOwnProperty("producerVersion")&&(ei.producerVersion=er.producerVersion),null!=er.domain&&er.hasOwnProperty("domain")&&(ei.domain=er.domain),null!=er.modelVersion&&er.hasOwnProperty("modelVersion")&&("number"==typeof er.modelVersion?ei.modelVersion=en.longs===String?String(er.modelVersion):er.modelVersion:ei.modelVersion=en.longs===String?ep.Long.prototype.toString.call(er.modelVersion):en.longs===Number?new ep.LongBits(er.modelVersion.low>>>0,er.modelVersion.high>>>0).toNumber():er.modelVersion),null!=er.docString&&er.hasOwnProperty("docString")&&(ei.docString=er.docString),null!=er.graph&&er.hasOwnProperty("graph")&&(ei.graph=ed.onnx.GraphProto.toObject(er.graph,en)),er.opsetImport&&er.opsetImport.length){ei.opsetImport=[];for(var ea=0;ea<er.opsetImport.length;++ea)ei.opsetImport[ea]=ed.onnx.OperatorSetIdProto.toObject(er.opsetImport[ea],en)}if(er.metadataProps&&er.metadataProps.length)for(ei.metadataProps=[],ea=0;ea<er.metadataProps.length;++ea)ei.metadataProps[ea]=ed.onnx.StringStringEntryProto.toObject(er.metadataProps[ea],en);return ei},er.prototype.toJSON=function(){return this.constructor.toObject(this,eu.util.toJSONOptions)},er}(),es.StringStringEntryProto=function(){function er(er){if(er)for(var en=Object.keys(er),ei=0;ei<en.length;++ei)null!=er[en[ei]]&&(this[en[ei]]=er[en[ei]])}return er.prototype.key="",er.prototype.value="",er.create=function(en){return new er(en)},er.encode=function(er,en){return en||(en=ec.create()),null!=er.key&&er.hasOwnProperty("key")&&en.uint32(10).string(er.key),null!=er.value&&er.hasOwnProperty("value")&&en.uint32(18).string(er.value),en},er.encodeDelimited=function(er,en){return this.encode(er,en).ldelim()},er.decode=function(er,en){er instanceof el||(er=el.create(er));for(var ei=void 0===en?er.len:er.pos+en,eo=new ed.onnx.StringStringEntryProto;er.pos<ei;){var ea=er.uint32();switch(ea>>>3){case 1:eo.key=er.string();break;case 2:eo.value=er.string();break;default:er.skipType(7&ea)}}return eo},er.decodeDelimited=function(er){return er instanceof el||(er=new el(er)),this.decode(er,er.uint32())},er.verify=function(er){return"object"!=typeof er||null===er?"object expected":null!=er.key&&er.hasOwnProperty("key")&&!ep.isString(er.key)?"key: string expected":null!=er.value&&er.hasOwnProperty("value")&&!ep.isString(er.value)?"value: string expected":null},er.fromObject=function(er){if(er instanceof ed.onnx.StringStringEntryProto)return er;var en=new ed.onnx.StringStringEntryProto;return null!=er.key&&(en.key=String(er.key)),null!=er.value&&(en.value=String(er.value)),en},er.toObject=function(er,en){en||(en={});var ei={};return en.defaults&&(ei.key="",ei.value=""),null!=er.key&&er.hasOwnProperty("key")&&(ei.key=er.key),null!=er.value&&er.hasOwnProperty("value")&&(ei.value=er.value),ei},er.prototype.toJSON=function(){return this.constructor.toObject(this,eu.util.toJSONOptions)},er}(),es.TensorAnnotation=function(){function er(er){if(this.quantParameterTensorNames=[],er)for(var en=Object.keys(er),ei=0;ei<en.length;++ei)null!=er[en[ei]]&&(this[en[ei]]=er[en[ei]])}return er.prototype.tensorName="",er.prototype.quantParameterTensorNames=ep.emptyArray,er.create=function(en){return new er(en)},er.encode=function(er,en){if(en||(en=ec.create()),null!=er.tensorName&&er.hasOwnProperty("tensorName")&&en.uint32(10).string(er.tensorName),null!=er.quantParameterTensorNames&&er.quantParameterTensorNames.length)for(var ei=0;ei<er.quantParameterTensorNames.length;++ei)ed.onnx.StringStringEntryProto.encode(er.quantParameterTensorNames[ei],en.uint32(18).fork()).ldelim();return en},er.encodeDelimited=function(er,en){return this.encode(er,en).ldelim()},er.decode=function(er,en){er instanceof el||(er=el.create(er));for(var ei=void 0===en?er.len:er.pos+en,eo=new ed.onnx.TensorAnnotation;er.pos<ei;){var ea=er.uint32();switch(ea>>>3){case 1:eo.tensorName=er.string();break;case 2:eo.quantParameterTensorNames&&eo.quantParameterTensorNames.length||(eo.quantParameterTensorNames=[]),eo.quantParameterTensorNames.push(ed.onnx.StringStringEntryProto.decode(er,er.uint32()));break;default:er.skipType(7&ea)}}return eo},er.decodeDelimited=function(er){return er instanceof el||(er=new el(er)),this.decode(er,er.uint32())},er.verify=function(er){if("object"!=typeof er||null===er)return"object expected";if(null!=er.tensorName&&er.hasOwnProperty("tensorName")&&!ep.isString(er.tensorName))return"tensorName: string expected";if(null!=er.quantParameterTensorNames&&er.hasOwnProperty("quantParameterTensorNames")){if(!Array.isArray(er.quantParameterTensorNames))return"quantParameterTensorNames: array expected";for(var en=0;en<er.quantParameterTensorNames.length;++en){var ei=ed.onnx.StringStringEntryProto.verify(er.quantParameterTensorNames[en]);if(ei)return"quantParameterTensorNames."+ei}}return null},er.fromObject=function(er){if(er instanceof ed.onnx.TensorAnnotation)return er;var en=new ed.onnx.TensorAnnotation;if(null!=er.tensorName&&(en.tensorName=String(er.tensorName)),er.quantParameterTensorNames){if(!Array.isArray(er.quantParameterTensorNames))throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: array expected");en.quantParameterTensorNames=[];for(var ei=0;ei<er.quantParameterTensorNames.length;++ei){if("object"!=typeof er.quantParameterTensorNames[ei])throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: object expected");en.quantParameterTensorNames[ei]=ed.onnx.StringStringEntryProto.fromObject(er.quantParameterTensorNames[ei])}}return en},er.toObject=function(er,en){en||(en={});var ei={};if((en.arrays||en.defaults)&&(ei.quantParameterTensorNames=[]),en.defaults&&(ei.tensorName=""),null!=er.tensorName&&er.hasOwnProperty("tensorName")&&(ei.tensorName=er.tensorName),er.quantParameterTensorNames&&er.quantParameterTensorNames.length){ei.quantParameterTensorNames=[];for(var eo=0;eo<er.quantParameterTensorNames.length;++eo)ei.quantParameterTensorNames[eo]=ed.onnx.StringStringEntryProto.toObject(er.quantParameterTensorNames[eo],en)}return ei},er.prototype.toJSON=function(){return this.constructor.toObject(this,eu.util.toJSONOptions)},er}(),es.GraphProto=function(){function er(er){if(this.node=[],this.initializer=[],this.input=[],this.output=[],this.valueInfo=[],this.quantizationAnnotation=[],er)for(var en=Object.keys(er),ei=0;ei<en.length;++ei)null!=er[en[ei]]&&(this[en[ei]]=er[en[ei]])}return er.prototype.node=ep.emptyArray,er.prototype.name="",er.prototype.initializer=ep.emptyArray,er.prototype.docString="",er.prototype.input=ep.emptyArray,er.prototype.output=ep.emptyArray,er.prototype.valueInfo=ep.emptyArray,er.prototype.quantizationAnnotation=ep.emptyArray,er.create=function(en){return new er(en)},er.encode=function(er,en){if(en||(en=ec.create()),null!=er.node&&er.node.length)for(var ei=0;ei<er.node.length;++ei)ed.onnx.NodeProto.encode(er.node[ei],en.uint32(10).fork()).ldelim();if(null!=er.name&&er.hasOwnProperty("name")&&en.uint32(18).string(er.name),null!=er.initializer&&er.initializer.length)for(ei=0;ei<er.initializer.length;++ei)ed.onnx.TensorProto.encode(er.initializer[ei],en.uint32(42).fork()).ldelim();if(null!=er.docString&&er.hasOwnProperty("docString")&&en.uint32(82).string(er.docString),null!=er.input&&er.input.length)for(ei=0;ei<er.input.length;++ei)ed.onnx.ValueInfoProto.encode(er.input[ei],en.uint32(90).fork()).ldelim();if(null!=er.output&&er.output.length)for(ei=0;ei<er.output.length;++ei)ed.onnx.ValueInfoProto.encode(er.output[ei],en.uint32(98).fork()).ldelim();if(null!=er.valueInfo&&er.valueInfo.length)for(ei=0;ei<er.valueInfo.length;++ei)ed.onnx.ValueInfoProto.encode(er.valueInfo[ei],en.uint32(106).fork()).ldelim();if(null!=er.quantizationAnnotation&&er.quantizationAnnotation.length)for(ei=0;ei<er.quantizationAnnotation.length;++ei)ed.onnx.TensorAnnotation.encode(er.quantizationAnnotation[ei],en.uint32(114).fork()).ldelim();return en},er.encodeDelimited=function(er,en){return this.encode(er,en).ldelim()},er.decode=function(er,en){er instanceof el||(er=el.create(er));for(var ei=void 0===en?er.len:er.pos+en,eo=new ed.onnx.GraphProto;er.pos<ei;){var ea=er.uint32();switch(ea>>>3){case 1:eo.node&&eo.node.length||(eo.node=[]),eo.node.push(ed.onnx.NodeProto.decode(er,er.uint32()));break;case 2:eo.name=er.string();break;case 5:eo.initializer&&eo.initializer.length||(eo.initializer=[]),eo.initializer.push(ed.onnx.TensorProto.decode(er,er.uint32()));break;case 10:eo.docString=er.string();break;case 11:eo.input&&eo.input.length||(eo.input=[]),eo.input.push(ed.onnx.ValueInfoProto.decode(er,er.uint32()));break;case 12:eo.output&&eo.output.length||(eo.output=[]),eo.output.push(ed.onnx.ValueInfoProto.decode(er,er.uint32()));break;case 13:eo.valueInfo&&eo.valueInfo.length||(eo.valueInfo=[]),eo.valueInfo.push(ed.onnx.ValueInfoProto.decode(er,er.uint32()));break;case 14:eo.quantizationAnnotation&&eo.quantizationAnnotation.length||(eo.quantizationAnnotation=[]),eo.quantizationAnnotation.push(ed.onnx.TensorAnnotation.decode(er,er.uint32()));break;default:er.skipType(7&ea)}}return eo},er.decodeDelimited=function(er){return er instanceof el||(er=new el(er)),this.decode(er,er.uint32())},er.verify=function(er){if("object"!=typeof er||null===er)return"object expected";if(null!=er.node&&er.hasOwnProperty("node")){if(!Array.isArray(er.node))return"node: array expected";for(var en,ei=0;ei<er.node.length;++ei)if(en=ed.onnx.NodeProto.verify(er.node[ei]))return"node."+en}if(null!=er.name&&er.hasOwnProperty("name")&&!ep.isString(er.name))return"name: string expected";if(null!=er.initializer&&er.hasOwnProperty("initializer")){if(!Array.isArray(er.initializer))return"initializer: array expected";for(ei=0;ei<er.initializer.length;++ei)if(en=ed.onnx.TensorProto.verify(er.initializer[ei]))return"initializer."+en}if(null!=er.docString&&er.hasOwnProperty("docString")&&!ep.isString(er.docString))return"docString: string expected";if(null!=er.input&&er.hasOwnProperty("input")){if(!Array.isArray(er.input))return"input: array expected";for(ei=0;ei<er.input.length;++ei)if(en=ed.onnx.ValueInfoProto.verify(er.input[ei]))return"input."+en}if(null!=er.output&&er.hasOwnProperty("output")){if(!Array.isArray(er.output))return"output: array expected";for(ei=0;ei<er.output.length;++ei)if(en=ed.onnx.ValueInfoProto.verify(er.output[ei]))return"output."+en}if(null!=er.valueInfo&&er.hasOwnProperty("valueInfo")){if(!Array.isArray(er.valueInfo))return"valueInfo: array expected";for(ei=0;ei<er.valueInfo.length;++ei)if(en=ed.onnx.ValueInfoProto.verify(er.valueInfo[ei]))return"valueInfo."+en}if(null!=er.quantizationAnnotation&&er.hasOwnProperty("quantizationAnnotation")){if(!Array.isArray(er.quantizationAnnotation))return"quantizationAnnotation: array expected";for(ei=0;ei<er.quantizationAnnotation.length;++ei)if(en=ed.onnx.TensorAnnotation.verify(er.quantizationAnnotation[ei]))return"quantizationAnnotation."+en}return null},er.fromObject=function(er){if(er instanceof ed.onnx.GraphProto)return er;var en=new ed.onnx.GraphProto;if(er.node){if(!Array.isArray(er.node))throw TypeError(".onnx.GraphProto.node: array expected");en.node=[];for(var ei=0;ei<er.node.length;++ei){if("object"!=typeof er.node[ei])throw TypeError(".onnx.GraphProto.node: object expected");en.node[ei]=ed.onnx.NodeProto.fromObject(er.node[ei])}}if(null!=er.name&&(en.name=String(er.name)),er.initializer){if(!Array.isArray(er.initializer))throw TypeError(".onnx.GraphProto.initializer: array expected");for(en.initializer=[],ei=0;ei<er.initializer.length;++ei){if("object"!=typeof er.initializer[ei])throw TypeError(".onnx.GraphProto.initializer: object expected");en.initializer[ei]=ed.onnx.TensorProto.fromObject(er.initializer[ei])}}if(null!=er.docString&&(en.docString=String(er.docString)),er.input){if(!Array.isArray(er.input))throw TypeError(".onnx.GraphProto.input: array expected");for(en.input=[],ei=0;ei<er.input.length;++ei){if("object"!=typeof er.input[ei])throw TypeError(".onnx.GraphProto.input: object expected");en.input[ei]=ed.onnx.ValueInfoProto.fromObject(er.input[ei])}}if(er.output){if(!Array.isArray(er.output))throw TypeError(".onnx.GraphProto.output: array expected");for(en.output=[],ei=0;ei<er.output.length;++ei){if("object"!=typeof er.output[ei])throw TypeError(".onnx.GraphProto.output: object expected");en.output[ei]=ed.onnx.ValueInfoProto.fromObject(er.output[ei])}}if(er.valueInfo){if(!Array.isArray(er.valueInfo))throw TypeError(".onnx.GraphProto.valueInfo: array expected");for(en.valueInfo=[],ei=0;ei<er.valueInfo.length;++ei){if("object"!=typeof er.valueInfo[ei])throw TypeError(".onnx.GraphProto.valueInfo: object expected");en.valueInfo[ei]=ed.onnx.ValueInfoProto.fromObject(er.valueInfo[ei])}}if(er.quantizationAnnotation){if(!Array.isArray(er.quantizationAnnotation))throw TypeError(".onnx.GraphProto.quantizationAnnotation: array expected");for(en.quantizationAnnotation=[],ei=0;ei<er.quantizationAnnotation.length;++ei){if("object"!=typeof er.quantizationAnnotation[ei])throw TypeError(".onnx.GraphProto.quantizationAnnotation: object expected");en.quantizationAnnotation[ei]=ed.onnx.TensorAnnotation.fromObject(er.quantizationAnnotation[ei])}}return en},er.toObject=function(er,en){en||(en={});var ei={};if((en.arrays||en.defaults)&&(ei.node=[],ei.initializer=[],ei.input=[],ei.output=[],ei.valueInfo=[],ei.quantizationAnnotation=[]),en.defaults&&(ei.name="",ei.docString=""),er.node&&er.node.length){ei.node=[];for(var eo=0;eo<er.node.length;++eo)ei.node[eo]=ed.onnx.NodeProto.toObject(er.node[eo],en)}if(null!=er.name&&er.hasOwnProperty("name")&&(ei.name=er.name),er.initializer&&er.initializer.length)for(ei.initializer=[],eo=0;eo<er.initializer.length;++eo)ei.initializer[eo]=ed.onnx.TensorProto.toObject(er.initializer[eo],en);if(null!=er.docString&&er.hasOwnProperty("docString")&&(ei.docString=er.docString),er.input&&er.input.length)for(ei.input=[],eo=0;eo<er.input.length;++eo)ei.input[eo]=ed.onnx.ValueInfoProto.toObject(er.input[eo],en);if(er.output&&er.output.length)for(ei.output=[],eo=0;eo<er.output.length;++eo)ei.output[eo]=ed.onnx.ValueInfoProto.toObject(er.output[eo],en);if(er.valueInfo&&er.valueInfo.length)for(ei.valueInfo=[],eo=0;eo<er.valueInfo.length;++eo)ei.valueInfo[eo]=ed.onnx.ValueInfoProto.toObject(er.valueInfo[eo],en);if(er.quantizationAnnotation&&er.quantizationAnnotation.length)for(ei.quantizationAnnotation=[],eo=0;eo<er.quantizationAnnotation.length;++eo)ei.quantizationAnnotation[eo]=ed.onnx.TensorAnnotation.toObject(er.quantizationAnnotation[eo],en);return ei},er.prototype.toJSON=function(){return this.constructor.toObject(this,eu.util.toJSONOptions)},er}(),es.TensorProto=function(){function er(er){if(this.dims=[],this.floatData=[],this.int32Data=[],this.stringData=[],this.int64Data=[],this.externalData=[],this.doubleData=[],this.uint64Data=[],er)for(var en=Object.keys(er),ei=0;ei<en.length;++ei)null!=er[en[ei]]&&(this[en[ei]]=er[en[ei]])}return er.prototype.dims=ep.emptyArray,er.prototype.dataType=0,er.prototype.segment=null,er.prototype.floatData=ep.emptyArray,er.prototype.int32Data=ep.emptyArray,er.prototype.stringData=ep.emptyArray,er.prototype.int64Data=ep.emptyArray,er.prototype.name="",er.prototype.docString="",er.prototype.rawData=ep.newBuffer([]),er.prototype.externalData=ep.emptyArray,er.prototype.dataLocation=0,er.prototype.doubleData=ep.emptyArray,er.prototype.uint64Data=ep.emptyArray,er.create=function(en){return new er(en)},er.encode=function(er,en){if(en||(en=ec.create()),null!=er.dims&&er.dims.length){en.uint32(10).fork();for(var ei=0;ei<er.dims.length;++ei)en.int64(er.dims[ei]);en.ldelim()}if(null!=er.dataType&&er.hasOwnProperty("dataType")&&en.uint32(16).int32(er.dataType),null!=er.segment&&er.hasOwnProperty("segment")&&ed.onnx.TensorProto.Segment.encode(er.segment,en.uint32(26).fork()).ldelim(),null!=er.floatData&&er.floatData.length){for(en.uint32(34).fork(),ei=0;ei<er.floatData.length;++ei)en.float(er.floatData[ei]);en.ldelim()}if(null!=er.int32Data&&er.int32Data.length){for(en.uint32(42).fork(),ei=0;ei<er.int32Data.length;++ei)en.int32(er.int32Data[ei]);en.ldelim()}if(null!=er.stringData&&er.stringData.length)for(ei=0;ei<er.stringData.length;++ei)en.uint32(50).bytes(er.stringData[ei]);if(null!=er.int64Data&&er.int64Data.length){for(en.uint32(58).fork(),ei=0;ei<er.int64Data.length;++ei)en.int64(er.int64Data[ei]);en.ldelim()}if(null!=er.name&&er.hasOwnProperty("name")&&en.uint32(66).string(er.name),null!=er.rawData&&er.hasOwnProperty("rawData")&&en.uint32(74).bytes(er.rawData),null!=er.doubleData&&er.doubleData.length){for(en.uint32(82).fork(),ei=0;ei<er.doubleData.length;++ei)en.double(er.doubleData[ei]);en.ldelim()}if(null!=er.uint64Data&&er.uint64Data.length){for(en.uint32(90).fork(),ei=0;ei<er.uint64Data.length;++ei)en.uint64(er.uint64Data[ei]);en.ldelim()}if(null!=er.docString&&er.hasOwnProperty("docString")&&en.uint32(98).string(er.docString),null!=er.externalData&&er.externalData.length)for(ei=0;ei<er.externalData.length;++ei)ed.onnx.StringStringEntryProto.encode(er.externalData[ei],en.uint32(106).fork()).ldelim();return null!=er.dataLocation&&er.hasOwnProperty("dataLocation")&&en.uint32(112).int32(er.dataLocation),en},er.encodeDelimited=function(er,en){return this.encode(er,en).ldelim()},er.decode=function(er,en){er instanceof el||(er=el.create(er));for(var ei=void 0===en?er.len:er.pos+en,eo=new ed.onnx.TensorProto;er.pos<ei;){var ea=er.uint32();switch(ea>>>3){case 1:if(eo.dims&&eo.dims.length||(eo.dims=[]),2==(7&ea))for(var es=er.uint32()+er.pos;er.pos<es;)eo.dims.push(er.int64());else eo.dims.push(er.int64());break;case 2:eo.dataType=er.int32();break;case 3:eo.segment=ed.onnx.TensorProto.Segment.decode(er,er.uint32());break;case 4:if(eo.floatData&&eo.floatData.length||(eo.floatData=[]),2==(7&ea))for(es=er.uint32()+er.pos;er.pos<es;)eo.floatData.push(er.float());else eo.floatData.push(er.float());break;case 5:if(eo.int32Data&&eo.int32Data.length||(eo.int32Data=[]),2==(7&ea))for(es=er.uint32()+er.pos;er.pos<es;)eo.int32Data.push(er.int32());else eo.int32Data.push(er.int32());break;case 6:eo.stringData&&eo.stringData.length||(eo.stringData=[]),eo.stringData.push(er.bytes());break;case 7:if(eo.int64Data&&eo.int64Data.length||(eo.int64Data=[]),2==(7&ea))for(es=er.uint32()+er.pos;er.pos<es;)eo.int64Data.push(er.int64());else eo.int64Data.push(er.int64());break;case 8:eo.name=er.string();break;case 12:eo.docString=er.string();break;case 9:eo.rawData=er.bytes();break;case 13:eo.externalData&&eo.externalData.length||(eo.externalData=[]),eo.externalData.push(ed.onnx.StringStringEntryProto.decode(er,er.uint32()));break;case 14:eo.dataLocation=er.int32();break;case 10:if(eo.doubleData&&eo.doubleData.length||(eo.doubleData=[]),2==(7&ea))for(es=er.uint32()+er.pos;er.pos<es;)eo.doubleData.push(er.double());else eo.doubleData.push(er.double());break;case 11:if(eo.uint64Data&&eo.uint64Data.length||(eo.uint64Data=[]),2==(7&ea))for(es=er.uint32()+er.pos;er.pos<es;)eo.uint64Data.push(er.uint64());else eo.uint64Data.push(er.uint64());break;default:er.skipType(7&ea)}}return eo},er.decodeDelimited=function(er){return er instanceof el||(er=new el(er)),this.decode(er,er.uint32())},er.verify=function(er){if("object"!=typeof er||null===er)return"object expected";if(null!=er.dims&&er.hasOwnProperty("dims")){if(!Array.isArray(er.dims))return"dims: array expected";for(var en,ei=0;ei<er.dims.length;++ei)if(!(ep.isInteger(er.dims[ei])||er.dims[ei]&&ep.isInteger(er.dims[ei].low)&&ep.isInteger(er.dims[ei].high)))return"dims: integer|Long[] expected"}if(null!=er.dataType&&er.hasOwnProperty("dataType")&&!ep.isInteger(er.dataType))return"dataType: integer expected";if(null!=er.segment&&er.hasOwnProperty("segment")&&(en=ed.onnx.TensorProto.Segment.verify(er.segment)))return"segment."+en;if(null!=er.floatData&&er.hasOwnProperty("floatData")){if(!Array.isArray(er.floatData))return"floatData: array expected";for(ei=0;ei<er.floatData.length;++ei)if("number"!=typeof er.floatData[ei])return"floatData: number[] expected"}if(null!=er.int32Data&&er.hasOwnProperty("int32Data")){if(!Array.isArray(er.int32Data))return"int32Data: array expected";for(ei=0;ei<er.int32Data.length;++ei)if(!ep.isInteger(er.int32Data[ei]))return"int32Data: integer[] expected"}if(null!=er.stringData&&er.hasOwnProperty("stringData")){if(!Array.isArray(er.stringData))return"stringData: array expected";for(ei=0;ei<er.stringData.length;++ei)if(!(er.stringData[ei]&&"number"==typeof er.stringData[ei].length||ep.isString(er.stringData[ei])))return"stringData: buffer[] expected"}if(null!=er.int64Data&&er.hasOwnProperty("int64Data")){if(!Array.isArray(er.int64Data))return"int64Data: array expected";for(ei=0;ei<er.int64Data.length;++ei)if(!(ep.isInteger(er.int64Data[ei])||er.int64Data[ei]&&ep.isInteger(er.int64Data[ei].low)&&ep.isInteger(er.int64Data[ei].high)))return"int64Data: integer|Long[] expected"}if(null!=er.name&&er.hasOwnProperty("name")&&!ep.isString(er.name))return"name: string expected";if(null!=er.docString&&er.hasOwnProperty("docString")&&!ep.isString(er.docString))return"docString: string expected";if(null!=er.rawData&&er.hasOwnProperty("rawData")&&!(er.rawData&&"number"==typeof er.rawData.length||ep.isString(er.rawData)))return"rawData: buffer expected";if(null!=er.externalData&&er.hasOwnProperty("externalData")){if(!Array.isArray(er.externalData))return"externalData: array expected";for(ei=0;ei<er.externalData.length;++ei)if(en=ed.onnx.StringStringEntryProto.verify(er.externalData[ei]))return"externalData."+en}if(null!=er.dataLocation&&er.hasOwnProperty("dataLocation"))switch(er.dataLocation){default:return"dataLocation: enum value expected";case 0:case 1:}if(null!=er.doubleData&&er.hasOwnProperty("doubleData")){if(!Array.isArray(er.doubleData))return"doubleData: array expected";for(ei=0;ei<er.doubleData.length;++ei)if("number"!=typeof er.doubleData[ei])return"doubleData: number[] expected"}if(null!=er.uint64Data&&er.hasOwnProperty("uint64Data")){if(!Array.isArray(er.uint64Data))return"uint64Data: array expected";for(ei=0;ei<er.uint64Data.length;++ei)if(!(ep.isInteger(er.uint64Data[ei])||er.uint64Data[ei]&&ep.isInteger(er.uint64Data[ei].low)&&ep.isInteger(er.uint64Data[ei].high)))return"uint64Data: integer|Long[] expected"}return null},er.fromObject=function(er){if(er instanceof ed.onnx.TensorProto)return er;var en=new ed.onnx.TensorProto;if(er.dims){if(!Array.isArray(er.dims))throw TypeError(".onnx.TensorProto.dims: array expected");en.dims=[];for(var ei=0;ei<er.dims.length;++ei)ep.Long?(en.dims[ei]=ep.Long.fromValue(er.dims[ei])).unsigned=!1:"string"==typeof er.dims[ei]?en.dims[ei]=parseInt(er.dims[ei],10):"number"==typeof er.dims[ei]?en.dims[ei]=er.dims[ei]:"object"==typeof er.dims[ei]&&(en.dims[ei]=new ep.LongBits(er.dims[ei].low>>>0,er.dims[ei].high>>>0).toNumber())}if(null!=er.dataType&&(en.dataType=0|er.dataType),null!=er.segment){if("object"!=typeof er.segment)throw TypeError(".onnx.TensorProto.segment: object expected");en.segment=ed.onnx.TensorProto.Segment.fromObject(er.segment)}if(er.floatData){if(!Array.isArray(er.floatData))throw TypeError(".onnx.TensorProto.floatData: array expected");for(en.floatData=[],ei=0;ei<er.floatData.length;++ei)en.floatData[ei]=Number(er.floatData[ei])}if(er.int32Data){if(!Array.isArray(er.int32Data))throw TypeError(".onnx.TensorProto.int32Data: array expected");for(en.int32Data=[],ei=0;ei<er.int32Data.length;++ei)en.int32Data[ei]=0|er.int32Data[ei]}if(er.stringData){if(!Array.isArray(er.stringData))throw TypeError(".onnx.TensorProto.stringData: array expected");for(en.stringData=[],ei=0;ei<er.stringData.length;++ei)"string"==typeof er.stringData[ei]?ep.base64.decode(er.stringData[ei],en.stringData[ei]=ep.newBuffer(ep.base64.length(er.stringData[ei])),0):er.stringData[ei].length&&(en.stringData[ei]=er.stringData[ei])}if(er.int64Data){if(!Array.isArray(er.int64Data))throw TypeError(".onnx.TensorProto.int64Data: array expected");for(en.int64Data=[],ei=0;ei<er.int64Data.length;++ei)ep.Long?(en.int64Data[ei]=ep.Long.fromValue(er.int64Data[ei])).unsigned=!1:"string"==typeof er.int64Data[ei]?en.int64Data[ei]=parseInt(er.int64Data[ei],10):"number"==typeof er.int64Data[ei]?en.int64Data[ei]=er.int64Data[ei]:"object"==typeof er.int64Data[ei]&&(en.int64Data[ei]=new ep.LongBits(er.int64Data[ei].low>>>0,er.int64Data[ei].high>>>0).toNumber())}if(null!=er.name&&(en.name=String(er.name)),null!=er.docString&&(en.docString=String(er.docString)),null!=er.rawData&&("string"==typeof er.rawData?ep.base64.decode(er.rawData,en.rawData=ep.newBuffer(ep.base64.length(er.rawData)),0):er.rawData.length&&(en.rawData=er.rawData)),er.externalData){if(!Array.isArray(er.externalData))throw TypeError(".onnx.TensorProto.externalData: array expected");for(en.externalData=[],ei=0;ei<er.externalData.length;++ei){if("object"!=typeof er.externalData[ei])throw TypeError(".onnx.TensorProto.externalData: object expected");en.externalData[ei]=ed.onnx.StringStringEntryProto.fromObject(er.externalData[ei])}}switch(er.dataLocation){case"DEFAULT":case 0:en.dataLocation=0;break;case"EXTERNAL":case 1:en.dataLocation=1}if(er.doubleData){if(!Array.isArray(er.doubleData))throw TypeError(".onnx.TensorProto.doubleData: array expected");for(en.doubleData=[],ei=0;ei<er.doubleData.length;++ei)en.doubleData[ei]=Number(er.doubleData[ei])}if(er.uint64Data){if(!Array.isArray(er.uint64Data))throw TypeError(".onnx.TensorProto.uint64Data: array expected");for(en.uint64Data=[],ei=0;ei<er.uint64Data.length;++ei)ep.Long?(en.uint64Data[ei]=ep.Long.fromValue(er.uint64Data[ei])).unsigned=!0:"string"==typeof er.uint64Data[ei]?en.uint64Data[ei]=parseInt(er.uint64Data[ei],10):"number"==typeof er.uint64Data[ei]?en.uint64Data[ei]=er.uint64Data[ei]:"object"==typeof er.uint64Data[ei]&&(en.uint64Data[ei]=new ep.LongBits(er.uint64Data[ei].low>>>0,er.uint64Data[ei].high>>>0).toNumber(!0))}return en},er.toObject=function(er,en){en||(en={});var ei={};if((en.arrays||en.defaults)&&(ei.dims=[],ei.floatData=[],ei.int32Data=[],ei.stringData=[],ei.int64Data=[],ei.doubleData=[],ei.uint64Data=[],ei.externalData=[]),en.defaults&&(ei.dataType=0,ei.segment=null,ei.name="",en.bytes===String?ei.rawData="":(ei.rawData=[],en.bytes!==Array&&(ei.rawData=ep.newBuffer(ei.rawData))),ei.docString="",ei.dataLocation=en.enums===String?"DEFAULT":0),er.dims&&er.dims.length){ei.dims=[];for(var eo=0;eo<er.dims.length;++eo)"number"==typeof er.dims[eo]?ei.dims[eo]=en.longs===String?String(er.dims[eo]):er.dims[eo]:ei.dims[eo]=en.longs===String?ep.Long.prototype.toString.call(er.dims[eo]):en.longs===Number?new ep.LongBits(er.dims[eo].low>>>0,er.dims[eo].high>>>0).toNumber():er.dims[eo]}if(null!=er.dataType&&er.hasOwnProperty("dataType")&&(ei.dataType=er.dataType),null!=er.segment&&er.hasOwnProperty("segment")&&(ei.segment=ed.onnx.TensorProto.Segment.toObject(er.segment,en)),er.floatData&&er.floatData.length)for(ei.floatData=[],eo=0;eo<er.floatData.length;++eo)ei.floatData[eo]=en.json&&!isFinite(er.floatData[eo])?String(er.floatData[eo]):er.floatData[eo];if(er.int32Data&&er.int32Data.length)for(ei.int32Data=[],eo=0;eo<er.int32Data.length;++eo)ei.int32Data[eo]=er.int32Data[eo];if(er.stringData&&er.stringData.length)for(ei.stringData=[],eo=0;eo<er.stringData.length;++eo)ei.stringData[eo]=en.bytes===String?ep.base64.encode(er.stringData[eo],0,er.stringData[eo].length):en.bytes===Array?Array.prototype.slice.call(er.stringData[eo]):er.stringData[eo];if(er.int64Data&&er.int64Data.length)for(ei.int64Data=[],eo=0;eo<er.int64Data.length;++eo)"number"==typeof er.int64Data[eo]?ei.int64Data[eo]=en.longs===String?String(er.int64Data[eo]):er.int64Data[eo]:ei.int64Data[eo]=en.longs===String?ep.Long.prototype.toString.call(er.int64Data[eo]):en.longs===Number?new ep.LongBits(er.int64Data[eo].low>>>0,er.int64Data[eo].high>>>0).toNumber():er.int64Data[eo];if(null!=er.name&&er.hasOwnProperty("name")&&(ei.name=er.name),null!=er.rawData&&er.hasOwnProperty("rawData")&&(ei.rawData=en.bytes===String?ep.base64.encode(er.rawData,0,er.rawData.length):en.bytes===Array?Array.prototype.slice.call(er.rawData):er.rawData),er.doubleData&&er.doubleData.length)for(ei.doubleData=[],eo=0;eo<er.doubleData.length;++eo)ei.doubleData[eo]=en.json&&!isFinite(er.doubleData[eo])?String(er.doubleData[eo]):er.doubleData[eo];if(er.uint64Data&&er.uint64Data.length)for(ei.uint64Data=[],eo=0;eo<er.uint64Data.length;++eo)"number"==typeof er.uint64Data[eo]?ei.uint64Data[eo]=en.longs===String?String(er.uint64Data[eo]):er.uint64Data[eo]:ei.uint64Data[eo]=en.longs===String?ep.Long.prototype.toString.call(er.uint64Data[eo]):en.longs===Number?new ep.LongBits(er.uint64Data[eo].low>>>0,er.uint64Data[eo].high>>>0).toNumber(!0):er.uint64Data[eo];if(null!=er.docString&&er.hasOwnProperty("docString")&&(ei.docString=er.docString),er.externalData&&er.externalData.length)for(ei.externalData=[],eo=0;eo<er.externalData.length;++eo)ei.externalData[eo]=ed.onnx.StringStringEntryProto.toObject(er.externalData[eo],en);return null!=er.dataLocation&&er.hasOwnProperty("dataLocation")&&(ei.dataLocation=en.enums===String?ed.onnx.TensorProto.DataLocation[er.dataLocation]:er.dataLocation),ei},er.prototype.toJSON=function(){return this.constructor.toObject(this,eu.util.toJSONOptions)},er.DataType=function(){var er={},en=Object.create(er);return en[er[0]="UNDEFINED"]=0,en[er[1]="FLOAT"]=1,en[er[2]="UINT8"]=2,en[er[3]="INT8"]=3,en[er[4]="UINT16"]=4,en[er[5]="INT16"]=5,en[er[6]="INT32"]=6,en[er[7]="INT64"]=7,en[er[8]="STRING"]=8,en[er[9]="BOOL"]=9,en[er[10]="FLOAT16"]=10,en[er[11]="DOUBLE"]=11,en[er[12]="UINT32"]=12,en[er[13]="UINT64"]=13,en[er[14]="COMPLEX64"]=14,en[er[15]="COMPLEX128"]=15,en[er[16]="BFLOAT16"]=16,en}(),er.Segment=function(){function er(er){if(er)for(var en=Object.keys(er),ei=0;ei<en.length;++ei)null!=er[en[ei]]&&(this[en[ei]]=er[en[ei]])}return er.prototype.begin=ep.Long?ep.Long.fromBits(0,0,!1):0,er.prototype.end=ep.Long?ep.Long.fromBits(0,0,!1):0,er.create=function(en){return new er(en)},er.encode=function(er,en){return en||(en=ec.create()),null!=er.begin&&er.hasOwnProperty("begin")&&en.uint32(8).int64(er.begin),null!=er.end&&er.hasOwnProperty("end")&&en.uint32(16).int64(er.end),en},er.encodeDelimited=function(er,en){return this.encode(er,en).ldelim()},er.decode=function(er,en){er instanceof el||(er=el.create(er));for(var ei=void 0===en?er.len:er.pos+en,eo=new ed.onnx.TensorProto.Segment;er.pos<ei;){var ea=er.uint32();switch(ea>>>3){case 1:eo.begin=er.int64();break;case 2:eo.end=er.int64();break;default:er.skipType(7&ea)}}return eo},er.decodeDelimited=function(er){return er instanceof el||(er=new el(er)),this.decode(er,er.uint32())},er.verify=function(er){return"object"!=typeof er||null===er?"object expected":null!=er.begin&&er.hasOwnProperty("begin")&&!(ep.isInteger(er.begin)||er.begin&&ep.isInteger(er.begin.low)&&ep.isInteger(er.begin.high))?"begin: integer|Long expected":null!=er.end&&er.hasOwnProperty("end")&&!(ep.isInteger(er.end)||er.end&&ep.isInteger(er.end.low)&&ep.isInteger(er.end.high))?"end: integer|Long expected":null},er.fromObject=function(er){if(er instanceof ed.onnx.TensorProto.Segment)return er;var en=new ed.onnx.TensorProto.Segment;return null!=er.begin&&(ep.Long?(en.begin=ep.Long.fromValue(er.begin)).unsigned=!1:"string"==typeof er.begin?en.begin=parseInt(er.begin,10):"number"==typeof er.begin?en.begin=er.begin:"object"==typeof er.begin&&(en.begin=new ep.LongBits(er.begin.low>>>0,er.begin.high>>>0).toNumber())),null!=er.end&&(ep.Long?(en.end=ep.Long.fromValue(er.end)).unsigned=!1:"string"==typeof er.end?en.end=parseInt(er.end,10):"number"==typeof er.end?en.end=er.end:"object"==typeof er.end&&(en.end=new ep.LongBits(er.end.low>>>0,er.end.high>>>0).toNumber())),en},er.toObject=function(er,en){en||(en={});var ei={};if(en.defaults){if(ep.Long){var eo=new ep.Long(0,0,!1);ei.begin=en.longs===String?eo.toString():en.longs===Number?eo.toNumber():eo}else ei.begin=en.longs===String?"0":0;ep.Long?(eo=new ep.Long(0,0,!1),ei.end=en.longs===String?eo.toString():en.longs===Number?eo.toNumber():eo):ei.end=en.longs===String?"0":0}return null!=er.begin&&er.hasOwnProperty("begin")&&("number"==typeof er.begin?ei.begin=en.longs===String?String(er.begin):er.begin:ei.begin=en.longs===String?ep.Long.prototype.toString.call(er.begin):en.longs===Number?new ep.LongBits(er.begin.low>>>0,er.begin.high>>>0).toNumber():er.begin),null!=er.end&&er.hasOwnProperty("end")&&("number"==typeof er.end?ei.end=en.longs===String?String(er.end):er.end:ei.end=en.longs===String?ep.Long.prototype.toString.call(er.end):en.longs===Number?new ep.LongBits(er.end.low>>>0,er.end.high>>>0).toNumber():er.end),ei},er.prototype.toJSON=function(){return this.constructor.toObject(this,eu.util.toJSONOptions)},er}(),er.DataLocation=function(){var er={},en=Object.create(er);return en[er[0]="DEFAULT"]=0,en[er[1]="EXTERNAL"]=1,en}(),er}(),es.TensorShapeProto=function(){function er(er){if(this.dim=[],er)for(var en=Object.keys(er),ei=0;ei<en.length;++ei)null!=er[en[ei]]&&(this[en[ei]]=er[en[ei]])}return er.prototype.dim=ep.emptyArray,er.create=function(en){return new er(en)},er.encode=function(er,en){if(en||(en=ec.create()),null!=er.dim&&er.dim.length)for(var ei=0;ei<er.dim.length;++ei)ed.onnx.TensorShapeProto.Dimension.encode(er.dim[ei],en.uint32(10).fork()).ldelim();return en},er.encodeDelimited=function(er,en){return this.encode(er,en).ldelim()},er.decode=function(er,en){er instanceof el||(er=el.create(er));for(var ei=void 0===en?er.len:er.pos+en,eo=new ed.onnx.TensorShapeProto;er.pos<ei;){var ea=er.uint32();ea>>>3==1?(eo.dim&&eo.dim.length||(eo.dim=[]),eo.dim.push(ed.onnx.TensorShapeProto.Dimension.decode(er,er.uint32()))):er.skipType(7&ea)}return eo},er.decodeDelimited=function(er){return er instanceof el||(er=new el(er)),this.decode(er,er.uint32())},er.verify=function(er){if("object"!=typeof er||null===er)return"object expected";if(null!=er.dim&&er.hasOwnProperty("dim")){if(!Array.isArray(er.dim))return"dim: array expected";for(var en=0;en<er.dim.length;++en){var ei=ed.onnx.TensorShapeProto.Dimension.verify(er.dim[en]);if(ei)return"dim."+ei}}return null},er.fromObject=function(er){if(er instanceof ed.onnx.TensorShapeProto)return er;var en=new ed.onnx.TensorShapeProto;if(er.dim){if(!Array.isArray(er.dim))throw TypeError(".onnx.TensorShapeProto.dim: array expected");en.dim=[];for(var ei=0;ei<er.dim.length;++ei){if("object"!=typeof er.dim[ei])throw TypeError(".onnx.TensorShapeProto.dim: object expected");en.dim[ei]=ed.onnx.TensorShapeProto.Dimension.fromObject(er.dim[ei])}}return en},er.toObject=function(er,en){en||(en={});var ei={};if((en.arrays||en.defaults)&&(ei.dim=[]),er.dim&&er.dim.length){ei.dim=[];for(var eo=0;eo<er.dim.length;++eo)ei.dim[eo]=ed.onnx.TensorShapeProto.Dimension.toObject(er.dim[eo],en)}return ei},er.prototype.toJSON=function(){return this.constructor.toObject(this,eu.util.toJSONOptions)},er.Dimension=function(){var er;function en(er){if(er)for(var en=Object.keys(er),ei=0;ei<en.length;++ei)null!=er[en[ei]]&&(this[en[ei]]=er[en[ei]])}return en.prototype.dimValue=ep.Long?ep.Long.fromBits(0,0,!1):0,en.prototype.dimParam="",en.prototype.denotation="",Object.defineProperty(en.prototype,"value",{get:ep.oneOfGetter(er=["dimValue","dimParam"]),set:ep.oneOfSetter(er)}),en.create=function(er){return new en(er)},en.encode=function(er,en){return en||(en=ec.create()),null!=er.dimValue&&er.hasOwnProperty("dimValue")&&en.uint32(8).int64(er.dimValue),null!=er.dimParam&&er.hasOwnProperty("dimParam")&&en.uint32(18).string(er.dimParam),null!=er.denotation&&er.hasOwnProperty("denotation")&&en.uint32(26).string(er.denotation),en},en.encodeDelimited=function(er,en){return this.encode(er,en).ldelim()},en.decode=function(er,en){er instanceof el||(er=el.create(er));for(var ei=void 0===en?er.len:er.pos+en,eo=new ed.onnx.TensorShapeProto.Dimension;er.pos<ei;){var ea=er.uint32();switch(ea>>>3){case 1:eo.dimValue=er.int64();break;case 2:eo.dimParam=er.string();break;case 3:eo.denotation=er.string();break;default:er.skipType(7&ea)}}return eo},en.decodeDelimited=function(er){return er instanceof el||(er=new el(er)),this.decode(er,er.uint32())},en.verify=function(er){if("object"!=typeof er||null===er)return"object expected";var en={};if(null!=er.dimValue&&er.hasOwnProperty("dimValue")&&(en.value=1,!(ep.isInteger(er.dimValue)||er.dimValue&&ep.isInteger(er.dimValue.low)&&ep.isInteger(er.dimValue.high))))return"dimValue: integer|Long expected";if(null!=er.dimParam&&er.hasOwnProperty("dimParam")){if(1===en.value)return"value: multiple values";if(en.value=1,!ep.isString(er.dimParam))return"dimParam: string expected"}return null!=er.denotation&&er.hasOwnProperty("denotation")&&!ep.isString(er.denotation)?"denotation: string expected":null},en.fromObject=function(er){if(er instanceof ed.onnx.TensorShapeProto.Dimension)return er;var en=new ed.onnx.TensorShapeProto.Dimension;return null!=er.dimValue&&(ep.Long?(en.dimValue=ep.Long.fromValue(er.dimValue)).unsigned=!1:"string"==typeof er.dimValue?en.dimValue=parseInt(er.dimValue,10):"number"==typeof er.dimValue?en.dimValue=er.dimValue:"object"==typeof er.dimValue&&(en.dimValue=new ep.LongBits(er.dimValue.low>>>0,er.dimValue.high>>>0).toNumber())),null!=er.dimParam&&(en.dimParam=String(er.dimParam)),null!=er.denotation&&(en.denotation=String(er.denotation)),en},en.toObject=function(er,en){en||(en={});var ei={};return en.defaults&&(ei.denotation=""),null!=er.dimValue&&er.hasOwnProperty("dimValue")&&("number"==typeof er.dimValue?ei.dimValue=en.longs===String?String(er.dimValue):er.dimValue:ei.dimValue=en.longs===String?ep.Long.prototype.toString.call(er.dimValue):en.longs===Number?new ep.LongBits(er.dimValue.low>>>0,er.dimValue.high>>>0).toNumber():er.dimValue,en.oneofs&&(ei.value="dimValue")),null!=er.dimParam&&er.hasOwnProperty("dimParam")&&(ei.dimParam=er.dimParam,en.oneofs&&(ei.value="dimParam")),null!=er.denotation&&er.hasOwnProperty("denotation")&&(ei.denotation=er.denotation),ei},en.prototype.toJSON=function(){return this.constructor.toObject(this,eu.util.toJSONOptions)},en}(),er}(),es.TypeProto=function(){var er;function en(er){if(er)for(var en=Object.keys(er),ei=0;ei<en.length;++ei)null!=er[en[ei]]&&(this[en[ei]]=er[en[ei]])}return en.prototype.tensorType=null,en.prototype.denotation="",Object.defineProperty(en.prototype,"value",{get:ep.oneOfGetter(er=["tensorType"]),set:ep.oneOfSetter(er)}),en.create=function(er){return new en(er)},en.encode=function(er,en){return en||(en=ec.create()),null!=er.tensorType&&er.hasOwnProperty("tensorType")&&ed.onnx.TypeProto.Tensor.encode(er.tensorType,en.uint32(10).fork()).ldelim(),null!=er.denotation&&er.hasOwnProperty("denotation")&&en.uint32(50).string(er.denotation),en},en.encodeDelimited=function(er,en){return this.encode(er,en).ldelim()},en.decode=function(er,en){er instanceof el||(er=el.create(er));for(var ei=void 0===en?er.len:er.pos+en,eo=new ed.onnx.TypeProto;er.pos<ei;){var ea=er.uint32();switch(ea>>>3){case 1:eo.tensorType=ed.onnx.TypeProto.Tensor.decode(er,er.uint32());break;case 6:eo.denotation=er.string();break;default:er.skipType(7&ea)}}return eo},en.decodeDelimited=function(er){return er instanceof el||(er=new el(er)),this.decode(er,er.uint32())},en.verify=function(er){if("object"!=typeof er||null===er)return"object expected";if(null!=er.tensorType&&er.hasOwnProperty("tensorType")){var en=ed.onnx.TypeProto.Tensor.verify(er.tensorType);if(en)return"tensorType."+en}return null!=er.denotation&&er.hasOwnProperty("denotation")&&!ep.isString(er.denotation)?"denotation: string expected":null},en.fromObject=function(er){if(er instanceof ed.onnx.TypeProto)return er;var en=new ed.onnx.TypeProto;if(null!=er.tensorType){if("object"!=typeof er.tensorType)throw TypeError(".onnx.TypeProto.tensorType: object expected");en.tensorType=ed.onnx.TypeProto.Tensor.fromObject(er.tensorType)}return null!=er.denotation&&(en.denotation=String(er.denotation)),en},en.toObject=function(er,en){en||(en={});var ei={};return en.defaults&&(ei.denotation=""),null!=er.tensorType&&er.hasOwnProperty("tensorType")&&(ei.tensorType=ed.onnx.TypeProto.Tensor.toObject(er.tensorType,en),en.oneofs&&(ei.value="tensorType")),null!=er.denotation&&er.hasOwnProperty("denotation")&&(ei.denotation=er.denotation),ei},en.prototype.toJSON=function(){return this.constructor.toObject(this,eu.util.toJSONOptions)},en.Tensor=function(){function er(er){if(er)for(var en=Object.keys(er),ei=0;ei<en.length;++ei)null!=er[en[ei]]&&(this[en[ei]]=er[en[ei]])}return er.prototype.elemType=0,er.prototype.shape=null,er.create=function(en){return new er(en)},er.encode=function(er,en){return en||(en=ec.create()),null!=er.elemType&&er.hasOwnProperty("elemType")&&en.uint32(8).int32(er.elemType),null!=er.shape&&er.hasOwnProperty("shape")&&ed.onnx.TensorShapeProto.encode(er.shape,en.uint32(18).fork()).ldelim(),en},er.encodeDelimited=function(er,en){return this.encode(er,en).ldelim()},er.decode=function(er,en){er instanceof el||(er=el.create(er));for(var ei=void 0===en?er.len:er.pos+en,eo=new ed.onnx.TypeProto.Tensor;er.pos<ei;){var ea=er.uint32();switch(ea>>>3){case 1:eo.elemType=er.int32();break;case 2:eo.shape=ed.onnx.TensorShapeProto.decode(er,er.uint32());break;default:er.skipType(7&ea)}}return eo},er.decodeDelimited=function(er){return er instanceof el||(er=new el(er)),this.decode(er,er.uint32())},er.verify=function(er){if("object"!=typeof er||null===er)return"object expected";if(null!=er.elemType&&er.hasOwnProperty("elemType")&&!ep.isInteger(er.elemType))return"elemType: integer expected";if(null!=er.shape&&er.hasOwnProperty("shape")){var en=ed.onnx.TensorShapeProto.verify(er.shape);if(en)return"shape."+en}return null},er.fromObject=function(er){if(er instanceof ed.onnx.TypeProto.Tensor)return er;var en=new ed.onnx.TypeProto.Tensor;if(null!=er.elemType&&(en.elemType=0|er.elemType),null!=er.shape){if("object"!=typeof er.shape)throw TypeError(".onnx.TypeProto.Tensor.shape: object expected");en.shape=ed.onnx.TensorShapeProto.fromObject(er.shape)}return en},er.toObject=function(er,en){en||(en={});var ei={};return en.defaults&&(ei.elemType=0,ei.shape=null),null!=er.elemType&&er.hasOwnProperty("elemType")&&(ei.elemType=er.elemType),null!=er.shape&&er.hasOwnProperty("shape")&&(ei.shape=ed.onnx.TensorShapeProto.toObject(er.shape,en)),ei},er.prototype.toJSON=function(){return this.constructor.toObject(this,eu.util.toJSONOptions)},er}(),en}(),es.OperatorSetIdProto=function(){function er(er){if(er)for(var en=Object.keys(er),ei=0;ei<en.length;++ei)null!=er[en[ei]]&&(this[en[ei]]=er[en[ei]])}return er.prototype.domain="",er.prototype.version=ep.Long?ep.Long.fromBits(0,0,!1):0,er.create=function(en){return new er(en)},er.encode=function(er,en){return en||(en=ec.create()),null!=er.domain&&er.hasOwnProperty("domain")&&en.uint32(10).string(er.domain),null!=er.version&&er.hasOwnProperty("version")&&en.uint32(16).int64(er.version),en},er.encodeDelimited=function(er,en){return this.encode(er,en).ldelim()},er.decode=function(er,en){er instanceof el||(er=el.create(er));for(var ei=void 0===en?er.len:er.pos+en,eo=new ed.onnx.OperatorSetIdProto;er.pos<ei;){var ea=er.uint32();switch(ea>>>3){case 1:eo.domain=er.string();break;case 2:eo.version=er.int64();break;default:er.skipType(7&ea)}}return eo},er.decodeDelimited=function(er){return er instanceof el||(er=new el(er)),this.decode(er,er.uint32())},er.verify=function(er){return"object"!=typeof er||null===er?"object expected":null!=er.domain&&er.hasOwnProperty("domain")&&!ep.isString(er.domain)?"domain: string expected":null!=er.version&&er.hasOwnProperty("version")&&!(ep.isInteger(er.version)||er.version&&ep.isInteger(er.version.low)&&ep.isInteger(er.version.high))?"version: integer|Long expected":null},er.fromObject=function(er){if(er instanceof ed.onnx.OperatorSetIdProto)return er;var en=new ed.onnx.OperatorSetIdProto;return null!=er.domain&&(en.domain=String(er.domain)),null!=er.version&&(ep.Long?(en.version=ep.Long.fromValue(er.version)).unsigned=!1:"string"==typeof er.version?en.version=parseInt(er.version,10):"number"==typeof er.version?en.version=er.version:"object"==typeof er.version&&(en.version=new ep.LongBits(er.version.low>>>0,er.version.high>>>0).toNumber())),en},er.toObject=function(er,en){en||(en={});var ei={};if(en.defaults){if(ei.domain="",ep.Long){var eo=new ep.Long(0,0,!1);ei.version=en.longs===String?eo.toString():en.longs===Number?eo.toNumber():eo}else ei.version=en.longs===String?"0":0}return null!=er.domain&&er.hasOwnProperty("domain")&&(ei.domain=er.domain),null!=er.version&&er.hasOwnProperty("version")&&("number"==typeof er.version?ei.version=en.longs===String?String(er.version):er.version:ei.version=en.longs===String?ep.Long.prototype.toString.call(er.version):en.longs===Number?new ep.LongBits(er.version.low>>>0,er.version.high>>>0).toNumber():er.version),ei},er.prototype.toJSON=function(){return this.constructor.toObject(this,eu.util.toJSONOptions)},er}(),es),er.exports=ed},2100:(er,en,ei)=>{"use strict";er.exports=ei(9482)},9482:(er,en,ei)=>{"use strict";var eo=en;function ea(){eo.util._configure(),eo.Writer._configure(eo.BufferWriter),eo.Reader._configure(eo.BufferReader)}eo.build="minimal",eo.Writer=ei(1173),eo.BufferWriter=ei(3155),eo.Reader=ei(1408),eo.BufferReader=ei(593),eo.util=ei(9693),eo.rpc=ei(5994),eo.roots=ei(5054),eo.configure=ea,ea()},1408:(er,en,ei)=>{"use strict";er.exports=ec;var eo,ea=ei(9693),es=ea.LongBits,eu=ea.utf8;function el(er,en){return RangeError("index out of range: "+er.pos+" + "+(en||1)+" > "+er.len)}function ec(er){this.buf=er,this.pos=0,this.len=er.length}var ep,ed="undefined"!=typeof Uint8Array?function(er){if(er instanceof Uint8Array||Array.isArray(er))return new ec(er);throw Error("illegal buffer")}:function(er){if(Array.isArray(er))return new ec(er);throw Error("illegal buffer")},ef=function(){return ea.Buffer?function(er){return(ec.create=function(er){return ea.Buffer.isBuffer(er)?new eo(er):ed(er)})(er)}:ed};function eh(){var er=new es(0,0),en=0;if(!(this.len-this.pos>4)){for(;en<3;++en){if(this.pos>=this.len)throw el(this);if(er.lo=(er.lo|(127&this.buf[this.pos])<<7*en)>>>0,this.buf[this.pos++]<128)return er}return er.lo=(er.lo|(127&this.buf[this.pos++])<<7*en)>>>0,er}for(;en<4;++en)if(er.lo=(er.lo|(127&this.buf[this.pos])<<7*en)>>>0,this.buf[this.pos++]<128)return er;if(er.lo=(er.lo|(127&this.buf[this.pos])<<28)>>>0,er.hi=(er.hi|(127&this.buf[this.pos])>>4)>>>0,this.buf[this.pos++]<128)return er;if(en=0,this.len-this.pos>4){for(;en<5;++en)if(er.hi=(er.hi|(127&this.buf[this.pos])<<7*en+3)>>>0,this.buf[this.pos++]<128)return er}else for(;en<5;++en){if(this.pos>=this.len)throw el(this);if(er.hi=(er.hi|(127&this.buf[this.pos])<<7*en+3)>>>0,this.buf[this.pos++]<128)return er}throw Error("invalid varint encoding")}function eg(er,en){return(er[en-4]|er[en-3]<<8|er[en-2]<<16|er[en-1]<<24)>>>0}function em(){if(this.pos+8>this.len)throw el(this,8);return new es(eg(this.buf,this.pos+=4),eg(this.buf,this.pos+=4))}ec.create=ef(),ec.prototype._slice=ea.Array.prototype.subarray||ea.Array.prototype.slice,ec.prototype.uint32=(ep=4294967295,function(){if(ep=(127&this.buf[this.pos])>>>0,this.buf[this.pos++]<128||(ep=(ep|(127&this.buf[this.pos])<<7)>>>0,this.buf[this.pos++]<128)||(ep=(ep|(127&this.buf[this.pos])<<14)>>>0,this.buf[this.pos++]<128)||(ep=(ep|(127&this.buf[this.pos])<<21)>>>0,this.buf[this.pos++]<128)||(ep=(ep|(15&this.buf[this.pos])<<28)>>>0,this.buf[this.pos++]<128))return ep;if((this.pos+=5)>this.len)throw this.pos=this.len,el(this,10);return ep}),ec.prototype.int32=function(){return 0|this.uint32()},ec.prototype.sint32=function(){var er=this.uint32();return er>>>1^-(1&er)|0},ec.prototype.bool=function(){return 0!==this.uint32()},ec.prototype.fixed32=function(){if(this.pos+4>this.len)throw el(this,4);return eg(this.buf,this.pos+=4)},ec.prototype.sfixed32=function(){if(this.pos+4>this.len)throw el(this,4);return 0|eg(this.buf,this.pos+=4)},ec.prototype.float=function(){if(this.pos+4>this.len)throw el(this,4);var er=ea.float.readFloatLE(this.buf,this.pos);return this.pos+=4,er},ec.prototype.double=function(){if(this.pos+8>this.len)throw el(this,4);var er=ea.float.readDoubleLE(this.buf,this.pos);return this.pos+=8,er},ec.prototype.bytes=function(){var er=this.uint32(),en=this.pos,ei=this.pos+er;if(ei>this.len)throw el(this,er);return this.pos+=er,Array.isArray(this.buf)?this.buf.slice(en,ei):en===ei?new this.buf.constructor(0):this._slice.call(this.buf,en,ei)},ec.prototype.string=function(){var er=this.bytes();return eu.read(er,0,er.length)},ec.prototype.skip=function(er){if("number"==typeof er){if(this.pos+er>this.len)throw el(this,er);this.pos+=er}else do if(this.pos>=this.len)throw el(this);while(128&this.buf[this.pos++]);return this},ec.prototype.skipType=function(er){switch(er){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;4!=(er=7&this.uint32());)this.skipType(er);break;case 5:this.skip(4);break;default:throw Error("invalid wire type "+er+" at offset "+this.pos)}return this},ec._configure=function(er){eo=er,ec.create=ef(),eo._configure();var en=ea.Long?"toLong":"toNumber";ea.merge(ec.prototype,{int64:function(){return eh.call(this)[en](!1)},uint64:function(){return eh.call(this)[en](!0)},sint64:function(){return eh.call(this).zzDecode()[en](!1)},fixed64:function(){return em.call(this)[en](!0)},sfixed64:function(){return em.call(this)[en](!1)}})}},593:(er,en,ei)=>{"use strict";er.exports=es;var eo=ei(1408);(es.prototype=Object.create(eo.prototype)).constructor=es;var ea=ei(9693);function es(er){eo.call(this,er)}es._configure=function(){ea.Buffer&&(es.prototype._slice=ea.Buffer.prototype.slice)},es.prototype.string=function(){var er=this.uint32();return this.buf.utf8Slice?this.buf.utf8Slice(this.pos,this.pos=Math.min(this.pos+er,this.len)):this.buf.toString("utf-8",this.pos,this.pos=Math.min(this.pos+er,this.len))},es._configure()},5054:er=>{"use strict";er.exports={}},5994:(er,en,ei)=>{"use strict";en.Service=ei(7948)},7948:(er,en,ei)=>{"use strict";er.exports=ea;var eo=ei(9693);function ea(er,en,ei){if("function"!=typeof er)throw TypeError("rpcImpl must be a function");eo.EventEmitter.call(this),this.rpcImpl=er,this.requestDelimited=!!en,this.responseDelimited=!!ei}(ea.prototype=Object.create(eo.EventEmitter.prototype)).constructor=ea,ea.prototype.rpcCall=function er(en,ei,ea,es,eu){if(!es)throw TypeError("request must be specified");var el=this;if(!eu)return eo.asPromise(er,el,en,ei,ea,es);if(el.rpcImpl)try{return el.rpcImpl(en,ei[el.requestDelimited?"encodeDelimited":"encode"](es).finish(),function(er,ei){if(er)return el.emit("error",er,en),eu(er);if(null!==ei){if(!(ei instanceof ea))try{ei=ea[el.responseDelimited?"decodeDelimited":"decode"](ei)}catch(er){return el.emit("error",er,en),eu(er)}return el.emit("data",ei,en),eu(null,ei)}el.end(!0)})}catch(er){return el.emit("error",er,en),void setTimeout(function(){eu(er)},0)}else setTimeout(function(){eu(Error("already ended"))},0)},ea.prototype.end=function(er){return this.rpcImpl&&(er||this.rpcImpl(null,null,null),this.rpcImpl=null,this.emit("end").off()),this}},1945:(er,en,ei)=>{"use strict";er.exports=ea;var eo=ei(9693);function ea(er,en){this.lo=er>>>0,this.hi=en>>>0}var es=ea.zero=new ea(0,0);es.toNumber=function(){return 0},es.zzEncode=es.zzDecode=function(){return this},es.length=function(){return 1};var eu=ea.zeroHash="\x00\x00\x00\x00\x00\x00\x00\x00";ea.fromNumber=function(er){if(0===er)return es;var en=er<0;en&&(er=-er);var ei=er>>>0,eo=(er-ei)/4294967296>>>0;return en&&(eo=~eo>>>0,ei=~ei>>>0,++ei>4294967295&&(ei=0,++eo>4294967295&&(eo=0))),new ea(ei,eo)},ea.from=function(er){if("number"==typeof er)return ea.fromNumber(er);if(eo.isString(er)){if(!eo.Long)return ea.fromNumber(parseInt(er,10));er=eo.Long.fromString(er)}return er.low||er.high?new ea(er.low>>>0,er.high>>>0):es},ea.prototype.toNumber=function(er){if(!er&&this.hi>>>31){var en=1+~this.lo>>>0,ei=~this.hi>>>0;return en||(ei=ei+1>>>0),-(en+4294967296*ei)}return this.lo+4294967296*this.hi},ea.prototype.toLong=function(er){return eo.Long?new eo.Long(0|this.lo,0|this.hi,!!er):{low:0|this.lo,high:0|this.hi,unsigned:!!er}};var el=String.prototype.charCodeAt;ea.fromHash=function(er){return er===eu?es:new ea((el.call(er,0)|el.call(er,1)<<8|el.call(er,2)<<16|el.call(er,3)<<24)>>>0,(el.call(er,4)|el.call(er,5)<<8|el.call(er,6)<<16|el.call(er,7)<<24)>>>0)},ea.prototype.toHash=function(){return String.fromCharCode(255&this.lo,this.lo>>>8&255,this.lo>>>16&255,this.lo>>>24,255&this.hi,this.hi>>>8&255,this.hi>>>16&255,this.hi>>>24)},ea.prototype.zzEncode=function(){var er=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^er)>>>0,this.lo=(this.lo<<1^er)>>>0,this},ea.prototype.zzDecode=function(){var er=-(1&this.lo);return this.lo=((this.lo>>>1|this.hi<<31)^er)>>>0,this.hi=(this.hi>>>1^er)>>>0,this},ea.prototype.length=function(){var er=this.lo,en=(this.lo>>>28|this.hi<<4)>>>0,ei=this.hi>>>24;return 0===ei?0===en?er<16384?er<128?1:2:er<2097152?3:4:en<16384?en<128?5:6:en<2097152?7:8:ei<128?9:10}},9693:function(er,en,ei){"use strict";var eo=en;function ea(er,en,ei){for(var eo=Object.keys(en),ea=0;ea<eo.length;++ea)void 0!==er[eo[ea]]&&ei||(er[eo[ea]]=en[eo[ea]]);return er}function es(er){function en(er,ei){if(!(this instanceof en))return new en(er,ei);Object.defineProperty(this,"message",{get:function(){return er}}),Error.captureStackTrace?Error.captureStackTrace(this,en):Object.defineProperty(this,"stack",{value:Error().stack||""}),ei&&ea(this,ei)}return(en.prototype=Object.create(Error.prototype)).constructor=en,Object.defineProperty(en.prototype,"name",{get:function(){return er}}),en.prototype.toString=function(){return this.name+": "+this.message},en}eo.asPromise=ei(4537),eo.base64=ei(7419),eo.EventEmitter=ei(9211),eo.float=ei(945),eo.inquire=ei(7199),eo.utf8=ei(4997),eo.pool=ei(6662),eo.LongBits=ei(1945),eo.isNode=!!(void 0!==ei.g&&ei.g&&ei.g.process&&ei.g.process.versions&&ei.g.process.versions.node),eo.global=eo.isNode&&ei.g||"undefined"!=typeof window&&window||"undefined"!=typeof self&&self||this,eo.emptyArray=Object.freeze?Object.freeze([]):[],eo.emptyObject=Object.freeze?Object.freeze({}):{},eo.isInteger=Number.isInteger||function(er){return"number"==typeof er&&isFinite(er)&&Math.floor(er)===er},eo.isString=function(er){return"string"==typeof er||er instanceof String},eo.isObject=function(er){return er&&"object"==typeof er},eo.isset=eo.isSet=function(er,en){var ei=er[en];return!(null==ei||!er.hasOwnProperty(en))&&("object"!=typeof ei||(Array.isArray(ei)?ei.length:Object.keys(ei).length)>0)},eo.Buffer=function(){try{var er=eo.inquire("buffer").Buffer;return er.prototype.utf8Write?er:null}catch(er){return null}}(),eo._Buffer_from=null,eo._Buffer_allocUnsafe=null,eo.newBuffer=function(er){return"number"==typeof er?eo.Buffer?eo._Buffer_allocUnsafe(er):new eo.Array(er):eo.Buffer?eo._Buffer_from(er):"undefined"==typeof Uint8Array?er:new Uint8Array(er)},eo.Array="undefined"!=typeof Uint8Array?Uint8Array:Array,eo.Long=eo.global.dcodeIO&&eo.global.dcodeIO.Long||eo.global.Long||eo.inquire("long"),eo.key2Re=/^true|false|0|1$/,eo.key32Re=/^-?(?:0|[1-9][0-9]*)$/,eo.key64Re=/^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/,eo.longToHash=function(er){return er?eo.LongBits.from(er).toHash():eo.LongBits.zeroHash},eo.longFromHash=function(er,en){var ei=eo.LongBits.fromHash(er);return eo.Long?eo.Long.fromBits(ei.lo,ei.hi,en):ei.toNumber(!!en)},eo.merge=ea,eo.lcFirst=function(er){return er.charAt(0).toLowerCase()+er.substring(1)},eo.newError=es,eo.ProtocolError=es("ProtocolError"),eo.oneOfGetter=function(er){for(var en={},ei=0;ei<er.length;++ei)en[er[ei]]=1;return function(){for(var er=Object.keys(this),ei=er.length-1;ei>-1;--ei)if(1===en[er[ei]]&&void 0!==this[er[ei]]&&null!==this[er[ei]])return er[ei]}},eo.oneOfSetter=function(er){return function(en){for(var ei=0;ei<er.length;++ei)er[ei]!==en&&delete this[er[ei]]}},eo.toJSONOptions={longs:String,enums:String,bytes:String,json:!0},eo._configure=function(){var er=eo.Buffer;er?(eo._Buffer_from=er.from!==Uint8Array.from&&er.from||function(en,ei){return new er(en,ei)},eo._Buffer_allocUnsafe=er.allocUnsafe||function(en){return new er(en)}):eo._Buffer_from=eo._Buffer_allocUnsafe=null}},1173:(er,en,ei)=>{"use strict";er.exports=ef;var eo,ea=ei(9693),es=ea.LongBits,eu=ea.base64,el=ea.utf8;function ec(er,en,ei){this.fn=er,this.len=en,this.next=void 0,this.val=ei}function ep(){}function ed(er){this.head=er.head,this.tail=er.tail,this.len=er.len,this.next=er.states}function ef(){this.len=0,this.head=new ec(ep,0,0),this.tail=this.head,this.states=null}var eh=function(){return ea.Buffer?function(){return(ef.create=function(){return new eo})()}:function(){return new ef}};function eg(er,en,ei){en[ei]=255&er}function em(er,en){this.len=er,this.next=void 0,this.val=en}function eb(er,en,ei){for(;er.hi;)en[ei++]=127&er.lo|128,er.lo=(er.lo>>>7|er.hi<<25)>>>0,er.hi>>>=7;for(;er.lo>127;)en[ei++]=127&er.lo|128,er.lo=er.lo>>>7;en[ei++]=er.lo}function ey(er,en,ei){en[ei]=255&er,en[ei+1]=er>>>8&255,en[ei+2]=er>>>16&255,en[ei+3]=er>>>24}ef.create=eh(),ef.alloc=function(er){return new ea.Array(er)},ea.Array!==Array&&(ef.alloc=ea.pool(ef.alloc,ea.Array.prototype.subarray)),ef.prototype._push=function(er,en,ei){return this.tail=this.tail.next=new ec(er,en,ei),this.len+=en,this},em.prototype=Object.create(ec.prototype),em.prototype.fn=function(er,en,ei){for(;er>127;)en[ei++]=127&er|128,er>>>=7;en[ei]=er},ef.prototype.uint32=function(er){return this.len+=(this.tail=this.tail.next=new em((er>>>=0)<128?1:er<16384?2:er<2097152?3:er<268435456?4:5,er)).len,this},ef.prototype.int32=function(er){return er<0?this._push(eb,10,es.fromNumber(er)):this.uint32(er)},ef.prototype.sint32=function(er){return this.uint32((er<<1^er>>31)>>>0)},ef.prototype.uint64=function(er){var en=es.from(er);return this._push(eb,en.length(),en)},ef.prototype.int64=ef.prototype.uint64,ef.prototype.sint64=function(er){var en=es.from(er).zzEncode();return this._push(eb,en.length(),en)},ef.prototype.bool=function(er){return this._push(eg,1,er?1:0)},ef.prototype.fixed32=function(er){return this._push(ey,4,er>>>0)},ef.prototype.sfixed32=ef.prototype.fixed32,ef.prototype.fixed64=function(er){var en=es.from(er);return this._push(ey,4,en.lo)._push(ey,4,en.hi)},ef.prototype.sfixed64=ef.prototype.fixed64,ef.prototype.float=function(er){return this._push(ea.float.writeFloatLE,4,er)},ef.prototype.double=function(er){return this._push(ea.float.writeDoubleLE,8,er)};var ev=ea.Array.prototype.set?function(er,en,ei){en.set(er,ei)}:function(er,en,ei){for(var eo=0;eo<er.length;++eo)en[ei+eo]=er[eo]};ef.prototype.bytes=function(er){var en=er.length>>>0;if(!en)return this._push(eg,1,0);if(ea.isString(er)){var ei=ef.alloc(en=eu.length(er));eu.decode(er,ei,0),er=ei}return this.uint32(en)._push(ev,en,er)},ef.prototype.string=function(er){var en=el.length(er);return en?this.uint32(en)._push(el.write,en,er):this._push(eg,1,0)},ef.prototype.fork=function(){return this.states=new ed(this),this.head=this.tail=new ec(ep,0,0),this.len=0,this},ef.prototype.reset=function(){return this.states?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new ec(ep,0,0),this.len=0),this},ef.prototype.ldelim=function(){var er=this.head,en=this.tail,ei=this.len;return this.reset().uint32(ei),ei&&(this.tail.next=er.next,this.tail=en,this.len+=ei),this},ef.prototype.finish=function(){for(var er=this.head.next,en=this.constructor.alloc(this.len),ei=0;er;)er.fn(er.val,en,ei),ei+=er.len,er=er.next;return en},ef._configure=function(er){eo=er,ef.create=eh(),eo._configure()}},3155:(er,en,ei)=>{"use strict";er.exports=es;var eo=ei(1173);(es.prototype=Object.create(eo.prototype)).constructor=es;var ea=ei(9693);function es(){eo.call(this)}function eu(er,en,ei){er.length<40?ea.utf8.write(er,en,ei):en.utf8Write?en.utf8Write(er,ei):en.write(er,ei)}es._configure=function(){es.alloc=ea._Buffer_allocUnsafe,es.writeBytesBuffer=ea.Buffer&&ea.Buffer.prototype instanceof Uint8Array&&"set"===ea.Buffer.prototype.set.name?function(er,en,ei){en.set(er,ei)}:function(er,en,ei){if(er.copy)er.copy(en,ei,0,er.length);else for(var eo=0;eo<er.length;)en[ei++]=er[eo++]}},es.prototype.bytes=function(er){ea.isString(er)&&(er=ea._Buffer_from(er,"base64"));var en=er.length>>>0;return this.uint32(en),en&&this._push(es.writeBytesBuffer,en,er),this},es.prototype.string=function(er){var en=ea.Buffer.byteLength(er);return this.uint32(en),en&&this._push(eu,en,er),this},es._configure()},4154:er=>{"use strict";er.exports='"use strict";var e={},t="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(t){var r=require("worker_threads"),a=r.parentPort;a.on("message",(e=>onmessage({data:e})));var o=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:function(e){(0,eval)(o.readFileSync(e,"utf8"))},postMessage:function(e){a.postMessage(e)},performance:global.performance||{now:function(){return Date.now()}}})}var s=!1,n=[],i=function(){var e=Array.prototype.slice.call(arguments).join(" ");t?o.writeSync(2,e+"\\n"):console.error(e)};self.alert=function(){var t=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:t,threadId:e._pthread_self()})},e.instantiateWasm=(t,r)=>{var a=new WebAssembly.Instance(e.wasmModule,t);return r(a),e.wasmModule=null,a.exports},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=t=>{try{if("load"===t.data.cmd){if(e.wasmModule=t.data.wasmModule,e.wasmMemory=t.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof t.data.urlOrBlob)importScripts(t.data.urlOrBlob);else{var r=URL.createObjectURL(t.data.urlOrBlob);importScripts(r),URL.revokeObjectURL(r)}ortWasmThreaded(e).then((function(t){e=t}))}else if("run"===t.data.cmd){e.__performance_now_clock_drift=performance.now()-t.data.time,e.__emscripten_thread_init(t.data.pthread_ptr,0,0,1),e.establishStackSpace(),e.PThread.receiveObjectTransfer(t.data),e.PThread.threadInitTLS(),s||(n.forEach((t=>{e.executeNotifiedProxyingQueue(t)})),n=[],s=!0);try{e.invokeEntryPoint(t.data.start_routine,t.data.arg)}catch(t){if("unwind"!=t){if(!(t instanceof e.ExitStatus))throw t;e.keepRuntimeAlive()||e.__emscripten_thread_exit(t.status)}}}else"cancel"===t.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===t.data.target||("processProxyingQueue"===t.data.cmd?s?e.executeNotifiedProxyingQueue(t.data.queue):n.push(t.data.queue):(i("worker.js received unknown command "+t.data.cmd),i(t.data)))}catch(t){throw i("worker.js onmessage() captured an uncaught exception: "+t),t&&t.stack&&i(t.stack),e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),t}};\n'},7067:()=>{},1296:()=>{},760:()=>{},1384:()=>{},3993:()=>{},908:()=>{},6953:()=>{},9925:()=>{},2806:()=>{},6449:()=>{},2850:()=>{},5381:()=>{},5686:(er,en,ei)=>{"use strict";ei.r(en),ei.d(en,{flatbuffers:()=>eo});var eo={};eo.Offset,eo.Table,eo.SIZEOF_SHORT=2,eo.SIZEOF_INT=4,eo.FILE_IDENTIFIER_LENGTH=4,eo.SIZE_PREFIX_LENGTH=4,eo.Encoding={UTF8_BYTES:1,UTF16_STRING:2},eo.int32=new Int32Array(2),eo.float32=new Float32Array(eo.int32.buffer),eo.float64=new Float64Array(eo.int32.buffer),eo.isLittleEndian=1===new Uint16Array(new Uint8Array([1,0]).buffer)[0],eo.Long=function(er,en){this.low=0|er,this.high=0|en},eo.Long.create=function(er,en){return 0==er&&0==en?eo.Long.ZERO:new eo.Long(er,en)},eo.Long.prototype.toFloat64=function(){return(this.low>>>0)+4294967296*this.high},eo.Long.prototype.equals=function(er){return this.low==er.low&&this.high==er.high},eo.Long.ZERO=new eo.Long(0,0),eo.Builder=function(er){if(er)en=er;else var en=1024;this.bb=eo.ByteBuffer.allocate(en),this.space=en,this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},eo.Builder.prototype.clear=function(){this.bb.clear(),this.space=this.bb.capacity(),this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},eo.Builder.prototype.forceDefaults=function(er){this.force_defaults=er},eo.Builder.prototype.dataBuffer=function(){return this.bb},eo.Builder.prototype.asUint8Array=function(){return this.bb.bytes().subarray(this.bb.position(),this.bb.position()+this.offset())},eo.Builder.prototype.prep=function(er,en){er>this.minalign&&(this.minalign=er);for(var ei=1+~(this.bb.capacity()-this.space+en)&er-1;this.space<ei+er+en;){var ea=this.bb.capacity();this.bb=eo.Builder.growByteBuffer(this.bb),this.space+=this.bb.capacity()-ea}this.pad(ei)},eo.Builder.prototype.pad=function(er){for(var en=0;en<er;en++)this.bb.writeInt8(--this.space,0)},eo.Builder.prototype.writeInt8=function(er){this.bb.writeInt8(this.space-=1,er)},eo.Builder.prototype.writeInt16=function(er){this.bb.writeInt16(this.space-=2,er)},eo.Builder.prototype.writeInt32=function(er){this.bb.writeInt32(this.space-=4,er)},eo.Builder.prototype.writeInt64=function(er){this.bb.writeInt64(this.space-=8,er)},eo.Builder.prototype.writeFloat32=function(er){this.bb.writeFloat32(this.space-=4,er)},eo.Builder.prototype.writeFloat64=function(er){this.bb.writeFloat64(this.space-=8,er)},eo.Builder.prototype.addInt8=function(er){this.prep(1,0),this.writeInt8(er)},eo.Builder.prototype.addInt16=function(er){this.prep(2,0),this.writeInt16(er)},eo.Builder.prototype.addInt32=function(er){this.prep(4,0),this.writeInt32(er)},eo.Builder.prototype.addInt64=function(er){this.prep(8,0),this.writeInt64(er)},eo.Builder.prototype.addFloat32=function(er){this.prep(4,0),this.writeFloat32(er)},eo.Builder.prototype.addFloat64=function(er){this.prep(8,0),this.writeFloat64(er)},eo.Builder.prototype.addFieldInt8=function(er,en,ei){(this.force_defaults||en!=ei)&&(this.addInt8(en),this.slot(er))},eo.Builder.prototype.addFieldInt16=function(er,en,ei){(this.force_defaults||en!=ei)&&(this.addInt16(en),this.slot(er))},eo.Builder.prototype.addFieldInt32=function(er,en,ei){(this.force_defaults||en!=ei)&&(this.addInt32(en),this.slot(er))},eo.Builder.prototype.addFieldInt64=function(er,en,ei){!this.force_defaults&&en.equals(ei)||(this.addInt64(en),this.slot(er))},eo.Builder.prototype.addFieldFloat32=function(er,en,ei){(this.force_defaults||en!=ei)&&(this.addFloat32(en),this.slot(er))},eo.Builder.prototype.addFieldFloat64=function(er,en,ei){(this.force_defaults||en!=ei)&&(this.addFloat64(en),this.slot(er))},eo.Builder.prototype.addFieldOffset=function(er,en,ei){(this.force_defaults||en!=ei)&&(this.addOffset(en),this.slot(er))},eo.Builder.prototype.addFieldStruct=function(er,en,ei){en!=ei&&(this.nested(en),this.slot(er))},eo.Builder.prototype.nested=function(er){if(er!=this.offset())throw Error("FlatBuffers: struct must be serialized inline.")},eo.Builder.prototype.notNested=function(){if(this.isNested)throw Error("FlatBuffers: object serialization must not be nested.")},eo.Builder.prototype.slot=function(er){this.vtable[er]=this.offset()},eo.Builder.prototype.offset=function(){return this.bb.capacity()-this.space},eo.Builder.growByteBuffer=function(er){var en=er.capacity();if(3221225472&en)throw Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");var ei=en<<1,ea=eo.ByteBuffer.allocate(ei);return ea.setPosition(ei-en),ea.bytes().set(er.bytes(),ei-en),ea},eo.Builder.prototype.addOffset=function(er){this.prep(eo.SIZEOF_INT,0),this.writeInt32(this.offset()-er+eo.SIZEOF_INT)},eo.Builder.prototype.startObject=function(er){this.notNested(),null==this.vtable&&(this.vtable=[]),this.vtable_in_use=er;for(var en=0;en<er;en++)this.vtable[en]=0;this.isNested=!0,this.object_start=this.offset()},eo.Builder.prototype.endObject=function(){if(null==this.vtable||!this.isNested)throw Error("FlatBuffers: endObject called without startObject");this.addInt32(0);for(var er=this.offset(),en=this.vtable_in_use-1;en>=0&&0==this.vtable[en];en--);for(var ei=en+1;en>=0;en--)this.addInt16(0!=this.vtable[en]?er-this.vtable[en]:0);this.addInt16(er-this.object_start);var ea=(ei+2)*eo.SIZEOF_SHORT;this.addInt16(ea);var es=0,eu=this.space;e:for(en=0;en<this.vtables.length;en++){var el=this.bb.capacity()-this.vtables[en];if(ea==this.bb.readInt16(el)){for(var ec=eo.SIZEOF_SHORT;ec<ea;ec+=eo.SIZEOF_SHORT)if(this.bb.readInt16(eu+ec)!=this.bb.readInt16(el+ec))continue e;es=this.vtables[en];break}}return es?(this.space=this.bb.capacity()-er,this.bb.writeInt32(this.space,es-er)):(this.vtables.push(this.offset()),this.bb.writeInt32(this.bb.capacity()-er,this.offset()-er)),this.isNested=!1,er},eo.Builder.prototype.finish=function(er,en,ei){var ea=ei?eo.SIZE_PREFIX_LENGTH:0;if(en){var es=en;if(this.prep(this.minalign,eo.SIZEOF_INT+eo.FILE_IDENTIFIER_LENGTH+ea),es.length!=eo.FILE_IDENTIFIER_LENGTH)throw Error("FlatBuffers: file identifier must be length "+eo.FILE_IDENTIFIER_LENGTH);for(var eu=eo.FILE_IDENTIFIER_LENGTH-1;eu>=0;eu--)this.writeInt8(es.charCodeAt(eu))}this.prep(this.minalign,eo.SIZEOF_INT+ea),this.addOffset(er),ea&&this.addInt32(this.bb.capacity()-this.space),this.bb.setPosition(this.space)},eo.Builder.prototype.finishSizePrefixed=function(er,en){this.finish(er,en,!0)},eo.Builder.prototype.requiredField=function(er,en){var ei=this.bb.capacity()-er,eo=ei-this.bb.readInt32(ei);if(0==this.bb.readInt16(eo+en))throw Error("FlatBuffers: field "+en+" must be set")},eo.Builder.prototype.startVector=function(er,en,ei){this.notNested(),this.vector_num_elems=en,this.prep(eo.SIZEOF_INT,er*en),this.prep(ei,er*en)},eo.Builder.prototype.endVector=function(){return this.writeInt32(this.vector_num_elems),this.offset()},eo.Builder.prototype.createString=function(er){if(er instanceof Uint8Array)var en=er;else{en=[];for(var ei=0;ei<er.length;){var eo,ea=er.charCodeAt(ei++);(eo=ea<55296||ea>=56320?ea:(ea<<10)+er.charCodeAt(ei++)+-56613888)<128?en.push(eo):(eo<2048?en.push(eo>>6&31|192):(eo<65536?en.push(eo>>12&15|224):en.push(eo>>18&7|240,eo>>12&63|128),en.push(eo>>6&63|128)),en.push(63&eo|128))}}this.addInt8(0),this.startVector(1,en.length,1),this.bb.setPosition(this.space-=en.length),ei=0;for(var es=this.space,eu=this.bb.bytes();ei<en.length;ei++)eu[es++]=en[ei];return this.endVector()},eo.Builder.prototype.createLong=function(er,en){return eo.Long.create(er,en)},eo.ByteBuffer=function(er){this.bytes_=er,this.position_=0},eo.ByteBuffer.allocate=function(er){return new eo.ByteBuffer(new Uint8Array(er))},eo.ByteBuffer.prototype.clear=function(){this.position_=0},eo.ByteBuffer.prototype.bytes=function(){return this.bytes_},eo.ByteBuffer.prototype.position=function(){return this.position_},eo.ByteBuffer.prototype.setPosition=function(er){this.position_=er},eo.ByteBuffer.prototype.capacity=function(){return this.bytes_.length},eo.ByteBuffer.prototype.readInt8=function(er){return this.readUint8(er)<<24>>24},eo.ByteBuffer.prototype.readUint8=function(er){return this.bytes_[er]},eo.ByteBuffer.prototype.readInt16=function(er){return this.readUint16(er)<<16>>16},eo.ByteBuffer.prototype.readUint16=function(er){return this.bytes_[er]|this.bytes_[er+1]<<8},eo.ByteBuffer.prototype.readInt32=function(er){return this.bytes_[er]|this.bytes_[er+1]<<8|this.bytes_[er+2]<<16|this.bytes_[er+3]<<24},eo.ByteBuffer.prototype.readUint32=function(er){return this.readInt32(er)>>>0},eo.ByteBuffer.prototype.readInt64=function(er){return new eo.Long(this.readInt32(er),this.readInt32(er+4))},eo.ByteBuffer.prototype.readUint64=function(er){return new eo.Long(this.readUint32(er),this.readUint32(er+4))},eo.ByteBuffer.prototype.readFloat32=function(er){return eo.int32[0]=this.readInt32(er),eo.float32[0]},eo.ByteBuffer.prototype.readFloat64=function(er){return eo.int32[eo.isLittleEndian?0:1]=this.readInt32(er),eo.int32[eo.isLittleEndian?1:0]=this.readInt32(er+4),eo.float64[0]},eo.ByteBuffer.prototype.writeInt8=function(er,en){this.bytes_[er]=en},eo.ByteBuffer.prototype.writeUint8=function(er,en){this.bytes_[er]=en},eo.ByteBuffer.prototype.writeInt16=function(er,en){this.bytes_[er]=en,this.bytes_[er+1]=en>>8},eo.ByteBuffer.prototype.writeUint16=function(er,en){this.bytes_[er]=en,this.bytes_[er+1]=en>>8},eo.ByteBuffer.prototype.writeInt32=function(er,en){this.bytes_[er]=en,this.bytes_[er+1]=en>>8,this.bytes_[er+2]=en>>16,this.bytes_[er+3]=en>>24},eo.ByteBuffer.prototype.writeUint32=function(er,en){this.bytes_[er]=en,this.bytes_[er+1]=en>>8,this.bytes_[er+2]=en>>16,this.bytes_[er+3]=en>>24},eo.ByteBuffer.prototype.writeInt64=function(er,en){this.writeInt32(er,en.low),this.writeInt32(er+4,en.high)},eo.ByteBuffer.prototype.writeUint64=function(er,en){this.writeUint32(er,en.low),this.writeUint32(er+4,en.high)},eo.ByteBuffer.prototype.writeFloat32=function(er,en){eo.float32[0]=en,this.writeInt32(er,eo.int32[0])},eo.ByteBuffer.prototype.writeFloat64=function(er,en){eo.float64[0]=en,this.writeInt32(er,eo.int32[eo.isLittleEndian?0:1]),this.writeInt32(er+4,eo.int32[eo.isLittleEndian?1:0])},eo.ByteBuffer.prototype.getBufferIdentifier=function(){if(this.bytes_.length<this.position_+eo.SIZEOF_INT+eo.FILE_IDENTIFIER_LENGTH)throw Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");for(var er="",en=0;en<eo.FILE_IDENTIFIER_LENGTH;en++)er+=String.fromCharCode(this.readInt8(this.position_+eo.SIZEOF_INT+en));return er},eo.ByteBuffer.prototype.__offset=function(er,en){var ei=er-this.readInt32(er);return en<this.readInt16(ei)?this.readInt16(ei+en):0},eo.ByteBuffer.prototype.__union=function(er,en){return er.bb_pos=en+this.readInt32(en),er.bb=this,er},eo.ByteBuffer.prototype.__string=function(er,en){er+=this.readInt32(er);var ei=this.readInt32(er),ea="",es=0;if(er+=eo.SIZEOF_INT,en===eo.Encoding.UTF8_BYTES)return this.bytes_.subarray(er,er+ei);for(;es<ei;){var eu,el=this.readUint8(er+es++);if(el<192)eu=el;else{var ec=this.readUint8(er+es++);if(el<224)eu=(31&el)<<6|63&ec;else{var ep=this.readUint8(er+es++);eu=el<240?(15&el)<<12|(63&ec)<<6|63&ep:(7&el)<<18|(63&ec)<<12|(63&ep)<<6|63&this.readUint8(er+es++)}}eu<65536?ea+=String.fromCharCode(eu):(eu-=65536,ea+=String.fromCharCode(55296+(eu>>10),56320+(1023&eu)))}return ea},eo.ByteBuffer.prototype.__indirect=function(er){return er+this.readInt32(er)},eo.ByteBuffer.prototype.__vector=function(er){return er+this.readInt32(er)+eo.SIZEOF_INT},eo.ByteBuffer.prototype.__vector_len=function(er){return this.readInt32(er+this.readInt32(er))},eo.ByteBuffer.prototype.__has_identifier=function(er){if(er.length!=eo.FILE_IDENTIFIER_LENGTH)throw Error("FlatBuffers: file identifier must be length "+eo.FILE_IDENTIFIER_LENGTH);for(var en=0;en<eo.FILE_IDENTIFIER_LENGTH;en++)if(er.charCodeAt(en)!=this.readInt8(this.position_+eo.SIZEOF_INT+en))return!1;return!0},eo.ByteBuffer.prototype.createLong=function(er,en){return eo.Long.create(er,en)}}},__webpack_module_cache__={};function __nested_webpack_require_606622__(er){var en=__webpack_module_cache__[er];if(void 0!==en)return en.exports;var ei=__webpack_module_cache__[er]={exports:{}};return __webpack_modules__[er].call(ei.exports,ei,ei.exports,__nested_webpack_require_606622__),ei.exports}__nested_webpack_require_606622__.n=er=>{var en=er&&er.__esModule?()=>er.default:()=>er;return __nested_webpack_require_606622__.d(en,{a:en}),en},__nested_webpack_require_606622__.d=(er,en)=>{for(var ei in en)__nested_webpack_require_606622__.o(en,ei)&&!__nested_webpack_require_606622__.o(er,ei)&&Object.defineProperty(er,ei,{enumerable:!0,get:en[ei]})},__nested_webpack_require_606622__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||Function("return this")()}catch(er){if("object"==typeof window)return window}}(),__nested_webpack_require_606622__.o=(er,en)=>Object.prototype.hasOwnProperty.call(er,en),__nested_webpack_require_606622__.r=er=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(er,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(er,"__esModule",{value:!0})};var __webpack_exports__=__nested_webpack_require_606622__(1057);return __webpack_exports__})())}}]);